import { Component, ElementRef, Input, Output, EventEmitter, ChangeDetectionStrategy, ViewChild, Renderer2, } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import { DatetimeAdapter, MAT_DATETIME_FORMATS, } from '@mat-datetimepicker/core';
import { PepLayoutService, PepUtilitiesService, PepCustomizationService, DEFAULT_HORIZONTAL_ALIGNMENT, PepDateField, } from '@pepperi-addons/ngx-lib';
import { utc } from 'moment/moment';
import { MomentUtcDateAdapter, MomentUtcDateTimeAdapter, MY_DATE_FORMATS } from './date.model';
const ɵ0 = MY_DATE_FORMATS, ɵ1 = MY_DATE_FORMATS;
export class PepDateComponent {
    constructor(adapter, element, layoutService, utilitiesService, customizationService, renderer) {
        this.adapter = adapter;
        this.element = element;
        this.layoutService = layoutService;
        this.utilitiesService = utilitiesService;
        this.customizationService = customizationService;
        this.renderer = renderer;
        this.key = '';
        this._value = '';
        this.formattedValue = '';
        this.label = '';
        this._type = 'date';
        this.mandatory = false;
        this.disabled = false;
        this.readonly = false;
        this.textColor = '';
        this.xAlignment = DEFAULT_HORIZONTAL_ALIGNMENT;
        this.rowSpan = 1;
        this._visible = true;
        this.controlType = 'date';
        this.form = null;
        this.isActive = false;
        this.showTitle = true;
        this.renderTitle = true;
        this.renderError = true;
        this.renderSymbol = true;
        this.layoutType = 'form';
        this.valueChange = new EventEmitter();
        this.standAlone = false;
        this.isInEditMode = false;
        this.showDatepicker = false;
        this.showTime = false;
    }
    set value(value) {
        this._value = value;
        this.setDateModel();
    }
    get value() {
        return this._value;
    }
    set type(type) {
        this._type = type;
        this.showTime = type === 'datetime';
    }
    get type() {
        return this._type;
    }
    set visible(visible) {
        this._visible = visible;
        if (visible) {
            this.renderer.removeClass(this.element.nativeElement, 'hidden-element');
        }
        else {
            this.renderer.addClass(this.element.nativeElement, 'hidden-element');
        }
    }
    get visible() {
        return this._visible;
    }
    // Minimum in thicks
    set minValue(value) {
        if (value > 0) {
            this.minDate = new Date(value * 1000 * 60 * 60 * 24);
        }
    }
    // Maximum in thicks
    set maxValue(value) {
        if (value > 0) {
            this.maxDate = new Date(value * 1000 * 60 * 60 * 24);
        }
    }
    // Minimum in date
    set minDateValue(date) {
        this.minDate = date ? new Date(date) : null;
    }
    // Maximum in date
    set maxDateValue(date) {
        this.maxDate = date ? new Date(date) : null;
    }
    setDefaultForm() {
        const pepField = new PepDateField({
            key: this.key,
            value: this.value,
            mandatory: this.mandatory,
            readonly: this.readonly,
            disabled: this.disabled,
        });
        this.form = this.customizationService.getDefaultFromGroup(pepField);
    }
    ngOnInit() {
        if (this.form === null) {
            this.standAlone = true;
            this.setDefaultForm();
            this.renderer.addClass(this.element.nativeElement, PepCustomizationService.STAND_ALONE_FIELD_CLASS_NAME);
        }
        const culture = this.layoutService.getCurrentLanguage();
        this.adapter.setLocale(culture);
        this.setDateModel();
    }
    ngOnChanges(changes) {
        if (this.standAlone) {
            this.setDefaultForm();
        }
    }
    ngOnDestroy() {
        //
    }
    setFormattedValueFromModel() {
        if (this.dateModel === null || !this.dateModel.isValid()) {
            this.formattedValue = '';
        }
        else {
            const format = this.showTime
                ? MY_DATE_FORMATS.display.datetimeInput
                : MY_DATE_FORMATS.display.dateInput;
            this.formattedValue = this.adapter.format(this.dateModel, format);
        }
    }
    setDateModel() {
        if (this.value === null ||
            this.value === '' ||
            this.value.indexOf('1900-1-1') >= 0 ||
            this.value.indexOf('1900-01-01') >= 0 ||
            this.value.indexOf('1970-1-1') >= 0 ||
            this.value.indexOf('1970-01-01') >= 0) {
            this._value = '';
            this.dateModel = null;
        }
        else {
            this.dateModel = utc(this.utilitiesService.parseDate(this.value, this.showTime));
        }
        this.setFormattedValueFromModel();
    }
    openDatetimePicker(datetimePicker) {
        datetimePicker.opened = false;
        datetimePicker.open();
    }
    onBlur(event) {
        // Don't remove the timeout cause a bug DI-17819.
        setTimeout(() => {
            if (this.isInEditMode && !this.datetimePicker.opened) {
                this.isInEditMode = false;
            }
        }, 0);
    }
    onDateChange(event) {
        let value = '';
        if (event.value != null) {
            const date = event.value.toDate();
            value = this.utilitiesService.stringifyDate(date, this.showTime);
            // Update the formatted value.
            this.setFormattedValueFromModel();
        }
        this.customizationService.updateFormFieldValue(this.form, this.key, 
        // this.formattedValue
        value);
        this.valueChange.emit(value);
        setTimeout(() => {
            if (this.isInEditMode) {
                this.isInEditMode = false;
            }
        }, 0);
    }
    cardTemplateClicked(event) {
        this.isInEditMode = true;
        setTimeout(() => {
            this.input.nativeElement.focus();
            this.openDatetimePicker(this.datetimePicker);
        }, 0);
    }
}
PepDateComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-date',
                template: "<ng-container [formGroup]=\"form\">\n    <ng-template #pepTemplate let-showIcon=\"showIcon\">\n        <mat-form-field appearance=\"outline\">\n            <input #input [id]=\"key\" title=\"{{ formattedValue }}\" matInput class=\"body-sm\" autocomplete=\"false\"\n                [ngStyle]=\"{ color: textColor, 'text-align': xAlignment == 'center' ? 'center' : xAlignment == 'right' ? 'right' : 'left'}\"\n                [(ngModel)]=\"dateModel\" [ngModelOptions]=\"{standalone: true}\" [matDatetimepicker]=\"datetimePicker\"\n                [min]=\"minDate\" [max]=\"maxDate\" [required]=\"mandatory\" [disabled]=\"disabled\"\n                (dateChange)=\"onDateChange($event)\" (click)=\"openDatetimePicker(datetimePicker)\"\n                (blur)=\"onBlur($event)\" />\n            <mat-error *ngIf=\"renderError\"><span class=\"body-xs\"\n                    [title]=\"mandatory && formattedValue.length == 0 ? ('MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}) : ('MESSAGES.ERROR_IS_NOT_VALID' | translate: {field: label})\"\n                    [innerText]=\"mandatory && formattedValue.length == 0 ? ('MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}) : ('MESSAGES.ERROR_IS_NOT_VALID' | translate: {field: label})\"></span>\n            </mat-error>\n            <pep-textbox-icon *ngIf=\"renderSymbol && showIcon && xAlignment == 'right'\" matPrefix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\" (iconClick)=\"openDatetimePicker(datetimePicker)\">\n            </pep-textbox-icon>\n            <pep-textbox-icon *ngIf=\"renderSymbol && showIcon && xAlignment == 'left'\" matSuffix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\" (iconClick)=\"openDatetimePicker(datetimePicker)\">\n            </pep-textbox-icon>\n            <mat-datetimepicker #datetimePicker [type]=\"showTime ? 'datetime' : 'date'\" [openOnFocus]=\"false\"\n                [touchUi]=\"true\" [timeInterval]=\"1\"></mat-datetimepicker>\n        </mat-form-field>\n    </ng-template>\n\n    <ng-container *ngIf=\"layoutType === 'form'\">\n        <pep-field-title *ngIf=\"renderTitle\" [label]=\"label\" [mandatory]=\"mandatory\" [disabled]=\"disabled\"\n            [xAlignment]=\"xAlignment\" [showTitle]=\"showTitle\">\n        </pep-field-title>\n        <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: true}\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'card'\">\n        <ng-container *ngIf=\"isInEditMode; then editBlock; else readOnlyBlock\"></ng-container>\n        <ng-template #editBlock>\n            <div [ngClass]=\"{'one-row': rowSpan === 1}\">\n                <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: false}\"></ng-container>\n            </div>\n        </ng-template>\n        <ng-template #readOnlyBlock>\n            <div class=\"pep-card-input card-flex-container\"\n                [ngClass]=\"{'one-row': rowSpan === 1, 'pep-button weak': isActive && !disabled }\"\n                [ngStyle]=\"{ color: textColor }\" [class]=\"'text-align-' + xAlignment\"\n                (click)=\"!disabled ? cardTemplateClicked($event) : ''\">\n                <span *ngIf=\"showTitle && label != ''\" class=\"body-xs title\" title=\"{{ label }}\">{{ label\n                    }}&nbsp;</span>\n                <span [id]=\"key\" title=\"{{ formattedValue }}\" class=\"body-sm value\">{{ formattedValue }}</span>\n                <button *ngIf=\"isActive && !disabled\" class=\"pep-button weak card-edit-button\" mat-button>\n                    <mat-icon>\n                        <pep-icon name=\"system_edit\">\n                        </pep-icon>\n                    </mat-icon>\n                </button>\n            </div>\n        </ng-template>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'table'\">\n        <ng-container *ngIf=\"isActive && !disabled; then selectedBlock; else notSelectedBlock\"></ng-container>\n        <ng-template #selectedBlock>\n            <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: true}\"></ng-container>\n        </ng-template>\n        <ng-template #notSelectedBlock>\n            <ng-container *ngIf=\"formattedValue?.length > 0; then notEmptyBlock; else emptyBlock\"></ng-container>\n            <ng-template #notEmptyBlock>\n                <ng-container [ngSwitch]=\"type\">\n                    <ng-container *ngSwitchDefault>\n                        <span [id]=\"key\" class=\"body-sm pep-report-input\" [ngStyle]=\"{ color: textColor }\"\n                            [ngClass]=\"{readonly: disabled}\" title=\"{{ formattedValue }}\">{{ formattedValue }}</span>\n                    </ng-container>\n                </ng-container>\n            </ng-template>\n            <ng-template #emptyBlock>\n                <span [id]=\"key\">&nbsp;</span>\n            </ng-template>\n        </ng-template>\n    </ng-container>\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    // CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR,
                    // The locale would typically be provided on the root module of your application. We do it at
                    // the component level here, due to limitations of our example generation script.
                    //{ provide: MAT_DATE_LOCALE, useValue: 'en-US' },
                    // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing
                    // `MatMomentDateModule` in your applications root module. We provide it at the component level
                    // here, due to limitations of our example generation script.
                    //{ provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    //{ provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },
                    { provide: DateAdapter, useClass: MomentUtcDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                    { provide: DatetimeAdapter, useClass: MomentUtcDateTimeAdapter },
                    //{ provide: MAT_DATETIME_FORMATS, useValue: MAT_NATIVE_DATETIME_FORMATS }
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 },
                ],
                styles: [":host{height:inherit;display:grid}:host>*{align-self:center}"]
            },] }
];
PepDateComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: ElementRef },
    { type: PepLayoutService },
    { type: PepUtilitiesService },
    { type: PepCustomizationService },
    { type: Renderer2 }
];
PepDateComponent.propDecorators = {
    key: [{ type: Input }],
    value: [{ type: Input }],
    formattedValue: [{ type: Input }],
    label: [{ type: Input }],
    type: [{ type: Input }],
    mandatory: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    textColor: [{ type: Input }],
    xAlignment: [{ type: Input }],
    rowSpan: [{ type: Input }],
    visible: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    minDateValue: [{ type: Input }],
    maxDateValue: [{ type: Input }],
    form: [{ type: Input }],
    isActive: [{ type: Input }],
    showTitle: [{ type: Input }],
    renderTitle: [{ type: Input }],
    renderError: [{ type: Input }],
    renderSymbol: [{ type: Input }],
    layoutType: [{ type: Input }],
    valueChange: [{ type: Output }],
    datetimePicker: [{ type: ViewChild, args: ['datetimePicker',] }],
    input: [{ type: ViewChild, args: ['input',] }]
};
export { ɵ0, ɵ1 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbGliL2RhdGUvZGF0ZS5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxVQUFVLEVBRVYsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBQ1osdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxTQUFTLEdBSVosTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3ZFLE9BQU8sRUFDSCxlQUFlLEVBRWYsb0JBQW9CLEdBQ3ZCLE1BQU0sMEJBQTBCLENBQUM7QUFFbEMsT0FBTyxFQUNILGdCQUFnQixFQUNoQixtQkFBbUIsRUFFbkIsdUJBQXVCLEVBRXZCLDRCQUE0QixFQUU1QixZQUFZLEdBQ2YsTUFBTSx5QkFBeUIsQ0FBQztBQUNqQyxPQUFPLEVBQVUsR0FBRyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzVDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSx3QkFBd0IsRUFBRSxlQUFlLEVBQUUsTUFBTSxjQUFjLENBQUM7V0FtQmhELGVBQWUsT0FHWCxlQUFlO0FBR2xFLE1BQU0sT0FBTyxnQkFBZ0I7SUF5R3pCLFlBQ1ksT0FBeUIsRUFDekIsT0FBbUIsRUFDbkIsYUFBK0IsRUFDL0IsZ0JBQXFDLEVBQ3JDLG9CQUE2QyxFQUM3QyxRQUFtQjtRQUxuQixZQUFPLEdBQVAsT0FBTyxDQUFrQjtRQUN6QixZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQXFCO1FBQ3JDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBeUI7UUFDN0MsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQTlHdEIsUUFBRyxHQUFHLEVBQUUsQ0FBQztRQUVWLFdB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QUs7d0JBU0wsS0FBSzt1QkFDTCxLQUFLO3VCQUNMLEtBQUs7d0JBQ0wsS0FBSzt5QkFDTCxLQUFLO3NCQUNMLEtBQUs7c0JBR0wsS0FBSzt1QkFvQkwsS0FBSzt1QkFRTCxLQUFLOzJCQVFMLEtBQUs7MkJBTUwsS0FBSzttQkFPTCxLQUFLO3VCQUNMLEtBQUs7d0JBQ0wsS0FBSzswQkFDTCxLQUFLOzBCQUNMLEtBQUs7MkJBQ0wsS0FBSzt5QkFDTCxLQUFLOzBCQUVMLE1BQU07NkJBRU4sU0FBUyxTQUFDLGdCQUFnQjtvQkFFMUIsU0FBUyxTQUFDLE9BQU8iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBFbGVtZW50UmVmLFxuICAgIE9uSW5pdCxcbiAgICBJbnB1dCxcbiAgICBPdXRwdXQsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIFZpZXdDaGlsZCxcbiAgICBSZW5kZXJlcjIsXG4gICAgT25EZXN0cm95LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPcHRpb25hbCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNb21lbnREYXRlQWRhcHRlciB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsLW1vbWVudC1hZGFwdGVyJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvY29yZSc7XG5pbXBvcnQge1xuICAgIERhdGV0aW1lQWRhcHRlcixcbiAgICBNYXREYXRldGltZXBpY2tlcklucHV0RXZlbnQsXG4gICAgTUFUX0RBVEVUSU1FX0ZPUk1BVFMsXG59IGZyb20gJ0BtYXQtZGF0ZXRpbWVwaWNrZXIvY29yZSc7XG5pbXBvcnQgeyBNb21lbnREYXRldGltZUFkYXB0ZXIgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL21vbWVudCc7XG5pbXBvcnQge1xuICAgIFBlcExheW91dFNlcnZpY2UsXG4gICAgUGVwVXRpbGl0aWVzU2VydmljZSxcbiAgICBQZXBMYXlvdXRUeXBlLFxuICAgIFBlcEN1c3RvbWl6YXRpb25TZXJ2aWNlLFxuICAgIFBlcEhvcml6b250YWxBbGlnbm1lbnQsXG4gICAgREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOTUVOVCxcbiAgICBQZXBEYXRlRmllbGRUeXBlLFxuICAgIFBlcERhdGVGaWVsZCxcbn0gZnJvbSAnQHBlcHBlcmktYWRkb25zL25neC1saWInO1xuaW1wb3J0IHsgTW9tZW50LCB1dGMgfSBmcm9tICdtb21lbnQvbW9tZW50JztcbmltcG9ydCB7IE1vbWVudFV0Y0RhdGVBZGFwdGVyLCBNb21lbnRVdGNEYXRlVGltZUFkYXB0ZXIsIE1ZX0RBVEVfRk9STUFUUyB9IGZyb20gJy4vZGF0ZS5tb2RlbCc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncGVwLWRhdGUnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kYXRlLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9kYXRlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIC8vIENVU1RPTV9JTlBVVF9DT05UUk9MX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAvLyBUaGUgbG9jYWxlIHdvdWxkIHR5cGljYWxseSBiZSBwcm92aWRlZCBvbiB0aGUgcm9vdCBtb2R1bGUgb2YgeW91ciBhcHBsaWNhdGlvbi4gV2UgZG8gaXQgYXRcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCBsZXZlbCBoZXJlLCBkdWUgdG8gbGltaXRhdGlvbnMgb2Ygb3VyIGV4YW1wbGUgZ2VuZXJhdGlvbiBzY3JpcHQuXG4gICAgICAgIC8veyBwcm92aWRlOiBNQVRfREFURV9MT0NBTEUsIHVzZVZhbHVlOiAnZW4tVVMnIH0sXG5cbiAgICAgICAgLy8gYE1vbWVudERhdGVBZGFwdGVyYCBhbmQgYE1BVF9NT01FTlRfREFURV9GT1JNQVRTYCBjYW4gYmUgYXV0b21hdGljYWxseSBwcm92aWRlZCBieSBpbXBvcnRpbmdcbiAgICAgICAgLy8gYE1hdE1vbWVudERhdGVNb2R1bGVgIGluIHlvdXIgYXBwbGljYXRpb25zIHJvb3QgbW9kdWxlLiBXZSBwcm92aWRlIGl0IGF0IHRoZSBjb21wb25lbnQgbGV2ZWxcbiAgICAgICAgLy8gaGVyZSwgZHVlIHRvIGxpbWl0YXRpb25zIG9mIG91ciBleGFtcGxlIGdlbmVyYXRpb24gc2NyaXB0LlxuICAgICAgICAvL3sgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlciwgZGVwczogW01BVF9EQVRFX0xPQ0FMRV0gfSxcbiAgICAgICAgLy97IHByb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNQVRfTU9NRU5UX0RBVEVfRk9STUFUUyB9LFxuICAgICAgICB7IHByb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50VXRjRGF0ZUFkYXB0ZXIgfSxcbiAgICAgICAgeyBwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTVlfREFURV9GT1JNQVRTIH0sXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZXRpbWVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50VXRjRGF0ZVRpbWVBZGFwdGVyIH0sXG4gICAgICAgIC8veyBwcm92aWRlOiBNQVRfREFURVRJTUVfRk9STUFUUywgdXNlVmFsdWU6IE1BVF9OQVRJVkVfREFURVRJTUVfRk9STUFUUyB9XG4gICAgICAgIHsgcHJvdmlkZTogTUFUX0RBVEVUSU1FX0ZPUk1BVFMsIHVzZVZhbHVlOiBNWV9EQVRFX0ZPUk1BVFMgfSxcbiAgICBdLFxufSlcbmV4cG9ydCBjbGFzcyBQZXBEYXRlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkga2V5ID0gJyc7XG5cbiAgICBwcml2YXRlIF92YWx1ZSA9ICcnO1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IHZhbHVlKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXREYXRlTW9kZWwoKTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgZm9ybWF0dGVkVmFsdWUgPSAnJztcbiAgICBASW5wdXQoKSBsYWJlbCA9ICcnO1xuXG4gICAgcHJpdmF0ZSBfdHlwZTogUGVwRGF0ZUZpZWxkVHlwZSA9ICdkYXRlJztcbiAgICBASW5wdXQoKVxuICAgIHNldCB0eXBlKHR5cGU6IFBlcERhdGVGaWVsZFR5cGUpIHtcbiAgICAgICAgdGhpcy5fdHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuc2hvd1RpbWUgPSB0eXBlID09PSAnZGF0ZXRpbWUnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpOiBQZXBEYXRlRmllbGRUeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuXG4gICAgQElucHV0KCkgbWFuZGF0b3J5ID0gZmFsc2U7XG4gICAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHRleHRDb2xvciA9ICcnO1xuICAgIEBJbnB1dCgpIHhBbGlnbm1lbnQ6IFBlcEhvcml6b250YWxBbGlnbm1lbnQgPSBERUZBVUxUX0hPUklaT05UQUxfQUxJR05NRU5UO1xuICAgIEBJbnB1dCgpIHJvd1NwYW4gPSAxO1xuXG4gICAgcHJpdmF0ZSBfdmlzaWJsZSA9IHRydWU7XG4gICAgQElucHV0KClcbiAgICBzZXQgdmlzaWJsZSh2aXNpYmxlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX3Zpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAnaGlkZGVuLWVsZW1lbnQnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICAgICAnaGlkZGVuLWVsZW1lbnQnXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB2aXNpYmxlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmlzaWJsZTtcbiAgICB9XG5cbiAgICAvLyBNaW5pbXVtIGluIHRoaWNrc1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IG1pblZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgICAgICAgdGhpcy5taW5EYXRlID0gbmV3IERhdGUodmFsdWUgKiAxMDAwICogNjAgKiA2MCAqIDI0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1heGltdW0gaW4gdGhpY2tzXG4gICAgQElucHV0KClcbiAgICBzZXQgbWF4VmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLm1heERhdGUgPSBuZXcgRGF0ZSh2YWx1ZSAqIDEwMDAgKiA2MCAqIDYwICogMjQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWluaW11bSBpbiBkYXRlXG4gICAgQElucHV0KClcbiAgICBzZXQgbWluRGF0ZVZhbHVlKGRhdGU6IHN0cmluZykge1xuICAgICAgICB0aGlzLm1pbkRhdGUgPSBkYXRlID8gbmV3IERhdGUoZGF0ZSkgOiBudWxsO1xuICAgIH1cblxuICAgIC8vIE1heGltdW0gaW4gZGF0ZVxuICAgIEBJbnB1dCgpXG4gICAgc2V0IG1heERhdGVWYWx1ZShkYXRlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5tYXhEYXRlID0gZGF0ZSA/IG5ldyBEYXRlKGRhdGUpIDogbnVsbDtcbiAgICB9XG5cbiAgICBjb250cm9sVHlwZSA9ICdkYXRlJztcblxuICAgIEBJbnB1dCgpIGZvcm06IEZvcm1Hcm91cCA9IG51bGw7XG4gICAgQElucHV0KCkgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICBASW5wdXQoKSBzaG93VGl0bGUgPSB0cnVlO1xuICAgIEBJbnB1dCgpIHJlbmRlclRpdGxlID0gdHJ1ZTtcbiAgICBASW5wdXQoKSByZW5kZXJFcnJvciA9IHRydWU7XG4gICAgQElucHV0KCkgcmVuZGVyU3ltYm9sID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBsYXlvdXRUeXBlOiBQZXBMYXlvdXRUeXBlID0gJ2Zvcm0nO1xuXG4gICAgQE91dHB1dCgpXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG4gICAgQFZpZXdDaGlsZCgnZGF0ZXRpbWVQaWNrZXInKSBkYXRldGltZVBpY2tlcjogYW55O1xuXG4gICAgQFZpZXdDaGlsZCgnaW5wdXQnKSBpbnB1dDogRWxlbWVudFJlZjtcblxuICAgIHN0YW5kQWxvbmUgPSBmYWxzZTtcbiAgICBpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgICBkYXRlTW9kZWw6IE1vbWVudDtcbiAgICBtaW5EYXRlOiBEYXRlO1xuICAgIG1heERhdGU6IERhdGU7XG4gICAgc2hvd0RhdGVwaWNrZXIgPSBmYWxzZTtcbiAgICBzaG93VGltZSA9IGZhbHNlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgYWRhcHRlcjogRGF0ZUFkYXB0ZXI8YW55PixcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGxheW91dFNlcnZpY2U6IFBlcExheW91dFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgdXRpbGl0aWVzU2VydmljZTogUGVwVXRpbGl0aWVzU2VydmljZSxcbiAgICAgICAgcHJpdmF0ZSBjdXN0b21pemF0aW9uU2VydmljZTogUGVwQ3VzdG9taXphdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICAgICkgeyB9XG5cbiAgICBwcml2YXRlIHNldERlZmF1bHRGb3JtKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBwZXBGaWVsZCA9IG5ldyBQZXBEYXRlRmllbGQoe1xuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgICAgICAgICAgbWFuZGF0b3J5OiB0aGlzLm1hbmRhdG9yeSxcbiAgICAgICAgICAgIHJlYWRvbmx5OiB0aGlzLnJlYWRvbmx5LFxuICAgICAgICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvcm0gPSB0aGlzLmN1c3RvbWl6YXRpb25TZXJ2aWNlLmdldERlZmF1bHRGcm9tR3JvdXAocGVwRmllbGQpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mb3JtID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YW5kQWxvbmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zZXREZWZhdWx0Rm9ybSgpO1xuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgIFBlcEN1c3RvbWl6YXRpb25TZXJ2aWNlLlNUQU5EX0FMT05FX0ZJRUxEX0NMQVNTX05BTUVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdWx0dXJlID0gdGhpcy5sYXlvdXRTZXJ2aWNlLmdldEN1cnJlbnRMYW5ndWFnZSgpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIuc2V0TG9jYWxlKGN1bHR1cmUpO1xuXG4gICAgICAgIHRoaXMuc2V0RGF0ZU1vZGVsKCk7XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN0YW5kQWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEZvcm0oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvL1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0Rm9ybWF0dGVkVmFsdWVGcm9tTW9kZWwoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRhdGVNb2RlbCA9PT0gbnVsbCB8fCAhdGhpcy5kYXRlTW9kZWwuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZFZhbHVlID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLnNob3dUaW1lXG4gICAgICAgICAgICAgICAgPyBNWV9EQVRFX0ZPUk1BVFMuZGlzcGxheS5kYXRldGltZUlucHV0XG4gICAgICAgICAgICAgICAgOiBNWV9EQVRFX0ZPUk1BVFMuZGlzcGxheS5kYXRlSW5wdXQ7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZFZhbHVlID0gdGhpcy5hZGFwdGVyLmZvcm1hdCh0aGlzLmRhdGVNb2RlbCwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0RGF0ZU1vZGVsKCk6IHZvaWQge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICB0aGlzLnZhbHVlID09PSAnJyB8fFxuICAgICAgICAgICAgdGhpcy52YWx1ZS5pbmRleE9mKCcxOTAwLTEtMScpID49IDAgfHxcbiAgICAgICAgICAgIHRoaXMudmFsdWUuaW5kZXhPZignMTkwMC0wMS0wMScpID49IDAgfHxcbiAgICAgICAgICAgIHRoaXMudmFsdWUuaW5kZXhPZignMTk3MC0xLTEnKSA+PSAwIHx8XG4gICAgICAgICAgICB0aGlzLnZhbHVlLmluZGV4T2YoJzE5NzAtMDEtMDEnKSA+PSAwXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZGF0ZU1vZGVsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0ZU1vZGVsID0gdXRjKHRoaXMudXRpbGl0aWVzU2VydmljZS5wYXJzZURhdGUodGhpcy52YWx1ZSwgdGhpcy5zaG93VGltZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRGb3JtYXR0ZWRWYWx1ZUZyb21Nb2RlbCgpO1xuICAgIH1cblxuICAgIG9wZW5EYXRldGltZVBpY2tlcihkYXRldGltZVBpY2tlcik6IHZvaWQge1xuICAgICAgICBkYXRldGltZVBpY2tlci5vcGVuZWQgPSBmYWxzZTtcbiAgICAgICAgZGF0ZXRpbWVQaWNrZXIub3BlbigpO1xuICAgIH1cblxuICAgIG9uQmx1cihldmVudDogYW55KTogdm9pZCB7XG4gICAgICAgIC8vIERvbid0IHJlbW92ZSB0aGUgdGltZW91dCBjYXVzZSBhIGJ1ZyBESS0xNzgxOS5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUgJiYgIXRoaXMuZGF0ZXRpbWVQaWNrZXIub3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgb25EYXRlQ2hhbmdlKGV2ZW50OiBNYXREYXRldGltZXBpY2tlcklucHV0RXZlbnQ8TW9tZW50Pik6IHZvaWQge1xuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKGV2ZW50LnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSBldmVudC52YWx1ZS50b0RhdGUoKTtcblxuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLnV0aWxpdGllc1NlcnZpY2Uuc3RyaW5naWZ5RGF0ZShkYXRlLCB0aGlzLnNob3dUaW1lKTtcblxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBmb3JtYXR0ZWQgdmFsdWUuXG4gICAgICAgICAgICB0aGlzLnNldEZvcm1hdHRlZFZhbHVlRnJvbU1vZGVsKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmN1c3RvbWl6YXRpb25TZXJ2aWNlLnVwZGF0ZUZvcm1GaWVsZFZhbHVlKFxuICAgICAgICAgICAgdGhpcy5mb3JtLFxuICAgICAgICAgICAgdGhpcy5rZXksXG4gICAgICAgICAgICAvLyB0aGlzLmZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZSk7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICBjYXJkVGVtcGxhdGVDbGlja2VkKGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuaXNJbkVkaXRNb2RlID0gdHJ1ZTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRGF0ZXRpbWVQaWNrZXIodGhpcy5kYXRldGltZVBpY2tlcik7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cbiJdfQ==