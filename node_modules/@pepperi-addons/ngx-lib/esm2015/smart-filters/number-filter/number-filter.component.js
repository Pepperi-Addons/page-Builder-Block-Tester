import { Component } from '@angular/core';
import { BaseFilterComponent } from '../common/model/base-filter-component';
import { PepSmartFilterOperators, } from '../common/model/operator';
import { Validators } from '@angular/forms';
import { distinctUntilChanged } from 'rxjs/operators';
export class PepNumberFilterComponent extends BaseFilterComponent {
    constructor() {
        super(...arguments);
        this.PepSmartFilterOperators = PepSmartFilterOperators;
        this.chooseTypeOptions = [];
    }
    ngOnInit() {
        this.firstControl.valueChanges
            .pipe(this.getDestroyer(), distinctUntilChanged())
            .subscribe(() => {
            this.setFieldsStateAndValidators();
        });
        this.secondControl.valueChanges
            .pipe(this.getDestroyer(), distinctUntilChanged())
            .subscribe(() => {
            this.setFieldsStateAndValidators();
        });
    }
    // Override
    getDefaultOperator() {
        return PepSmartFilterOperators.Equals;
    }
    // Override
    getFilterValue() {
        const filterValue = {
            first: this.firstControl.value,
        };
        if (this.operator === PepSmartFilterOperators.NumberRange) {
            filterValue['second'] = this.secondControl.value;
        }
        return filterValue;
    }
    // Override
    loadOperatorsOptions() {
        this.chooseTypeOptions = this.operators.map((operator) => {
            return {
                key: operator.id,
                value: this.translate.instant(`${this.OPERATORS_TRANSLATION_PREFIX}.${operator.name}`),
            };
        });
    }
    // Override
    setFieldsStateAndValidators() {
        if (this.operator === PepSmartFilterOperators.NumberRange) {
            const firstValidators = [Validators.required];
            if (this.secondControl.value) {
                firstValidators.push(this.validator.isLessThan(this.secondControl));
            }
            this.firstControl.setValidators(firstValidators);
            this.secondControl.enable();
            const secondValidators = [Validators.required];
            if (this.firstControl.value) {
                secondValidators.push(this.validator.isGreaterThan(this.firstControl));
            }
            this.secondControl.setValidators(secondValidators);
        }
        else {
            super.setFieldsStateAndValidators();
        }
    }
    onOperatorChanged(value) {
        const operator = Object.values(PepSmartFilterOperators).find((operator) => operator.id === value);
        this.operator = operator;
    }
}
PepNumberFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-number-filter',
                template: "<div [formGroup]=\"form\">\n    <ng-container>\n        <pep-select [key]=\"'typeOperator'\" [value]=\"operator.id\" [label]=\"'SMART_FILTERS.TYPE' | translate\"\n            [emptyOption]=\"false\" [options]=\"chooseTypeOptions\" (valueChange)=\"onOperatorChanged($event)\">\n        </pep-select>\n    </ng-container>\n    <div *ngIf=\"operator !== PepSmartFilterOperators.NumberRange\">\n        <!-- Amount -->\n        <pep-textbox [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.AMOUNT' | translate\"\n            [renderError]=\"false\" [type]=\"field.type\" [formattedValue]=\"firstControl.value\"\n            [value]=\"firstControl.value\">\n        </pep-textbox>\n    </div>\n    <div *ngIf=\"operator === PepSmartFilterOperators.NumberRange\" fxLayout=\"row\" fxLayout.xs=\"column\"\n        fxLayoutGap=\"1rem\">\n        <!-- Min number -->\n        <pep-textbox [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.MIN' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type\" [formattedValue]=\"firstControl.value\"\n            [value]=\"firstControl.value\" [maxValue]=\"secondControl.value\">\n        </pep-textbox>\n        <!-- Max number -->\n        <pep-textbox [form]=\"form\" [key]=\"secondControlKey\" [label]=\"'SMART_FILTERS.MAX' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type\" [formattedValue]=\"secondControl.value\"\n            [value]=\"secondControl.value\" [minValue]=\"firstControl.value\">\n        </pep-textbox>\n    </div>\n</div>",
                styles: [""]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibnVtYmVyLWZpbHRlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbGliL3NtYXJ0LWZpbHRlcnMvbnVtYmVyLWZpbHRlci9udW1iZXItZmlsdGVyLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUM3RCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUM1RSxPQUFPLEVBRUgsdUJBQXVCLEdBQzFCLE1BQU0sMEJBQTBCLENBQUM7QUFFbEMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTVDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBT3RELE1BQU0sT0FBTyx3QkFBeUIsU0FBUSxtQkFBbUI7SUFMakU7O1FBTUksNEJBQXVCLEdBQUcsdUJBQXVCLENBQUM7UUFDbEQsc0JBQWlCLEdBQXNCLEVBQUUsQ0FBQztJQXlFOUMsQ0FBQztJQXZFRyxRQUFRO1FBQ0osSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZO2FBQ3pCLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQzthQUNqRCxTQUFTLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDLDJCQUEyQixFQUFFLENBQUM7UUFDdkMsQ0FBQyxDQUFDLENBQUM7UUFFUCxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVk7YUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLEVBQUUsRUFBRSxvQkFBb0IsRUFBRSxDQUFDO2FBQ2pELFNBQVMsQ0FBQyxHQUFHLEVBQUU7WUFDWixJQUFJLENBQUMsMkJBQTJCLEVBQUUsQ0FBQztRQUN2QyxDQUFDLENBQUMsQ0FBQztJQUNYLENBQUM7SUFFRCxXQUFXO0lBQ1gsa0JBQWtCO1FBQ2QsT0FBTyx1QkFBdUIsQ0FBQyxNQUFNLENBQUM7SUFDMUMsQ0FBQztJQUVELFdBQVc7SUFDWCxjQUFjO1FBQ1YsTUFBTSxXQUFXLEdBQUc7WUFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSztTQUNqQyxDQUFDO1FBRUYsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLHVCQUF1QixDQUFDLFdBQVcsRUFBRTtZQUN2RCxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUM7U0FDcEQ7UUFFRCxPQUFPLFdBQVcsQ0FBQztJQUN2QixDQUFDO0lBRUQsV0FBVztJQUNYLG9CQUFvQjtRQUNoQixJQUFJLENBQUMsaUJBQWlCLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxRQUFRLEVBQUUsRUFBRTtZQUNyRCxPQUFPO2dCQUNILEdBQUcsRUFBRSxRQUFRLENBQUMsRUFBRTtnQkFDaEIsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUN6QixHQUFHLElBQUksQ0FBQyw0QkFBNEIsSUFBSSxRQUFRLENBQUMsSUFBSSxFQUFFLENBQzFEO2FBQ0osQ0FBQztRQUNOLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVELFdBQVc7SUFDWCwyQkFBMkI7UUFDdkIsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLHVCQUF1QixDQUFDLFdBQVcsRUFBRTtZQUN2RCxNQUFNLGVBQWUsR0FBRyxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUM5QyxJQUFJLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxFQUFFO2dCQUMxQixlQUFlLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO2FBQ3ZFO1lBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUM7WUFHakQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUM1QixNQUFNLGdCQUFnQixHQUFHLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQy9DLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUU7Z0JBQ3pCLGdCQUFnQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQzthQUMxRTtZQUNELElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLGdCQUFnQixDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNILEtBQUssQ0FBQywyQkFBMkIsRUFBRSxDQUFDO1NBQ3ZDO0lBQ0wsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQWE7UUFDM0IsTUFBTSxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLElBQUksQ0FDeEQsQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUN0QyxDQUFDO1FBQ0YsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDN0IsQ0FBQzs7O1lBL0VKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixxakRBQTZDOzthQUVoRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgT25DaGFuZ2VzLCBPbkluaXQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEJhc2VGaWx0ZXJDb21wb25lbnQgfSBmcm9tICcuLi9jb21tb24vbW9kZWwvYmFzZS1maWx0ZXItY29tcG9uZW50JztcbmltcG9ydCB7XG4gICAgSVBlcFNtYXJ0RmlsdGVyT3BlcmF0b3IsXG4gICAgUGVwU21hcnRGaWx0ZXJPcGVyYXRvcnMsXG59IGZyb20gJy4uL2NvbW1vbi9tb2RlbC9vcGVyYXRvcic7XG5pbXBvcnQgeyBJUGVwU21hcnRGaWx0ZXJEYXRhVmFsdWUgfSBmcm9tICcuLi9jb21tb24vbW9kZWwvZmlsdGVyJztcbmltcG9ydCB7IFZhbGlkYXRvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBJUGVwT3B0aW9uIH0gZnJvbSAnQHBlcHBlcmktYWRkb25zL25neC1saWInO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAncGVwLW51bWJlci1maWx0ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9udW1iZXItZmlsdGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9udW1iZXItZmlsdGVyLmNvbXBvbmVudC5zY3NzJ10sXG59KVxuZXhwb3J0IGNsYXNzIFBlcE51bWJlckZpbHRlckNvbXBvbmVudCBleHRlbmRzIEJhc2VGaWx0ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIFBlcFNtYXJ0RmlsdGVyT3BlcmF0b3JzID0gUGVwU21hcnRGaWx0ZXJPcGVyYXRvcnM7XG4gICAgY2hvb3NlVHlwZU9wdGlvbnM6IEFycmF5PElQZXBPcHRpb24+ID0gW107XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5maXJzdENvbnRyb2wudmFsdWVDaGFuZ2VzXG4gICAgICAgICAgICAucGlwZSh0aGlzLmdldERlc3Ryb3llcigpLCBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaWVsZHNTdGF0ZUFuZFZhbGlkYXRvcnMoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2Vjb25kQ29udHJvbC52YWx1ZUNoYW5nZXNcbiAgICAgICAgICAgIC5waXBlKHRoaXMuZ2V0RGVzdHJveWVyKCksIGRpc3RpbmN0VW50aWxDaGFuZ2VkKCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpZWxkc1N0YXRlQW5kVmFsaWRhdG9ycygpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBnZXREZWZhdWx0T3BlcmF0b3IoKTogSVBlcFNtYXJ0RmlsdGVyT3BlcmF0b3Ige1xuICAgICAgICByZXR1cm4gUGVwU21hcnRGaWx0ZXJPcGVyYXRvcnMuRXF1YWxzO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlXG4gICAgZ2V0RmlsdGVyVmFsdWUoKTogSVBlcFNtYXJ0RmlsdGVyRGF0YVZhbHVlIHtcbiAgICAgICAgY29uc3QgZmlsdGVyVmFsdWUgPSB7XG4gICAgICAgICAgICBmaXJzdDogdGhpcy5maXJzdENvbnRyb2wudmFsdWUsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09IFBlcFNtYXJ0RmlsdGVyT3BlcmF0b3JzLk51bWJlclJhbmdlKSB7XG4gICAgICAgICAgICBmaWx0ZXJWYWx1ZVsnc2Vjb25kJ10gPSB0aGlzLnNlY29uZENvbnRyb2wudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmlsdGVyVmFsdWU7XG4gICAgfVxuXG4gICAgLy8gT3ZlcnJpZGVcbiAgICBsb2FkT3BlcmF0b3JzT3B0aW9ucygpIHtcbiAgICAgICAgdGhpcy5jaG9vc2VUeXBlT3B0aW9ucyA9IHRoaXMub3BlcmF0b3JzLm1hcCgob3BlcmF0b3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBvcGVyYXRvci5pZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy50cmFuc2xhdGUuaW5zdGFudChcbiAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5PUEVSQVRPUlNfVFJBTlNMQVRJT05fUFJFRklYfS4ke29wZXJhdG9yLm5hbWV9YFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZVxuICAgIHNldEZpZWxkc1N0YXRlQW5kVmFsaWRhdG9ycygpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMub3BlcmF0b3IgPT09IFBlcFNtYXJ0RmlsdGVyT3BlcmF0b3JzLk51bWJlclJhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFZhbGlkYXRvcnMgPSBbVmFsaWRhdG9ycy5yZXF1aXJlZF07XG4gICAgICAgICAgICBpZiAodGhpcy5zZWNvbmRDb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZmlyc3RWYWxpZGF0b3JzLnB1c2godGhpcy52YWxpZGF0b3IuaXNMZXNzVGhhbih0aGlzLnNlY29uZENvbnRyb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZmlyc3RDb250cm9sLnNldFZhbGlkYXRvcnMoZmlyc3RWYWxpZGF0b3JzKTtcblxuXG4gICAgICAgICAgICB0aGlzLnNlY29uZENvbnRyb2wuZW5hYmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRWYWxpZGF0b3JzID0gW1ZhbGlkYXRvcnMucmVxdWlyZWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDb250cm9sLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgc2Vjb25kVmFsaWRhdG9ycy5wdXNoKHRoaXMudmFsaWRhdG9yLmlzR3JlYXRlclRoYW4odGhpcy5maXJzdENvbnRyb2wpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vjb25kQ29udHJvbC5zZXRWYWxpZGF0b3JzKHNlY29uZFZhbGlkYXRvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuc2V0RmllbGRzU3RhdGVBbmRWYWxpZGF0b3JzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk9wZXJhdG9yQ2hhbmdlZCh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdG9yID0gT2JqZWN0LnZhbHVlcyhQZXBTbWFydEZpbHRlck9wZXJhdG9ycykuZmluZChcbiAgICAgICAgICAgIChvcGVyYXRvcikgPT4gb3BlcmF0b3IuaWQgPT09IHZhbHVlXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB9XG59XG4iXX0=