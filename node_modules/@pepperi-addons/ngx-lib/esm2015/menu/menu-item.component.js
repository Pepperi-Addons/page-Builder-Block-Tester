import { Component, Input, Output, EventEmitter, ViewChild, } from '@angular/core';
import { pepIconArrowRight } from '@pepperi-addons/ngx-lib/icon';
import { PepMenuItem, } from './menu.model';
export class PepInternalMenuItem extends PepMenuItem {
    constructor() {
        super(...arguments);
        this.selected = false;
    }
}
export class PepMenuItemComponent {
    constructor() {
        this.type = 'action';
        this.parent = null;
        this.items = [];
        this._selectedItem = null;
        this.xPosition = 'after';
        this.subMenuIconName = pepIconArrowRight.name;
        this.menuItemClick = new EventEmitter();
    }
    set selectedItem(selectedItem) {
        this.updateSelectedItem(selectedItem);
    }
    get selectedItem() {
        return this._selectedItem;
    }
    ngOnDestroy() {
        // if (this.menuItemClick) {
        //     this.menuItemClick.unsubscribe();
        // }
    }
    clearSelectedItem(selectedItem) {
        if (this.items) {
            this.items.forEach((item) => {
                item.selected = (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.key) === item.key;
                if (item.children) {
                    item.children.forEach((child) => {
                        this.clearSelectedChildren(child, selectedItem);
                    });
                }
            });
        }
    }
    clearSelectedChildren(item, selectedItem) {
        item.selected = (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.key) === item.key;
        if (item.children) {
            item.children.forEach((child) => {
                this.clearSelectedChildren(child, selectedItem);
            });
        }
    }
    selectParentAndChildren(items, parentsKeys) {
        if (parentsKeys.length > 0) {
            const key = parentsKeys.pop();
            const selectedParent = items.find((item) => item.key === key);
            if (selectedParent) {
                selectedParent.selected = true;
                this.selectParentAndChildren(selectedParent.children, parentsKeys);
            }
        }
    }
    updateSelectedParent(parentItem, parentsKeys) {
        parentsKeys.push(parentItem.key);
        if (parentItem.parent) {
            this.updateSelectedParent(parentItem.parent, parentsKeys);
        }
        else {
            this.selectParentAndChildren(this.items, parentsKeys);
        }
    }
    updateSelectedItem(selectedItem) {
        this.clearSelectedItem(selectedItem);
        this._selectedItem = selectedItem;
        if (selectedItem && selectedItem.parent) {
            this.updateSelectedParent(selectedItem.parent, []);
        }
    }
    onChildClicked(click) {
        // click.source.selected = true;
        this.menuItemClick.emit(click);
    }
    onMenuItemClicked(item) {
        // item.selected = true;
        this.menuItemClick.emit({ source: item });
    }
}
PepMenuItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-menu-item',
                template: "<mat-menu #childMenu=\"matMenu\" xPosition=\"{{ xPosition }}\" class=\"pep-{{type}}-menu\">\n    <ng-container *ngFor=\"let menuItem of items\">\n        <ng-container *ngIf=\"!menuItem.hidden\">\n            <ng-container *ngIf=\"menuItem.type === 'splitter'; then splitterBlock; else buttonBlock\"></ng-container>\n            <ng-template #splitterBlock>\n                <div mat-menu-item class=\"splitter\"></div>\n            </ng-template>\n\n            <ng-template #buttonBlock>\n                <ng-container\n                    *ngIf=\"type !== 'select' && menuItem.children?.length > 0; then childrenBlock; else regularBlock\">\n                </ng-container>\n                <ng-template #childrenBlock>\n                    <button mat-menu-item (click)=\"onMenuItemClicked(menuItem)\" [matMenuTriggerFor]=\"menu.childMenu\"\n                        title=\"{{ menuItem.text }}\" pepRtlDirection [disabled]=\"menuItem.disabled\"\n                        [ngClass]=\"{ selected: type === 'action-select' && menuItem.selected, disabled: menuItem.disabled }\">\n                        <ng-container *ngTemplateOutlet=\"itemTemplate; context: {\n                            itemIconName: menuItem.iconName,\n                            itemText: menuItem.text,\n                            itemType: menuItem.type,\n                            hasChildren: true\n                        }\"></ng-container>\n                    </button>\n                    <pep-menu-item #menu [type]=\"type\" [items]=\"menuItem.children\" [parent]=\"menuItem\"\n                        (menuItemClick)=\"onChildClicked($event)\">\n                    </pep-menu-item>\n                </ng-template>\n                <ng-template #regularBlock>\n                    <button mat-menu-item (click)=\"onMenuItemClicked(menuItem)\" title=\"{{ menuItem.text }}\"\n                        pepRtlDirection [disabled]=\"menuItem.disabled\"\n                        [ngClass]=\"{ selected: (type === 'select' || type === 'action-select') && menuItem.selected, disabled: menuItem.disabled }\">\n                        <ng-container *ngTemplateOutlet=\"itemTemplate; context: {\n                            itemIconName: menuItem.iconName,\n                            itemText: menuItem.text,\n                            itemType: menuItem.type,\n                            hasChildren: false\n                        }\"></ng-container>\n                    </button>\n                </ng-template>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n</mat-menu>\n\n<ng-template #itemTemplate let-itemIconName=\"itemIconName\" let-itemText=\"itemText\" let-itemType=\"itemType\"\n    let-hasChildren=\"hasChildren\">\n    <ng-container>\n        <mat-icon *ngIf=\"itemIconName\" class=\"pull-left flip\">\n            <pep-icon name=\"{{itemIconName}}\"></pep-icon>\n        </mat-icon>\n        <span *ngIf=\"itemText\" class=\"pull-left flip title ellipsis\"\n            [ngClass]=\"{ 'spacing-from-icon': itemIconName, 'spacing-from-submenu-trigger': hasChildren }\"\n            [title]=\"itemText\">\n            {{ itemText }}\n        </span>\n        <mat-icon *ngIf=\"hasChildren\" class=\"pull-left flip submenu-trigger\"\n            [ngClass]=\"{ 'rotate': xPosition === 'before' }\">\n            <pep-icon name=\"{{ subMenuIconName }}\"></pep-icon>\n        </mat-icon>\n    </ng-container>\n</ng-template>",
                styles: [".mat-menu-item-submenu-trigger:after{display:none}.mat-menu-item .title{margin:0 .25rem;margin:0 var(--pep-spacing-xs,.25rem)}.mat-menu-item .title.spacing-from-icon{margin:0 .5rem;margin:0 var(--pep-spacing-sm,.5rem)}.mat-menu-item .title.spacing-from-submenu-trigger{-webkit-padding-end:1rem;padding-inline-end:1rem;-webkit-padding-end:var(--pep-spacing-lg,1rem);padding-inline-end:var(--pep-spacing-lg,1rem)}.mat-menu-item .mat-icon{margin:0}.mat-menu-item .submenu-trigger{position:absolute;right:.5rem;right:var(--pep-spacing-sm,.5rem);width:1rem}.mat-menu-item .submenu-trigger.rotate{transform:rotate(180deg)}.mat-menu-item.splitter{height:1px!important;margin:.5rem 0;margin:var(--pep-spacing-sm,.5rem) 0}.mat-menu-item[dir=rtl] .submenu-trigger{right:unset;left:.5rem;left:var(--pep-spacing-sm,.5rem);transform:rotate(180deg)}.mat-menu-item[dir=rtl] .submenu-trigger.rotate{transform:rotate(0deg)}.mat-menu-item-submenu-trigger:after{width:unset;height:unset;transform:unset}"]
            },] }
];
PepMenuItemComponent.propDecorators = {
    type: [{ type: Input }],
    parent: [{ type: Input }],
    items: [{ type: Input }],
    selectedItem: [{ type: Input }],
    xPosition: [{ type: Input }],
    subMenuIconName: [{ type: Input }],
    childMenu: [{ type: ViewChild, args: ['childMenu', { static: true },] }],
    menuItemClick: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVudS1pdGVtLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1saWIvbWVudS9tZW51LWl0ZW0uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsS0FBSyxFQUNMLE1BQU0sRUFDTixZQUFZLEVBRVosU0FBUyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ2pFLE9BQU8sRUFDSCxXQUFXLEdBSWQsTUFBTSxjQUFjLENBQUM7QUFFdEIsTUFBTSxPQUFPLG1CQUFvQixTQUFRLFdBQVc7SUFBcEQ7O1FBQ0ksYUFBUSxHQUFhLEtBQUssQ0FBQztJQUMvQixDQUFDO0NBQUE7QUFPRCxNQUFNLE9BQU8sb0JBQW9CO0lBTGpDO1FBTWEsU0FBSSxHQUFnQixRQUFRLENBQUM7UUFFN0IsV0FBTSxHQUFzQixJQUFJLENBQUM7UUFDakMsVUFBSyxHQUErQixFQUFFLENBQUM7UUFFeEMsa0JBQWEsR0FBd0IsSUFBSSxDQUFDO1FBU3pDLGNBQVMsR0FBdUIsT0FBTyxDQUFDO1FBQ3hDLG9CQUFlLEdBQVcsaUJBQWlCLENBQUMsSUFBSSxDQUFDO1FBSzFELGtCQUFhLEdBQXlDLElBQUksWUFBWSxFQUEwQixDQUFDO0lBb0ZyRyxDQUFDO0lBbEdHLElBQ0ksWUFBWSxDQUFDLFlBQWlDO1FBQzlDLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztJQUMxQyxDQUFDO0lBQ0QsSUFBSSxZQUFZO1FBQ1osT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDO0lBQzlCLENBQUM7SUFVRCxXQUFXO1FBQ1AsNEJBQTRCO1FBQzVCLHdDQUF3QztRQUN4QyxJQUFJO0lBQ1IsQ0FBQztJQUVPLGlCQUFpQixDQUFDLFlBQWlDO1FBQ3ZELElBQUksSUFBSSxDQUFDLEtBQUssRUFB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SSxLQUFLO3FCQUVMLEtBQUs7b0JBQ0wsS0FBSzsyQkFHTCxLQUFLO3dCQVFMLEtBQUs7OEJBQ0wsS0FBSzt3QkFFTCxTQUFTLFNBQUMsV0FBVyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs0QkFFdkMsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25EZXN0cm95LFxuICAgIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBwZXBJY29uQXJyb3dSaWdodCB9IGZyb20gJ0BwZXBwZXJpLWFkZG9ucy9uZ3gtbGliL2ljb24nO1xuaW1wb3J0IHtcbiAgICBQZXBNZW51SXRlbSxcbiAgICBJUGVwTWVudUl0ZW1DbGlja0V2ZW50LFxuICAgIFBlcE1lbnVUeXBlLFxuICAgIFBlcE1lbnVJdGVtUGFyZW50LFxufSBmcm9tICcuL21lbnUubW9kZWwnO1xuXG5leHBvcnQgY2xhc3MgUGVwSW50ZXJuYWxNZW51SXRlbSBleHRlbmRzIFBlcE1lbnVJdGVtIHtcbiAgICBzZWxlY3RlZD86IGJvb2xlYW4gPSBmYWxzZTtcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwZXAtbWVudS1pdGVtJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vbWVudS1pdGVtLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZVVybHM6IFsnLi9tZW51LWl0ZW0uY29tcG9uZW50LnNjc3MnXSxcbn0pXG5leHBvcnQgY2xhc3MgUGVwTWVudUl0ZW1Db21wb25lbnQgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIEBJbnB1dCgpIHR5cGU6IFBlcE1lbnVUeXBlID0gJ2FjdGlvbic7XG5cbiAgICBASW5wdXQoKSBwYXJlbnQ6IFBlcE1lbnVJdGVtUGFyZW50ID0gbnVsbDtcbiAgICBASW5wdXQoKSBpdGVtczogQXJyYXk8UGVwSW50ZXJuYWxNZW51SXRlbT4gPSBbXTtcblxuICAgIHByaXZhdGUgX3NlbGVjdGVkSXRlbTogUGVwSW50ZXJuYWxNZW51SXRlbSA9IG51bGw7XG4gICAgQElucHV0KClcbiAgICBzZXQgc2VsZWN0ZWRJdGVtKHNlbGVjdGVkSXRlbTogUGVwSW50ZXJuYWxNZW51SXRlbSkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkSXRlbShzZWxlY3RlZEl0ZW0pO1xuICAgIH1cbiAgICBnZXQgc2VsZWN0ZWRJdGVtKCk6IFBlcEludGVybmFsTWVudUl0ZW0ge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJdGVtO1xuICAgIH1cblxuICAgIEBJbnB1dCgpIHhQb3NpdGlvbjogJ2JlZm9yZScgfCAnYWZ0ZXInID0gJ2FmdGVyJztcbiAgICBASW5wdXQoKSBzdWJNZW51SWNvbk5hbWU6IHN0cmluZyA9IHBlcEljb25BcnJvd1JpZ2h0Lm5hbWU7XG5cbiAgICBAVmlld0NoaWxkKCdjaGlsZE1lbnUnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwdWJsaWMgY2hpbGRNZW51OiBhbnk7XG5cbiAgICBAT3V0cHV0KClcbiAgICBtZW51SXRlbUNsaWNrOiBFdmVudEVtaXR0ZXI8SVBlcE1lbnVJdGVtQ2xpY2tFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQZXBNZW51SXRlbUNsaWNrRXZlbnQ+KCk7XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy8gaWYgKHRoaXMubWVudUl0ZW1DbGljaykge1xuICAgICAgICAvLyAgICAgdGhpcy5tZW51SXRlbUNsaWNrLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU2VsZWN0ZWRJdGVtKHNlbGVjdGVkSXRlbTogUGVwSW50ZXJuYWxNZW51SXRlbSk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHNlbGVjdGVkSXRlbT8ua2V5ID09PSBpdGVtLmtleTtcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3RlZENoaWxkcmVuKGNoaWxkLCBzZWxlY3RlZEl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJTZWxlY3RlZENoaWxkcmVuKFxuICAgICAgICBpdGVtOiBQZXBJbnRlcm5hbE1lbnVJdGVtLFxuICAgICAgICBzZWxlY3RlZEl0ZW06IFBlcEludGVybmFsTWVudUl0ZW1cbiAgICApOiB2b2lkIHtcbiAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHNlbGVjdGVkSXRlbT8ua2V5ID09PSBpdGVtLmtleTtcblxuICAgICAgICBpZiAoaXRlbS5jaGlsZHJlbikge1xuICAgICAgICAgICAgaXRlbS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTZWxlY3RlZENoaWxkcmVuKGNoaWxkLCBzZWxlY3RlZEl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNlbGVjdFBhcmVudEFuZENoaWxkcmVuKFxuICAgICAgICBpdGVtczogQXJyYXk8UGVwSW50ZXJuYWxNZW51SXRlbT4sXG4gICAgICAgIHBhcmVudHNLZXlzOiBBcnJheTxzdHJpbmc+XG4gICAgKSB7XG4gICAgICAgIGlmIChwYXJlbnRzS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBwYXJlbnRzS2V5cy5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkUGFyZW50ID0gaXRlbXMuZmluZCgoaXRlbSkgPT4gaXRlbS5rZXkgPT09IGtleSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFBhcmVudCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkUGFyZW50LnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFBhcmVudEFuZENoaWxkcmVuKFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZFBhcmVudC5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50c0tleXNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTZWxlY3RlZFBhcmVudChcbiAgICAgICAgcGFyZW50SXRlbTogUGVwTWVudUl0ZW1QYXJlbnQsXG4gICAgICAgIHBhcmVudHNLZXlzOiBBcnJheTxzdHJpbmc+XG4gICAgKSB7XG4gICAgICAgIHBhcmVudHNLZXlzLnB1c2gocGFyZW50SXRlbS5rZXkpO1xuXG4gICAgICAgIGlmIChwYXJlbnRJdGVtLnBhcmVudCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTZWxlY3RlZFBhcmVudChwYXJlbnRJdGVtLnBhcmVudCwgcGFyZW50c0tleXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RQYXJlbnRBbmRDaGlsZHJlbih0aGlzLml0ZW1zLCBwYXJlbnRzS2V5cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNlbGVjdGVkSXRlbShzZWxlY3RlZEl0ZW06IFBlcEludGVybmFsTWVudUl0ZW0pIHtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGVkSXRlbShzZWxlY3RlZEl0ZW0pO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEl0ZW0gPSBzZWxlY3RlZEl0ZW07XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkSXRlbSAmJiBzZWxlY3RlZEl0ZW0ucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGVkUGFyZW50KHNlbGVjdGVkSXRlbS5wYXJlbnQsIFtdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2hpbGRDbGlja2VkKGNsaWNrOiBJUGVwTWVudUl0ZW1DbGlja0V2ZW50KTogdm9pZCB7XG4gICAgICAgIC8vIGNsaWNrLnNvdXJjZS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMubWVudUl0ZW1DbGljay5lbWl0KGNsaWNrKTtcbiAgICB9XG5cbiAgICBvbk1lbnVJdGVtQ2xpY2tlZChpdGVtOiBQZXBNZW51SXRlbSk6IHZvaWQge1xuICAgICAgICAvLyBpdGVtLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tZW51SXRlbUNsaWNrLmVtaXQoeyBzb3VyY2U6IGl0ZW0gfSk7XG4gICAgfVxufVxuIl19