import { Component, Input, Output, EventEmitter, ViewChild, ElementRef, ChangeDetectionStrategy, Renderer2, } from '@angular/core';
import { PepCustomizationService, DEFAULT_HORIZONTAL_ALIGNMENT, PepSelectField, } from '@pepperi-addons/ngx-lib';
export class PepSelectComponent {
    constructor(customizationService, renderer, element) {
        this.customizationService = customizationService;
        this.renderer = renderer;
        this.element = element;
        this.key = '';
        this.value = '';
        this.label = '';
        this.type = 'select';
        this.mandatory = false;
        this.disabled = false;
        this.readonly = false;
        this.xAlignment = DEFAULT_HORIZONTAL_ALIGNMENT;
        this.rowSpan = 1;
        this.options = [];
        this._visible = true;
        this.controlType = 'select';
        // @Input() field: PepFieldBase;
        this.form = null;
        this.layoutType = 'form';
        this.parentFieldKey = null;
        this.isActive = false;
        this.showTitle = true;
        this.emptyOption = true;
        this.valueChange = new EventEmitter();
        this.formValidationChange = new EventEmitter();
        this.standAlone = false;
        this.isInEditMode = false;
        this.isMulti = false;
        this.fieldFormattedValue = '';
    }
    set visible(visible) {
        this._visible = visible;
        if (visible) {
            this.renderer.removeClass(this.element.nativeElement, 'hidden-element');
        }
        else {
            this.renderer.addClass(this.element.nativeElement, 'hidden-element');
        }
    }
    get visible() {
        return this._visible;
    }
    addOptionsIfNeeded() {
        if (this.isMulti) {
            // Go gor all selected and add to options if not exist
            // for (let i = 0; i < this.selectedValuesModel.length; i++) {
            for (const selectedValue of this.selectedValuesModel) {
                let valueNotExist = false;
                if (this.options &&
                    !this.options.find((opt) => opt.key === selectedValue)) {
                    valueNotExist = true;
                }
                // Add it to options.
                if (valueNotExist) {
                    this.options.push({
                        key: selectedValue,
                        value: selectedValue,
                    });
                }
            }
        }
        else {
            if (this.value &&
                this.value !== '' &&
                this.options &&
                !this.options.find((opt) => opt.key === this.value)) {
                this.options.push({ key: this.value, value: this.value });
            }
        }
    }
    setFieldFormattedValue(value) {
        if (this.isMulti) {
            if (this.selectedValuesModel.length > 0) {
                this.fieldFormattedValue = this.selectedValuesModel
                    .map((value) => {
                    var _a;
                    return (_a = this.options.find((opt) => opt.key === value)) === null || _a === void 0 ? void 0 : _a.value;
                })
                    .join(', ');
            }
            else {
                this.fieldFormattedValue = '';
            }
            // this.fieldFormattedValue = typeof value === 'string' ? value.replace(new RegExp(';', 'g'), ', ') : '';
        }
        else {
            const selectedOpt = this.options.find((opt) => opt.key === value);
            if (selectedOpt) {
                this.fieldFormattedValue = selectedOpt.value;
            }
        }
    }
    setDefaultForm() {
        const pepField = new PepSelectField({
            key: this.key,
            value: this.value,
            mandatory: this.mandatory,
            readonly: this.readonly,
            disabled: this.disabled,
        });
        this.form = this.customizationService.getDefaultFromGroup(pepField);
    }
    ngOnInit() {
        if (this.form === null) {
            this.standAlone = true;
            this.setDefaultForm();
            this.renderer.addClass(this.element.nativeElement, PepCustomizationService.STAND_ALONE_FIELD_CLASS_NAME);
        }
    }
    ngOnChanges(changes) {
        if (this.standAlone) {
            this.setDefaultForm();
        }
        this.isMulti = this.type === 'multi';
        if (this.isMulti) {
            this.selectedValuesModel =
                this.value.length > 0 ? this.value.split(';') : [];
        }
        else {
            this.selectedValueModel = this.value;
        }
        this.addOptionsIfNeeded();
        this.setFieldFormattedValue(this.value);
    }
    ngOnDestroy() {
        //
    }
    selectionChange(event) {
        if (!this.isMulti) {
            this.changeValue(this.selectedValueModel);
        }
    }
    openedChange(event) {
        // Only on close.
        if (!event) {
            if (this.isMulti) {
                this.changeValue(this.selectedValuesModel.join(';'));
            }
            if (this.isInEditMode) {
                this.isInEditMode = false;
            }
        }
    }
    changeValue(value) {
        this.setFieldFormattedValue(value);
        this.customizationService.updateFormFieldValue(this.form, this.key, 
        // value,
        this.fieldFormattedValue, this.parentFieldKey);
        if (this.mandatory) {
            const fieldControl = this.form.controls[this.key];
            if (value) {
                fieldControl.setErrors(null);
            }
            else {
                fieldControl.setErrors({
                    serverError: 'Required',
                });
            }
            this.formValidationChange.emit(this.form.valid);
        }
        this.valueChange.emit(value);
    }
    cardTemplateClicked(event) {
        this.isInEditMode = true;
        setTimeout(() => {
            this.select.open();
        }, 0);
    }
}
PepSelectComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-select',
                template: "<ng-container [formGroup]=\"form\">\n    <ng-template #pepTemplate>\n        <ng-container *ngIf=\"type == 'multi'; then multiSelectBlock; else regularSelectBlock\"></ng-container>\n        <ng-template #regularSelectBlock>\n            <mat-form-field appearance=\"outline\" dir=\"{{ xAlignment === 'right' ? 'rtl' : 'ltr' }}\">\n                <mat-select #select [required]=\"mandatory ? mandatory : undefined\" matInput disableOptionCentering\n                    class=\"body-sm text-align-{{ xAlignment }}\" [id]=\"key\"\n                    [ngClass]=\"{'right-alignment': xAlignment === 'right'}\"\n                    [placeholder]=\"disabled || readonly ? '' : ('SELECT.HINT' | translate)\"\n                    [(ngModel)]=\"selectedValueModel\" [ngModelOptions]=\"{standalone: true}\" [disabled]=\"disabled\"\n                    (selectionChange)=\"selectionChange($event)\" (openedChange)=\"openedChange($event)\"\n                    title=\"{{ fieldFormattedValue }}\">\n                    <mat-option *ngIf=\"emptyOption\" value=\"\" [title]=\"'LIST.NONE' | translate\">{{ 'LIST.NONE' |\n                        translate }}</mat-option>\n                    <mat-option *ngFor=\"let option of options\" [value]=\"option.key\" [title]=\"option.value\">{{\n                        option.value }}</mat-option>\n                </mat-select>\n                <mat-error>\n                    <span class=\"body-xs\" [title]=\"'MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}\"\n                        [innerText]=\"'MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}\"></span>\n                </mat-error>\n            </mat-form-field>\n        </ng-template>\n        <ng-template #multiSelectBlock>\n            <mat-form-field appearance=\"outline\" dir=\"{{ xAlignment === 'right' ? 'rtl' : 'ltr' }}\">\n                <mat-select #select multiple [required]=\"mandatory ? mandatory : undefined\" matInput\n                    disableOptionCentering class=\"body-sm text-align-{{ xAlignment }}\" [id]=\"key\"\n                    [ngClass]=\"{'right-alignment': xAlignment === 'right'}\"\n                    [placeholder]=\"disabled || readonly ? '' : ('SELECT.HINT' | translate)\"\n                    [(ngModel)]=\"selectedValuesModel\" [ngModelOptions]=\"{standalone: true}\" [disabled]=\"disabled\"\n                    (openedChange)=\"openedChange($event)\" title=\"{{ fieldFormattedValue }}\">\n                    <mat-option *ngFor=\"let option of options\" [value]=\"option.key\" [title]=\"option.value\">{{\n                        option.value }}</mat-option>\n                </mat-select>\n                <mat-error><span class=\"body-xs\" [title]=\"'MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}\"\n                        [innerText]=\"'MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}\"> </span>\n                </mat-error>\n            </mat-form-field>\n        </ng-template>\n    </ng-template>\n\n    <ng-container *ngIf=\"layoutType === 'form'\">\n        <pep-field-title *ngIf=\"!parentFieldKey\" [label]=\"label\" [mandatory]=\"mandatory\" [disabled]=\"disabled\"\n            [xAlignment]=\"xAlignment\" [showTitle]=\"showTitle\">\n        </pep-field-title>\n        <ng-container *ngTemplateOutlet=\"pepTemplate\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'card'\">\n        <ng-container *ngIf=\"isInEditMode; then editBlock; else readOnlyBlock\"></ng-container>\n        <ng-template #editBlock>\n            <div [ngClass]=\"{'one-row': rowSpan === 1}\">\n                <ng-container *ngTemplateOutlet=\"pepTemplate\"></ng-container>\n            </div>\n        </ng-template>\n        <ng-template #readOnlyBlock>\n            <div class=\"pep-card-input card-flex-container\"\n                [ngClass]=\"{'one-row': rowSpan === 1, 'pep-button weak': isActive && !disabled}\"\n                [class]=\"'text-align-' + xAlignment\" (click)=\"!disabled ? cardTemplateClicked($event) : ''\">\n                <span *ngIf=\"showTitle && label != ''\" class=\"body-xs title\" title=\"{{ label }}\">{{ label\n                    }}&nbsp;</span>\n                <span [id]=\"key\" title=\"{{ fieldFormattedValue }}\" class=\"body-sm value\">{{ fieldFormattedValue\n                    }}</span>\n                <button *ngIf=\"isActive && !disabled\" class=\"pep-button weak card-edit-button\" mat-button>\n                    <mat-icon>\n                        <pep-icon name=\"system_edit\">\n                        </pep-icon>\n                    </mat-icon>\n                </button>\n            </div>\n        </ng-template>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'table'\">\n        <ng-container *ngIf=\"isActive && !disabled; then selectedBlock; else notSelectedBlock\"></ng-container>\n        <ng-template #selectedBlock>\n            <ng-container *ngTemplateOutlet=\"pepTemplate\"></ng-container>\n        </ng-template>\n        <ng-template #notSelectedBlock>\n            <span [id]=\"key\" class=\"body-sm pep-report-input\" [ngClass]=\"{readonly: disabled}\"\n                title=\"{{ fieldFormattedValue }}\">{{ fieldFormattedValue }}</span>\n        </ng-template>\n    </ng-container>\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{height:inherit;display:grid}:host>*{align-self:center}"]
            },] }
];
PepSelectComponent.ctorParameters = () => [
    { type: PepCustomizationService },
    { type: Renderer2 },
    { type: ElementRef }
];
PepSelectComponent.propDecorators = {
    key: [{ type: Input }],
    value: [{ type: Input }],
    label: [{ type: Input }],
    type: [{ type: Input }],
    mandatory: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    xAlignment: [{ type: Input }],
    rowSpan: [{ type: Input }],
    options: [{ type: Input }],
    visible: [{ type: Input }],
    form: [{ type: Input }],
    layoutType: [{ type: Input }],
    parentFieldKey: [{ type: Input }],
    isActive: [{ type: Input }],
    showTitle: [{ type: Input }],
    emptyOption: [{ type: Input }],
    valueChange: [{ type: Output }],
    formValidationChange: [{ type: Output }],
    select: [{ type: ViewChild, args: ['select',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC1saWIvc2VsZWN0L3NlbGVjdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFHVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixTQUFTLEVBQ1QsVUFBVSxFQUNWLHVCQUF1QixFQUV2QixTQUFTLEdBQ1osTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUVILHVCQUF1QixFQUV2Qiw0QkFBNEIsRUFFNUIsY0FBYyxHQUVqQixNQUFNLHlCQUF5QixDQUFDO0FBUWpDLE1BQU0sT0FBTyxrQkFBa0I7SUF3RDNCLFlBQ1ksb0JBQTZDLEVBQzdDLFFBQW1CLEVBQ25CLE9BQW1CO1FBRm5CLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBeUI7UUFDN0MsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUNuQixZQUFPLEdBQVAsT0FBTyxDQUFZO1FBMUR0QixRQUFHLEdBQUcsRUFBRSxDQUFDO1FBQ1QsVUFBSyxHQUFHLEVBQUUsQ0FBQztRQUNYLFVBQUssR0FBRyxFQUFFLENBQUM7UUFDWCxTQUFJLEdBQXVCLFFBQVEsQ0FBQztRQUNwQyxjQUFTLEdBQUcsS0FBSyxDQUFDO1FBQ2xCLGFBQVEsR0FBRyxLQUFLLENBQUM7UUFDakIsYUFBUSxHQUFHLEtBQUssQ0FBQztRQUNqQixlQUFVLEdBQTJCLDRCQUE0QixDQUFDO1FBQ2xFLFlBQU8sR0FBRyxDQUFDLENBQUM7UUFDWixZQUFPLEdBQXNCLEVBQUUsQ0FBQztRQUVqQyxhQUFRLEdBQUcsSUFBSSxDQUFDO1FBb0J4QixnQkFBVyxHQUFHLFFBQVEsQ0FBQztRQUV2QixnQ0FBZ0M7UUFDdkIsU0FBSSxHQUFjLElBQUksQ0FBQztRQUN2QixlQUFVLEdBQWtCLE1BQU0sQ0FBQztRQUNuQyxtQkFBYyxHQUFXLElBQUksQ0FBQztRQUM5Qixh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O3dCQUNMLEtBQUs7MEJBQ0wsS0FBSzswQkFFTCxNQUFNO21DQUVOLE1BQU07cUJBR04sU0FBUyxTQUFDLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBPbkluaXQsXG4gICAgT25DaGFuZ2VzLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgVmlld0NoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgT25EZXN0cm95LFxuICAgIFJlbmRlcmVyMixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtR3JvdXAgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBNYXRTZWxlY3QgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9zZWxlY3QnO1xuaW1wb3J0IHtcbiAgICBQZXBMYXlvdXRUeXBlLFxuICAgIFBlcEN1c3RvbWl6YXRpb25TZXJ2aWNlLFxuICAgIFBlcEhvcml6b250YWxBbGlnbm1lbnQsXG4gICAgREVGQVVMVF9IT1JJWk9OVEFMX0FMSUdOTUVOVCxcbiAgICBQZXBTZWxlY3RGaWVsZFR5cGUsXG4gICAgUGVwU2VsZWN0RmllbGQsXG4gICAgSVBlcE9wdGlvbixcbn0gZnJvbSAnQHBlcHBlcmktYWRkb25zL25neC1saWInO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3BlcC1zZWxlY3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWxlY3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlbGVjdC5jb21wb25lbnQuc2NzcyddLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBQZXBTZWxlY3RDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBASW5wdXQoKSBrZXkgPSAnJztcbiAgICBASW5wdXQoKSB2YWx1ZSA9ICcnO1xuICAgIEBJbnB1dCgpIGxhYmVsID0gJyc7XG4gICAgQElucHV0KCkgdHlwZTogUGVwU2VsZWN0RmllbGRUeXBlID0gJ3NlbGVjdCc7XG4gICAgQElucHV0KCkgbWFuZGF0b3J5ID0gZmFsc2U7XG4gICAgQElucHV0KCkgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICBASW5wdXQoKSByZWFkb25seSA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHhBbGlnbm1lbnQ6IFBlcEhvcml6b250YWxBbGlnbm1lbnQgPSBERUZBVUxUX0hPUklaT05UQUxfQUxJR05NRU5UO1xuICAgIEBJbnB1dCgpIHJvd1NwYW4gPSAxO1xuICAgIEBJbnB1dCgpIG9wdGlvbnM6IEFycmF5PElQZXBPcHRpb24+ID0gW107XG5cbiAgICBwcml2YXRlIF92aXNpYmxlID0gdHJ1ZTtcbiAgICBASW5wdXQoKVxuICAgIHNldCB2aXNpYmxlKHZpc2libGU6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5fdmlzaWJsZSA9IHZpc2libGU7XG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICdoaWRkZW4tZWxlbWVudCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICdoaWRkZW4tZWxlbWVudCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpYmxlO1xuICAgIH1cblxuICAgIGNvbnRyb2xUeXBlID0gJ3NlbGVjdCc7XG5cbiAgICAvLyBASW5wdXQoKSBmaWVsZDogUGVwRmllbGRCYXNlO1xuICAgIEBJbnB1dCgpIGZvcm06IEZvcm1Hcm91cCA9IG51bGw7XG4gICAgQElucHV0KCkgbGF5b3V0VHlwZTogUGVwTGF5b3V0VHlwZSA9ICdmb3JtJztcbiAgICBASW5wdXQoKSBwYXJlbnRGaWVsZEtleTogc3RyaW5nID0gbnVsbDtcbiAgICBASW5wdXQoKSBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHNob3dUaXRsZSA9IHRydWU7XG4gICAgQElucHV0KCkgZW1wdHlPcHRpb24gPSB0cnVlO1xuXG4gICAgQE91dHB1dCgpXG4gICAgdmFsdWVDaGFuZ2U6IEV2ZW50RW1pdHRlcjxzdHJpbmc+ID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XG4gICAgQE91dHB1dCgpXG4gICAgZm9ybVZhbGlkYXRpb25DaGFuZ2U6IEV2ZW50RW1pdHRlcjxib29sZWFuPiA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ3NlbGVjdCcpIHNlbGVjdDogTWF0U2VsZWN0O1xuXG4gICAgc3RhbmRBbG9uZSA9IGZhbHNlO1xuICAgIGlzSW5FZGl0TW9kZSA9IGZhbHNlO1xuICAgIGlzTXVsdGkgPSBmYWxzZTtcbiAgICBzZWxlY3RlZFZhbHVlc01vZGVsOiBzdHJpbmdbXTtcbiAgICBzZWxlY3RlZFZhbHVlTW9kZWw6IHN0cmluZztcbiAgICBmaWVsZEZvcm1hdHRlZFZhbHVlID0gJyc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBjdXN0b21pemF0aW9uU2VydmljZTogUGVwQ3VzdG9taXphdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmXG4gICAgKSB7IH1cblxuICAgIHByaXZhdGUgYWRkT3B0aW9uc0lmTmVlZGVkKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pc011bHRpKSB7XG4gICAgICAgICAgICAvLyBHbyBnb3IgYWxsIHNlbGVjdGVkIGFuZCBhZGQgdG8gb3B0aW9ucyBpZiBub3QgZXhpc3RcbiAgICAgICAgICAgIC8vIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zZWxlY3RlZFZhbHVlc01vZGVsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNlbGVjdGVkVmFsdWUgb2YgdGhpcy5zZWxlY3RlZFZhbHVlc01vZGVsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlTm90RXhpc3QgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuZmluZCgob3B0KSA9PiBvcHQua2V5ID09PSBzZWxlY3RlZFZhbHVlKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZU5vdEV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgdG8gb3B0aW9ucy5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVOb3RFeGlzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHNlbGVjdGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlICE9PSAnJyAmJlxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMuZmluZCgob3B0KSA9PiBvcHQua2V5ID09PSB0aGlzLnZhbHVlKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnB1c2goeyBrZXk6IHRoaXMudmFsdWUsIHZhbHVlOiB0aGlzLnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRGaWVsZEZvcm1hdHRlZFZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRWYWx1ZXNNb2RlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maWVsZEZvcm1hdHRlZFZhbHVlID0gdGhpcy5zZWxlY3RlZFZhbHVlc01vZGVsXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbmQoKG9wdCkgPT4gb3B0LmtleSA9PT0gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZmllbGRGb3JtYXR0ZWRWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzLmZpZWxkRm9ybWF0dGVkVmFsdWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUucmVwbGFjZShuZXcgUmVnRXhwKCc7JywgJ2cnKSwgJywgJykgOiAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkT3B0ID0gdGhpcy5vcHRpb25zLmZpbmQoKG9wdCkgPT4gb3B0LmtleSA9PT0gdmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRPcHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpZWxkRm9ybWF0dGVkVmFsdWUgPSBzZWxlY3RlZE9wdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0RGVmYXVsdEZvcm0oKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHBlcEZpZWxkID0gbmV3IFBlcFNlbGVjdEZpZWxkKHtcbiAgICAgICAgICAgIGtleTogdGhpcy5rZXksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIG1hbmRhdG9yeTogdGhpcy5tYW5kYXRvcnksXG4gICAgICAgICAgICByZWFkb25seTogdGhpcy5yZWFkb25seSxcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLmRpc2FibGVkLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5mb3JtID0gdGhpcy5jdXN0b21pemF0aW9uU2VydmljZS5nZXREZWZhdWx0RnJvbUdyb3VwKHBlcEZpZWxkKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zdGFuZEFsb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEZvcm0oKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyhcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICAgICBQZXBDdXN0b21pemF0aW9uU2VydmljZS5TVEFORF9BTE9ORV9GSUVMRF9DTEFTU19OQU1FXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlczogYW55KTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnN0YW5kQWxvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RGVmYXVsdEZvcm0oKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNNdWx0aSA9IHRoaXMudHlwZSA9PT0gJ211bHRpJztcbiAgICAgICAgaWYgKHRoaXMuaXNNdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFZhbHVlc01vZGVsID1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlLmxlbmd0aCA+IDAgPyB0aGlzLnZhbHVlLnNwbGl0KCc7JykgOiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRWYWx1ZU1vZGVsID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYWRkT3B0aW9uc0lmTmVlZGVkKCk7XG4gICAgICAgIHRoaXMuc2V0RmllbGRGb3JtYXR0ZWRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgLy9cbiAgICB9XG5cbiAgICBzZWxlY3Rpb25DaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdWx0aSkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh0aGlzLnNlbGVjdGVkVmFsdWVNb2RlbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuZWRDaGFuZ2UoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICAvLyBPbmx5IG9uIGNsb3NlLlxuICAgICAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc011bHRpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VWYWx1ZSh0aGlzLnNlbGVjdGVkVmFsdWVzTW9kZWwuam9pbignOycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoYW5nZVZhbHVlKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zZXRGaWVsZEZvcm1hdHRlZFZhbHVlKHZhbHVlKTtcbiAgICAgICAgdGhpcy5jdXN0b21pemF0aW9uU2VydmljZS51cGRhdGVGb3JtRmllbGRWYWx1ZShcbiAgICAgICAgICAgIHRoaXMuZm9ybSxcbiAgICAgICAgICAgIHRoaXMua2V5LFxuICAgICAgICAgICAgLy8gdmFsdWUsXG4gICAgICAgICAgICB0aGlzLmZpZWxkRm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICB0aGlzLnBhcmVudEZpZWxkS2V5XG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMubWFuZGF0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZENvbnRyb2wgPSB0aGlzLmZvcm0uY29udHJvbHNbdGhpcy5rZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZmllbGRDb250cm9sLnNldEVycm9ycyhudWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmllbGRDb250cm9sLnNldEVycm9ycyh7XG4gICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiAnUmVxdWlyZWQnLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3JtVmFsaWRhdGlvbkNoYW5nZS5lbWl0KHRoaXMuZm9ybS52YWxpZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZhbHVlQ2hhbmdlLmVtaXQodmFsdWUpO1xuICAgIH1cblxuICAgIGNhcmRUZW1wbGF0ZUNsaWNrZWQoZXZlbnQ6IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLmlzSW5FZGl0TW9kZSA9IHRydWU7XG5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdC5vcGVuKCk7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbn1cbiJdfQ==