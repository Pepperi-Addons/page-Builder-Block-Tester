import { Component, Input, Output, EventEmitter, Renderer2, ViewChild, ElementRef, ChangeDetectorRef, } from '@angular/core';
import { PepLayoutService, FIELD_TYPE, } from '@pepperi-addons/ngx-lib';
export class PepInternalListComponent {
    constructor(element, layoutService, cd, renderer) {
        this.element = element;
        this.layoutService = layoutService;
        this.cd = cd;
        this.renderer = renderer;
        this.noDataFoundMsg = 'Items not found';
        this.hideAllSelectionInMulti = false;
        this.top = -1;
        this.objectId = '0';
        this.parentId = '0';
        this.searchCode = '0';
        // @Input() showTopBorder = false;
        this.supportResizing = true;
        this.parentScroll = null;
        this.disabled = false;
        this.disableEvents = false;
        this.disableSelectionItems = false;
        this.totalsRow = [];
        // @Output()
        // itemClick: EventEmitter<IPepListItemClickEvent> = new EventEmitter<IPepListItemClickEvent>();
        this.fieldClick = new EventEmitter();
        this.valueChange = new EventEmitter();
        this.uiControl = null;
        this.totalRows = -1;
        this.isTable = false;
        this.hasColumnWidthOfTypePercentage = true;
        this._items = null;
        // isCardView = false;
        this.itemsCounter = 0;
        this.showItems = true;
        this.SEPARATOR = ',';
        this.nativeWindow = null;
        this.selectedItemId = '';
        this.hoveredItemId = '';
        this.lockEvents = false;
        this.containerWidth = 0;
        this.deviceHasMouse = false;
        // headerIsInFocus = false;
        // For resize
        this.pressedColumn = '';
        this.startX = 0;
        this.startWidth = 0;
        this.tableStartWidth = 0;
        this.isUserSelected = false;
        this.checkForChanges = null;
        this.useVirtualScroll = true;
        this.nativeWindow = window;
        this.deviceHasMouse = this.layoutService.getDeviceHasMouse();
        this.layoutService.onMouseOver$.subscribe((deviceHasMouse) => {
            this.deviceHasMouse = deviceHasMouse;
        });
    }
    get items() {
        return this._items;
    }
    ngOnInit() {
        this.containerWidth = 0;
    }
    ngOnChanges(changes) {
        if (this.containerWidth <= 0) {
            this.setContainerWidth();
        }
    }
    ngOnDestroy() {
        // if (this.valueChange) {
        //     this.valueChange.unsubscribe();
        // }
        // if (this.itemClick) {
        //     this.itemClick.unsubscribe();
        // }
        // if (this.fieldClick) {
        //     this.fieldClick.unsubscribe();
        // }
    }
    setContainerWidth() {
        const selectionCheckBoxWidth = 0;
        const rowHeight = 40; // the table row height (2.5rem * 16font-size).
        const style = window.getComputedStyle(this.element.nativeElement.parentElement);
        // The container-fluid class padding left + right + border
        const containerFluidSpacing = parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
        const parentContainer = this.element.nativeElement.parentElement.parentElement > 0
            ? this.element.nativeElement.parentElement.parentElement
            : this.element.nativeElement.parentElement;
        // Calculate if vertical scroll should appear, if so set the scroll width. (this.totalRows + 1) + 1 is for the header row.
        const scrollWidth = parentContainer.clientHeight < rowHeight * (this.totalRows + 1)
            ? 18
            : 0; // 18 is the default scroll width.
        // The selectionCheckBoxWidth width + containerFluidSpacing + scrollWidth.
        const rowHeaderWidthToSub = containerFluidSpacing + selectionCheckBoxWidth + scrollWidth;
        this.containerWidth = parentContainer.offsetWidth - rowHeaderWidthToSub;
    }
    clear() {
        this.cleanItems();
        this.uiControl = null;
    }
    toggleItems(isVisible) {
        this.showItems = isVisible;
        this.lockEvents = !isVisible;
    }
    updateScrollItems(startIndex, endIndex, loadInChunks = true) {
        this.scrollItems = this.items.slice(startIndex, endIndex);
    }
    getUniqItemId(itemId, itemType = '') {
        return itemId + this.SEPARATOR + itemType;
    }
    setLayout() {
        if (this.totalRows === 0 ||
            !this.uiControl ||
            !this.uiControl.ControlFields ||
            this.uiControl.ControlFields.length === 0) {
            return;
        }
        this.uiControl.ControlFields.forEach((cf) => {
            if (cf.ColumnWidth === 0) {
                cf.ColumnWidth = 10;
            }
            if (this.isTable &&
                (cf.FieldType === FIELD_TYPE.Image ||
                    // cf.FieldType === FIELD_TYPE.Indicators || ???
                    cf.FieldType === FIELD_TYPE.Signature ||
                    cf.FieldType === FIELD_TYPE.NumberIntegerQuantitySelector ||
                    cf.FieldType === FIELD_TYPE.NumberRealQuantitySelector ||
                    cf.FieldType === FIELD_TYPE.NumberIntegerForMatrix ||
                    cf.FieldType === FIELD_TYPE.NumberRealForMatrix ||
                    cf.FieldType === FIELD_TYPE.Package ||
                    cf.ApiName === 'UnitsQuantity' ||
                    cf.ApiName === 'QuantitySelector')) {
                cf.Layout.XAlignment = 3;
            }
        });
        if (!this.cd['destroyed']) {
            this.cd.detectChanges();
        }
        // Set the columns width.
        if (this.containerWidth <= 0) {
            this.setContainerWidth();
        }
        this.calcColumnsWidth();
        this.checkForChanges = new Date().getTime();
    }
    calcColumnsWidth() {
        const fixedMultiple = 3.78; // for converting em to pixel.
        const length = this.uiControl.ControlFields.length;
        const selectionCheckBoxWidth = 0;
        // Is table AND there is at least one column of width type of percentage.
        if (this.isTable) {
            if (this.uiControl && this.uiControl.ControlFields) {
                this.hasColumnWidthOfTypePercentage =
                    this.uiControl.ControlFields.filter((cf) => cf.ColumnWidthType === 1).length === 0;
            }
        }
        // If the columns size is fixed and the total is small then the container change it to percentage.
        if (!this.hasColumnWidthOfTypePercentage) {
            const totalFixedColsWidth = this.uiControl.ControlFields.map((cf) => cf.ColumnWidth * fixedMultiple).reduce((sum, current) => sum + current);
            if (window.innerWidth > totalFixedColsWidth) {
                this.hasColumnWidthOfTypePercentage = true;
            }
        }
        let totalCalcColsWidth = 0;
        // Calc by percentage
        if (this.hasColumnWidthOfTypePercentage) {
            const totalColsWidth = this.uiControl.ControlFields.map((cf) => cf.ColumnWidth).reduce((sum, current) => sum + current);
            for (let index = 0; index < length; index++) {
                const uiControlField = this.uiControl
                    .ControlFields[index];
                const calcColumnWidthPercentage = (100 / totalColsWidth) * uiControlField.ColumnWidth;
                uiControlField.calcColumnWidth = Math.floor((this.containerWidth * calcColumnWidthPercentage) / 100);
                if (index === length - 1) {
                    uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString =
                        'calc(100% - ' + totalCalcColsWidth + 'px)'; // For 100%
                }
                else {
                    uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString =
                        uiControlField.calcColumnWidth + 'px';
                    totalCalcColsWidth += uiControlField.calcColumnWidth;
                }
            }
            this.renderer.setStyle(this.element.nativeElement, 'width', 'inherit');
        }
        else {
            for (let index = 0; index < length; index++) {
                const uiControlField = this.uiControl
                    .ControlFields[index];
                const currentFixedWidth = Math.floor(uiControlField.ColumnWidth * fixedMultiple);
                if (index === length - 1) {
                    uiControlField.calcTitleColumnWidthString =
                        currentFixedWidth + 'px';
                    uiControlField.calcColumnWidthString =
                        currentFixedWidth - 4 + 'px'; // -4 for the row padding.
                }
                else {
                    uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString =
                        currentFixedWidth + 'px';
                }
                totalCalcColsWidth += currentFixedWidth;
            }
            this.renderer.setStyle(this.element.nativeElement, 'width', totalCalcColsWidth + selectionCheckBoxWidth + 'px');
        }
    }
    initResizeData() {
        this.startX = 0;
        this.startWidth = 0;
        this.tableStartWidth = 0;
        this.pressedColumn = '';
    }
    onListResizeStart(event, columnKey) {
        this.pressedColumn = columnKey;
        this.startX = event.x;
        this.startWidth = event.target.closest('.header-column').offsetWidth;
        // Set the tableStartWidth to the container offsetWidth
        this.tableStartWidth = this.noVirtualScrollCont.nativeElement.offsetWidth;
    }
    onListResize(event) {
        if (this.pressedColumn.length > 0) {
            const widthToAdd = this.layoutService.isRtl()
                ? this.startX - event.x
                : event.x - this.startX;
            // Set the width of the column and the container of the whole columns.
            if (this.startWidth + widthToAdd >= 48 || widthToAdd > 0) {
                const length = this.uiControl.ControlFields.length;
                let totalCalcColsWidth = 0;
                for (let index = 0; index < length; index++) {
                    const uiControlField = this.uiControl
                        .ControlFields[index];
                    if (index === length - 1) {
                        // Calc the last column only in percentage type.
                        if (this.hasColumnWidthOfTypePercentage) {
                            uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString =
                                'calc(100% - ' + totalCalcColsWidth + 'px)'; // For 100%
                        }
                        else {
                            if (uiControlField.ApiName === this.pressedColumn) {
                                uiControlField.calcColumnWidth =
                                    this.startWidth + widthToAdd;
                                uiControlField.calcTitleColumnWidthString =
                                    uiControlField.calcColumnWidth + 'px';
                                uiControlField.calcColumnWidthString =
                                    uiControlField.calcColumnWidth - 4 + 'px';
                            }
                        }
                    }
                    else if (uiControlField.ApiName === this.pressedColumn) {
                        uiControlField.calcColumnWidth =
                            this.startWidth + widthToAdd;
                        uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString =
                            uiControlField.calcColumnWidth + 'px';
                    }
                    totalCalcColsWidth += uiControlField.calcColumnWidth;
                }
                this.renderer.setStyle(this.element.nativeElement, 'width', this.tableStartWidth + widthToAdd + 'px');
            }
            this.checkForChanges = new Date().getTime();
        }
    }
    getParent(el, parentSelector) {
        // If no parentSelector defined will bubble up all the way to *document*
        if (parentSelector === undefined) {
            parentSelector = document;
        }
        const parent = [];
        let p = el.parentNode;
        while (p &&
            p.className !== '' &&
            p.className.indexOf(parentSelector) === -1 &&
            parentSelector !== document) {
            const o = p;
            p = o.parentNode;
        }
        if (p.className.indexOf(parentSelector) > -1) {
            parent.push(p); // Push that parentSelector you wanted to stop at
        }
        return parent;
    }
    onListResizeEnd(event) {
        if (this.pressedColumn.length > 0) {
            if (event &&
                this.getParent(event.srcElement, 'resize-box').length > 0) {
                this.initResizeData();
            }
            else {
                setTimeout(() => {
                    this.initResizeData();
                }, 0);
            }
        }
    }
    onListHeaderMouseEnter(event) {
        // this.headerIsInFocus = true;
    }
    onListHeaderMouseLeave(event) {
        // this.headerIsInFocus = false;
        this.onListResizeEnd(event);
        this.initResizeData();
    }
    onListChange(event) {
        if (this.disableEvents) {
            return;
        }
        // For other events do nothing.
        if (typeof event.start === 'undefined' ||
            typeof event.end === 'undefined') {
            return;
        }
        this.calculatedObjectHeight = event.calculatedChildHeight + 'px';
        if (!this.lockEvents) {
            this.toggleItems(false);
            this.updateScrollItems(event.start, event.end, false);
            this.toggleItems(true);
        }
    }
    getParentContainer() {
        return this.parentScroll ? this.parentScroll : window;
    }
    onValueChanged(valueChange) {
        if (this.disabled) {
            return;
        }
        this.valueChange.emit(valueChange);
    }
    onCustomizeFieldClick(customizeFieldClickedData) {
        if (this.disabled) {
            return;
        }
        this.fieldClick.emit(customizeFieldClickedData);
    }
    getIsDisabled(item) {
        if (this.disableSelectionItems) {
            return true;
        }
        else {
            const IsNotSelectableForActions = item && !item.IsSelectableForActions;
            return IsNotSelectableForActions;
        }
    }
    getIsItemSelected(itemId, itemType = '') {
        let isSelected = false;
        const uniqItemId = this.getUniqItemId(itemId, itemType);
        isSelected = uniqItemId === this.selectedItemId;
        return isSelected;
    }
    setItemClicked(itemId, isSelectableForActions, itemType, isChecked) {
        const uniqItemId = this.getUniqItemId(itemId, itemType);
        // select the selected item.
        if (isChecked) {
            // Set seleted item
            this.selectedItemId = uniqItemId;
        }
        else {
            if (this.selectedItemId === uniqItemId) {
                this.selectedItemId = '';
            }
        }
    }
    itemClicked(e, item) {
        // Set seleted item
        const itemId = item.UID.toString();
        const itemType = item.Type.toString();
        let isChecked = false;
        if (item && item.IsSelectableForActions) {
            this.selectedItemId = this.getUniqItemId(itemId, itemType);
            isChecked = true;
        }
        if (this.isTable) {
            this.setItemClicked(itemId, item.IsSelectableForActions, itemType, true);
        }
        else {
            if (this.disabled) {
                return;
            }
        }
        // this.itemClick.emit({ source: item, viewType: this.viewType });
    }
    onTableRowMouseEnter(event, itemId, itemType) {
        if (!this.deviceHasMouse) {
            return;
        }
        const uniqItemId = this.getUniqItemId(itemId, itemType);
        this.hoveredItemId = uniqItemId;
    }
    onTableRowMouseLeave(event, itemId, itemType) {
        this.hoveredItemId = '';
    }
    onCardMouseEnter(event, itemId, itemType) {
        if (!this.deviceHasMouse) {
            return;
        }
        const uniqItemId = this.getUniqItemId(itemId, itemType);
        this.hoveredItemId = uniqItemId;
    }
    onCardMouseLeave(event, itemId, itemType) {
        this.hoveredItemId = '';
    }
    // call this function after resize + animation end
    winResize(e) {
        this.containerWidth = 0;
        this.setLayout();
    }
    trackByFunc(index, item) {
        return item && item.UID ? item.UID : index;
    }
    cleanItems() {
        this.itemsCounter = 0;
        this._items =
            this.totalRows > 0 ? Array(this.totalRows) : [];
        this.scrollItems = [];
        this.calculatedObjectHeight = '';
    }
    getUIControl() {
        return this.uiControl;
    }
    initListData(uiControl, totalRows, items, viewType = 'table', itemClass = '') {
        this.viewType = viewType;
        this.isTable = viewType === 'table';
        // this.isCardView = viewType === 'cards';
        this.uiControl = uiControl;
        this.itemClass = itemClass;
        this.selectedItemId = '';
        this.totalRows = totalRows;
        // fix bug for the scrollTo that doesn't work on edge div , not window
        // const scrollingElement = this.getParentContainer();
        // scrollingElement.scrollTo(0, 0);
        this.cleanItems();
        this.updateItems(items);
        this.setLayout();
    }
    updateItems(items) {
        this.scrollItems = this._items = items;
        this.itemsCounter = items.length;
    }
    updateItem(data) {
        let index = 0;
        // Update items list
        index = this.items.findIndex((i) => i && i.UID === data.UID);
        if (index >= 0 && index < this.items.length) {
            this.items[index] = data;
        }
        // Update scrollItems list
        index = this.scrollItems.findIndex((i) => i && i.UID === data.UID);
        if (index >= 0 && index < this.scrollItems.length) {
            this.scrollItems[index] = data;
            this.checkForChanges = new Date().getTime();
        }
    }
    getIsItemEditable(uid) {
        const item = this.items.filter((x) => x.UID.toString() === uid);
        if (item.length > 0) {
            return item[0].IsEditable;
        }
        else {
            return false;
        }
    }
    getItemDataByID(uid) {
        return this.items.find((item) => item.UID.toString() === uid);
    }
}
PepInternalListComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-internal-list',
                template: "<ng-container *ngIf=\"totalRows == 0\">\n    <div class=\"pep-border-bottom\">\n        <p class=\"title-xl no-data\">\n            {{ (noDataFoundMsg ? noDataFoundMsg : 'LIST.NO_DATA_FOUND') | translate}}\n        </p>\n    </div>\n    <div class=\"no-data-suggestions\">\n        <p class=\"suggestions-title title-lg\">\n            {{ 'LIST.NO_DATA_FOUND_SUGGESTIONS_TITLE' | translate}}\n        </p>\n        <ul class=\"suggestions-list body-lg\" [innerHtml]=\"'LIST.NO_DATA_FOUND_SUGGESTIONS_LIST' | translate\"></ul>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"totalRows > 0\">\n    <div *ngIf=\"isTable\" #tableHeader class=\"table-header\" (mouseup)=\"onListResizeEnd($event)\"\n        (mouseenter)=\"onListHeaderMouseEnter($event)\" (mouseleave)=\"onListHeaderMouseLeave($event)\"\n        (mousemove)=\"onListResize($event)\">\n\n        <div class=\"table-header-padding-top\"></div>\n        <fieldset class=\"table-header-fieldset\">\n            <fieldset>\n                <div *ngFor=\"let field of uiControl?.ControlFields; let j = index\" class=\"header-column pull-left flip\"\n                    [ngStyle]=\"{ width: field.calcTitleColumnWidthString }\" [ngClass]=\"{\n                            'is-resizing': field.ApiName === pressedColumn,\n                            'is-first': j === 0,\n                            'is-last': j === uiControl?.ControlFields?.length - 1\n                        }\">\n                    <label *ngIf=\"field.Title != ''\" id=\"{{ field.ApiName }}\"\n                        class=\"header-label body-sm pull-left flip text-align-{{ field.Layout.XAlignment }}\"\n                        title=\"{{ field.Title }}\">\n                        {{ field.Title }}\n                    </label>\n                    <label *ngIf=\"field.Title == ''\" id=\"{{ field.ApiName }}\"\n                        class=\"header-label body-sm pull-left flip\">&nbsp;</label>\n\n                    <div *ngIf=\"supportResizing\" class=\"resize-box pull-right flip\"\n                        (mousedown)=\"onListResizeStart($event, field.ApiName)\">\n                        <div class=\"splitter\"></div>\n                    </div>\n                </div>\n            </fieldset>\n        </fieldset>\n    </div>\n\n    <div #noVirtualScrollCont [ngClass]=\"{ 'table-body': isTable, 'cards-body': !isTable }\">\n        <ng-container *ngTemplateOutlet=\"listData\"></ng-container>\n    </div>\n    <ng-container *ngTemplateOutlet=\"listTotals\"></ng-container>\n</ng-container>\n\n<ng-template #listData>\n    <ng-container *ngFor=\"let item of scrollItems; let i = index; let isFirst = first; trackBy: trackByFunc\">\n        <ng-container *ngIf=\"isTable\">\n            <div class=\"table-row\" (mouseenter)=\"onTableRowMouseEnter($event, item?.UID, item?.Type)\"\n                (mouseleave)=\"onTableRowMouseLeave($event, item?.UID, item?.Type)\" [ngClass]=\"{\n                        selected: getIsItemSelected(item?.UID, item?.Type),\n                        highlighted: item?.UID + SEPARATOR + item?.Type === selectedItemId\n                    }\"\n                [ngStyle]=\"{ height: calculatedObjectHeight, visibility: showItems || item ? 'visible' : 'hidden' }\">\n                <fieldset class=\"table-row-fieldset\" [ngStyle]=\"{ 'background-color': item?.BackgroundColor }\">\n                    <!-- [canEditObject]=\"!disabled && item?.IsEditable\" -->\n                    <pep-form [checkForChanges]=\"checkForChanges\" [layout]=\"uiControl\" [data]=\"item\"\n                        [canEditObject]=\"!disabled\" [objectId]=\"objectId\" [parentId]=\"parentId\"\n                        [searchCode]=\"searchCode\" [lockEvents]=\"disableSelectionItems\" [layoutType]=\"'table'\"\n                        [isActive]=\"\n                                (item?.UID + SEPARATOR + item?.Type === selectedItemId ||\n                                item?.UID + SEPARATOR + item?.Type === hoveredItemId) && deviceHasMouse\n                            \" (valueChange)=\"onValueChanged($event)\" (fieldClick)=\"onCustomizeFieldClick($event)\"\n                        (click)=\"itemClicked($event, item)\">\n                    </pep-form>\n                </fieldset>\n            </div>\n        </ng-container>\n\n        <ng-container *ngIf=\"!isTable\">\n            <div [class]=\"itemClass\" (mouseenter)=\"onCardMouseEnter($event, item?.UID, item?.Type)\"\n                (mouseleave)=\"onCardMouseLeave($event, item?.UID, item?.Type)\" [ngClass]=\"{\n                        selected: getIsItemSelected(item?.UID, item?.Type),\n                        highlighted: item?.UID + SEPARATOR + item?.Type === selectedItemId,\n                        'card-view': viewType === 'cards',\n                        'line-view': viewType === 'lines'\n                    }\" class=\"pull-left flip\"\n                [ngStyle]=\"{ height: calculatedObjectHeight, visibility: showItems || item ? 'visible' : 'hidden' }\">\n                <!-- [canEditObject]=\"!disabled && item?.IsEditable\" -->\n                <pep-form [checkForChanges]=\"checkForChanges\" [layout]=\"uiControl\" [data]=\"item\"\n                    [canEditObject]=\"!disabled\" [objectId]=\" objectId\" [parentId]=\"parentId\" [searchCode]=\"searchCode\"\n                    [lockEvents]=\"disableSelectionItems\" [layoutType]=\"'card'\" [isActive]=\"\n                            (item?.UID + SEPARATOR + item?.Type === selectedItemId ||\n                            item?.UID + SEPARATOR + item?.Type === hoveredItemId) && deviceHasMouse\n                        \" (valueChange)=\"onValueChanged($event)\" (fieldClick)=\"onCustomizeFieldClick($event)\"\n                    (click)=\"itemClicked($event, item)\">\n                </pep-form>\n            </div>\n        </ng-container>\n    </ng-container>\n</ng-template>\n\n<ng-template #listTotals>\n    <div *ngIf=\"totalsRow?.length > 0 && totalsRow.length <= uiControl?.ControlFields.length\" class=\"table-total\">\n        <fieldset class=\"table-header-fieldset\">\n            <div *ngFor=\"let field of uiControl?.ControlFields; let j = index\" class=\"total-column pull-left flip\"\n                [ngStyle]=\"{ width: field.calcTitleColumnWidthString }\">\n                <label class=\"total-label body-sm text-align-{{ field.Layout.XAlignment }}\">\n                    {{ totalsRow[j] }}\n                </label>\n            </div>\n        </fieldset>\n    </div>\n</ng-template>",
                host: {
                    '(window:resize)': 'winResize($event)',
                },
                styles: [":host{height:inherit;display:grid}.no-data{margin:2rem 0;margin:var(--pep-spacing-2xl,2rem) 0}.no-data-suggestions .suggestions-title{margin:1rem 0 .5rem;margin:var(--pep-spacing-lg,1rem) 0 var(--pep-spacing-sm,.5rem)}.no-data-suggestions .suggestions-list{margin:0;padding:0;-webkit-padding-start:2rem;padding-inline-start:2rem;-webkit-padding-start:var(--pep-spacing-2xl,2rem);padding-inline-start:var(--pep-spacing-2xl,2rem)}.table-header{top:0}"]
            },] }
];
PepInternalListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PepLayoutService },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
PepInternalListComponent.propDecorators = {
    noDataFoundMsg: [{ type: Input }],
    hideAllSelectionInMulti: [{ type: Input }],
    top: [{ type: Input }],
    objectId: [{ type: Input }],
    parentId: [{ type: Input }],
    searchCode: [{ type: Input }],
    supportResizing: [{ type: Input }],
    parentScroll: [{ type: Input }],
    disabled: [{ type: Input }],
    disableEvents: [{ type: Input }],
    disableSelectionItems: [{ type: Input }],
    totalsRow: [{ type: Input }],
    fieldClick: [{ type: Output }],
    valueChange: [{ type: Output }],
    noVirtualScrollCont: [{ type: ViewChild, args: ['noVirtualScrollCont',] }],
    tableHeader: [{ type: ViewChild, args: ['tableHeader',] }],
    selectAllCB: [{ type: ViewChild, args: ['selectAllCB',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWwtbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZ3gtbGliL2Zvcm0vaW50ZXJuYWwtbGlzdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNILFNBQVMsRUFDVCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFFWixTQUFTLEVBQ1QsU0FBUyxFQUNULFVBQVUsRUFDVixpQkFBaUIsR0FHcEIsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNILGdCQUFnQixFQUdoQixVQUFVLEdBRWIsTUFBTSx5QkFBeUIsQ0FBQztBQWdCakMsTUFBTSxPQUFPLHdCQUF3QjtJQXFFakMsWUFDWSxPQUFtQixFQUNuQixhQUErQixFQUMvQixFQUFxQixFQUNyQixRQUFtQjtRQUhuQixZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLGtCQUFhLEdBQWIsYUFBYSxDQUFrQjtRQUMvQixPQUFFLEdBQUYsRUFBRSxDQUFtQjtRQUNyQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBeEV0QixtQkFBYyxHQUFHLGlCQUFpQixDQUFDO1FBQ25DLDRCQUF1QixHQUFHLEtBQUssQ0FBQztRQUVoQyxRQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFDVCxhQUFRLEdBQUcsR0FBRyxDQUFDO1FBQ2YsYUFBUSxHQUFHLEdBQUcsQ0FBQztRQUNmLGVBQVUsR0FBRyxHQUFHLENBQUM7UUFDMUIsa0NBQWtDO1FBQ3pCLG9CQUFlLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLGlCQUFZLEdBQXFCLElBQUksQ0FBQztRQUN0QyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ2pCLGtCQUFhLEdBQUcsS0FBSyxDQUFDO1FBQ3RCLDBCQUFxQixHQUFHLEtBQUssQ0FBQztRQUM5QixjQUFTLEdBQUcsRUFBRSxDQUFDO1FBRXhCLFlBQVk7UUFDWixnR0FBZ0c7UUFFaEcsZUFBVSxHQUFzQixJQUFJ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QUFHLENBQUMsQ0FBQztRQUNoRSxJQUFJLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ2pCLE9BQU8sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQztTQUM3QjthQUFNO1lBQ0gsT0FBTyxLQUFLLENBQUM7U0FDaEI7SUFDTCxDQUFDO0lBRUQsZUFBZSxDQUFDLEdBQVc7UUFDdkIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLEVBQUUsS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNsRSxDQUFDOzs7WUE5bUJKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsbUJBQW1CO2dCQUM3QixzM01BQTZDO2dCQUU3QyxJQUFJLEVBQUU7b0JBQ0YsaUJBQWlCLEVBQUUsbUJBQW1CO2lCQUN6Qzs7YUFDSjs7O1lBM0JHLFVBQVU7WUFPVixnQkFBZ0I7WUFOaEIsaUJBQWlCO1lBSGpCLFNBQVM7Ozs2QkErQlIsS0FBSztzQ0FDTCxLQUFLO2tCQUVMLEtBQUs7dUJBQ0wsS0FBSzt1QkFDTCxLQUFLO3lCQUNMLEtBQUs7OEJBRUwsS0FBSzsyQkFDTCxLQUFLO3VCQUNMLEtBQUs7NEJBQ0wsS0FBSztvQ0FDTCxLQUFLO3dCQUNMLEtBQUs7eUJBSUwsTUFBTTswQkFFTixNQUFNO2tDQUdOLFNBQVMsU0FBQyxxQkFBcUI7MEJBQy9CLFNBQVMsU0FBQyxhQUFhOzBCQUN2QixTQUFTLFNBQUMsYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT25Jbml0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25DaGFuZ2VzLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGRlbGF5IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHtcbiAgICBQZXBMYXlvdXRTZXJ2aWNlLFxuICAgIFVJQ29udHJvbCxcbiAgICBVSUNvbnRyb2xGaWVsZCxcbiAgICBGSUVMRF9UWVBFLFxuICAgIE9iamVjdHNEYXRhUm93LFxufSBmcm9tICdAcGVwcGVyaS1hZGRvbnMvbmd4LWxpYic7XG5pbXBvcnQge1xuICAgIElQZXBGb3JtRmllbGRDbGlja0V2ZW50LFxuICAgIElQZXBGb3JtRmllbGRWYWx1ZUNoYW5nZUV2ZW50LFxufSBmcm9tICcuL2Zvcm0uY29tcG9uZW50JztcblxuZXhwb3J0IHR5cGUgUGVwTGlzdFZpZXdUeXBlID0gJ2NhcmRzJyB8ICdsaW5lcycgfCAndGFibGUnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3BlcC1pbnRlcm5hbC1saXN0JyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vaW50ZXJuYWwtbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vaW50ZXJuYWwtbGlzdC5jb21wb25lbnQuc2NzcyddLFxuICAgIGhvc3Q6IHtcbiAgICAgICAgJyh3aW5kb3c6cmVzaXplKSc6ICd3aW5SZXNpemUoJGV2ZW50KScsXG4gICAgfSxcbn0pXG5leHBvcnQgY2xhc3MgUGVwSW50ZXJuYWxMaXN0Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gICAgQElucHV0KCkgbm9EYXRhRm91bmRNc2cgPSAnSXRlbXMgbm90IGZvdW5kJztcbiAgICBASW5wdXQoKSBoaWRlQWxsU2VsZWN0aW9uSW5NdWx0aSA9IGZhbHNlO1xuXG4gICAgQElucHV0KCkgdG9wID0gLTE7XG4gICAgQElucHV0KCkgb2JqZWN0SWQgPSAnMCc7XG4gICAgQElucHV0KCkgcGFyZW50SWQgPSAnMCc7XG4gICAgQElucHV0KCkgc2VhcmNoQ29kZSA9ICcwJztcbiAgICAvLyBASW5wdXQoKSBzaG93VG9wQm9yZGVyID0gZmFsc2U7XG4gICAgQElucHV0KCkgc3VwcG9ydFJlc2l6aW5nID0gdHJ1ZTtcbiAgICBASW5wdXQoKSBwYXJlbnRTY3JvbGw6IEVsZW1lbnQgfCBXaW5kb3cgPSBudWxsO1xuICAgIEBJbnB1dCgpIGRpc2FibGVkID0gZmFsc2U7XG4gICAgQElucHV0KCkgZGlzYWJsZUV2ZW50cyA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIGRpc2FibGVTZWxlY3Rpb25JdGVtcyA9IGZhbHNlO1xuICAgIEBJbnB1dCgpIHRvdGFsc1JvdyA9IFtdO1xuXG4gICAgLy8gQE91dHB1dCgpXG4gICAgLy8gaXRlbUNsaWNrOiBFdmVudEVtaXR0ZXI8SVBlcExpc3RJdGVtQ2xpY2tFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyPElQZXBMaXN0SXRlbUNsaWNrRXZlbnQ+KCk7XG4gICAgQE91dHB1dCgpXG4gICAgZmllbGRDbGljazogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPElQZXBGb3JtRmllbGRDbGlja0V2ZW50PigpO1xuICAgIEBPdXRwdXQoKVxuICAgIHZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8SVBlcEZvcm1GaWVsZFZhbHVlQ2hhbmdlRXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcjxJUGVwRm9ybUZpZWxkVmFsdWVDaGFuZ2VFdmVudD4oKTtcblxuICAgIEBWaWV3Q2hpbGQoJ25vVmlydHVhbFNjcm9sbENvbnQnKSBub1ZpcnR1YWxTY3JvbGxDb250OiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ3RhYmxlSGVhZGVyJykgdGFibGVIZWFkZXI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0QWxsQ0InKSBzZWxlY3RBbGxDQjogYW55O1xuXG4gICAgcHVibGljIHVpQ29udHJvbDogVUlDb250cm9sID0gbnVsbDtcbiAgICBwdWJsaWMgdG90YWxSb3dzID0gLTE7XG4gICAgaXRlbUNsYXNzOiBzdHJpbmc7XG4gICAgaXNUYWJsZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgaGFzQ29sdW1uV2lkdGhPZlR5cGVQZXJjZW50YWdlID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX2l0ZW1zOiBBcnJheTxPYmplY3RzRGF0YVJvdz4gPSBudWxsO1xuICAgIGdldCBpdGVtcygpOiBBcnJheTxPYmplY3RzRGF0YVJvdz4ge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlbXM7XG4gICAgfVxuXG4gICAgLy8gaXNDYXJkVmlldyA9IGZhbHNlO1xuICAgIHByaXZhdGUgaXRlbXNDb3VudGVyID0gMDtcbiAgICBzaG93SXRlbXMgPSB0cnVlO1xuICAgIHZpZXdUeXBlOiBQZXBMaXN0Vmlld1R5cGU7XG4gICAgc2Nyb2xsSXRlbXM6IEFycmF5PE9iamVjdHNEYXRhUm93PjtcblxuICAgIHB1YmxpYyBTRVBBUkFUT1IgPSAnLCc7XG5cbiAgICBuYXRpdmVXaW5kb3c6IGFueSA9IG51bGw7XG5cbiAgICBzZWxlY3RlZEl0ZW1JZCA9ICcnO1xuICAgIGhvdmVyZWRJdGVtSWQgPSAnJztcblxuICAgIHByaXZhdGUgbG9ja0V2ZW50cyA9IGZhbHNlO1xuICAgIHByaXZhdGUgY29udGFpbmVyV2lkdGggPSAwO1xuXG4gICAgZGV2aWNlSGFzTW91c2UgPSBmYWxzZTtcblxuICAgIC8vIGhlYWRlcklzSW5Gb2N1cyA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIHJlc2l6ZVxuICAgIHByZXNzZWRDb2x1bW4gPSAnJztcbiAgICBzdGFydFggPSAwO1xuICAgIHN0YXJ0V2lkdGggPSAwO1xuICAgIHRhYmxlU3RhcnRXaWR0aCA9IDA7XG5cbiAgICBpc1VzZXJTZWxlY3RlZCA9IGZhbHNlO1xuICAgIGNoZWNrRm9yQ2hhbmdlczogYW55ID0gbnVsbDtcbiAgICB1c2VWaXJ0dWFsU2Nyb2xsID0gdHJ1ZTtcbiAgICBjYWxjdWxhdGVkT2JqZWN0SGVpZ2h0OiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGxheW91dFNlcnZpY2U6IFBlcExheW91dFNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgY2Q6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjJcbiAgICApIHtcbiAgICAgICAgdGhpcy5uYXRpdmVXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMuZGV2aWNlSGFzTW91c2UgPSB0aGlzLmxheW91dFNlcnZpY2UuZ2V0RGV2aWNlSGFzTW91c2UoKTtcbiAgICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLm9uTW91c2VPdmVyJC5zdWJzY3JpYmUoKGRldmljZUhhc01vdXNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmRldmljZUhhc01vdXNlID0gZGV2aWNlSGFzTW91c2U7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gMDtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lcldpZHRoIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29udGFpbmVyV2lkdGgoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICAvLyBpZiAodGhpcy52YWx1ZUNoYW5nZSkge1xuICAgICAgICAvLyAgICAgdGhpcy52YWx1ZUNoYW5nZS51bnN1YnNjcmliZSgpO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICh0aGlzLml0ZW1DbGljaykge1xuICAgICAgICAvLyAgICAgdGhpcy5pdGVtQ2xpY2sudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZiAodGhpcy5maWVsZENsaWNrKSB7XG4gICAgICAgIC8vICAgICB0aGlzLmZpZWxkQ2xpY2sudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gfVxuICAgIH1cblxuICAgIHNldENvbnRhaW5lcldpZHRoKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25DaGVja0JveFdpZHRoID0gMDtcblxuICAgICAgICBjb25zdCByb3dIZWlnaHQgPSA0MDsgLy8gdGhlIHRhYmxlIHJvdyBoZWlnaHQgKDIuNXJlbSAqIDE2Zm9udC1zaXplKS5cbiAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICAgICAgKTtcbiAgICAgICAgLy8gVGhlIGNvbnRhaW5lci1mbHVpZCBjbGFzcyBwYWRkaW5nIGxlZnQgKyByaWdodCArIGJvcmRlclxuICAgICAgICBjb25zdCBjb250YWluZXJGbHVpZFNwYWNpbmcgPVxuICAgICAgICAgICAgcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQsIDEwKSArIHBhcnNlSW50KHN0eWxlLnBhZGRpbmdSaWdodCwgMTApO1xuXG4gICAgICAgIGNvbnN0IHBhcmVudENvbnRhaW5lciA9XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQgPiAwXG4gICAgICAgICAgICAgICAgPyB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGlmIHZlcnRpY2FsIHNjcm9sbCBzaG91bGQgYXBwZWFyLCBpZiBzbyBzZXQgdGhlIHNjcm9sbCB3aWR0aC4gKHRoaXMudG90YWxSb3dzICsgMSkgKyAxIGlzIGZvciB0aGUgaGVhZGVyIHJvdy5cbiAgICAgICAgY29uc3Qgc2Nyb2xsV2lkdGggPVxuICAgICAgICAgICAgcGFyZW50Q29udGFpbmVyLmNsaWVudEhlaWdodCA8IHJvd0hlaWdodCAqICh0aGlzLnRvdGFsUm93cyArIDEpXG4gICAgICAgICAgICAgICAgPyAxOFxuICAgICAgICAgICAgICAgIDogMDsgLy8gMTggaXMgdGhlIGRlZmF1bHQgc2Nyb2xsIHdpZHRoLlxuXG4gICAgICAgIC8vIFRoZSBzZWxlY3Rpb25DaGVja0JveFdpZHRoIHdpZHRoICsgY29udGFpbmVyRmx1aWRTcGFjaW5nICsgc2Nyb2xsV2lkdGguXG4gICAgICAgIGNvbnN0IHJvd0hlYWRlcldpZHRoVG9TdWIgPVxuICAgICAgICAgICAgY29udGFpbmVyRmx1aWRTcGFjaW5nICsgc2VsZWN0aW9uQ2hlY2tCb3hXaWR0aCArIHNjcm9sbFdpZHRoO1xuICAgICAgICB0aGlzLmNvbnRhaW5lcldpZHRoID0gcGFyZW50Q29udGFpbmVyLm9mZnNldFdpZHRoIC0gcm93SGVhZGVyV2lkdGhUb1N1YjtcbiAgICB9XG5cbiAgICBjbGVhcigpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jbGVhbkl0ZW1zKCk7XG4gICAgICAgIHRoaXMudWlDb250cm9sID0gbnVsbDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUl0ZW1zKGlzVmlzaWJsZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLnNob3dJdGVtcyA9IGlzVmlzaWJsZTtcbiAgICAgICAgdGhpcy5sb2NrRXZlbnRzID0gIWlzVmlzaWJsZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNjcm9sbEl0ZW1zKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBsb2FkSW5DaHVua3MgPSB0cnVlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSXRlbXMgPSB0aGlzLml0ZW1zLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICB9XG5cbiAgICBnZXRVbmlxSXRlbUlkKGl0ZW1JZDogc3RyaW5nLCBpdGVtVHlwZSA9ICcnKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1JZCArIHRoaXMuU0VQQVJBVE9SICsgaXRlbVR5cGU7XG4gICAgfVxuXG4gICAgc2V0TGF5b3V0KCk6IHZvaWQge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0aGlzLnRvdGFsUm93cyA9PT0gMCB8fFxuICAgICAgICAgICAgIXRoaXMudWlDb250cm9sIHx8XG4gICAgICAgICAgICAhdGhpcy51aUNvbnRyb2wuQ29udHJvbEZpZWxkcyB8fFxuICAgICAgICAgICAgdGhpcy51aUNvbnRyb2wuQ29udHJvbEZpZWxkcy5sZW5ndGggPT09IDBcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVpQ29udHJvbC5Db250cm9sRmllbGRzLmZvckVhY2goKGNmKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2YuQ29sdW1uV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjZi5Db2x1bW5XaWR0aCA9IDEwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgdGhpcy5pc1RhYmxlICYmXG4gICAgICAgICAgICAgICAgKGNmLkZpZWxkVHlwZSA9PT0gRklFTERfVFlQRS5JbWFnZSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBjZi5GaWVsZFR5cGUgPT09IEZJRUxEX1RZUEUuSW5kaWNhdG9ycyB8fCA/Pz9cbiAgICAgICAgICAgICAgICAgICAgY2YuRmllbGRUeXBlID09PSBGSUVMRF9UWVBFLlNpZ25hdHVyZSB8fFxuICAgICAgICAgICAgICAgICAgICBjZi5GaWVsZFR5cGUgPT09IEZJRUxEX1RZUEUuTnVtYmVySW50ZWdlclF1YW50aXR5U2VsZWN0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgY2YuRmllbGRUeXBlID09PSBGSUVMRF9UWVBFLk51bWJlclJlYWxRdWFudGl0eVNlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIGNmLkZpZWxkVHlwZSA9PT0gRklFTERfVFlQRS5OdW1iZXJJbnRlZ2VyRm9yTWF0cml4IHx8XG4gICAgICAgICAgICAgICAgICAgIGNmLkZpZWxkVHlwZSA9PT0gRklFTERfVFlQRS5OdW1iZXJSZWFsRm9yTWF0cml4IHx8XG4gICAgICAgICAgICAgICAgICAgIGNmLkZpZWxkVHlwZSA9PT0gRklFTERfVFlQRS5QYWNrYWdlIHx8XG4gICAgICAgICAgICAgICAgICAgIGNmLkFwaU5hbWUgPT09ICdVbml0c1F1YW50aXR5JyB8fFxuICAgICAgICAgICAgICAgICAgICBjZi5BcGlOYW1lID09PSAnUXVhbnRpdHlTZWxlY3RvcicpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjZi5MYXlvdXQuWEFsaWdubWVudCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghdGhpcy5jZFsnZGVzdHJveWVkJ10pIHtcbiAgICAgICAgICAgIHRoaXMuY2QuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHRoZSBjb2x1bW5zIHdpZHRoLlxuICAgICAgICBpZiAodGhpcy5jb250YWluZXJXaWR0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldENvbnRhaW5lcldpZHRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGNDb2x1bW5zV2lkdGgoKTtcbiAgICAgICAgdGhpcy5jaGVja0ZvckNoYW5nZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNhbGNDb2x1bW5zV2lkdGgoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZpeGVkTXVsdGlwbGUgPSAzLjc4OyAvLyBmb3IgY29udmVydGluZyBlbSB0byBwaXhlbC5cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy51aUNvbnRyb2wuQ29udHJvbEZpZWxkcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbkNoZWNrQm94V2lkdGggPSAwO1xuXG4gICAgICAgIC8vIElzIHRhYmxlIEFORCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgY29sdW1uIG9mIHdpZHRoIHR5cGUgb2YgcGVyY2VudGFnZS5cbiAgICAgICAgaWYgKHRoaXMuaXNUYWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudWlDb250cm9sICYmIHRoaXMudWlDb250cm9sLkNvbnRyb2xGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0NvbHVtbldpZHRoT2ZUeXBlUGVyY2VudGFnZSA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudWlDb250cm9sLkNvbnRyb2xGaWVsZHMuZmlsdGVyKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNmKSA9PiBjZi5Db2x1bW5XaWR0aFR5cGUgPT09IDFcbiAgICAgICAgICAgICAgICAgICAgKS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgY29sdW1ucyBzaXplIGlzIGZpeGVkIGFuZCB0aGUgdG90YWwgaXMgc21hbGwgdGhlbiB0aGUgY29udGFpbmVyIGNoYW5nZSBpdCB0byBwZXJjZW50YWdlLlxuICAgICAgICBpZiAoIXRoaXMuaGFzQ29sdW1uV2lkdGhPZlR5cGVQZXJjZW50YWdlKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbEZpeGVkQ29sc1dpZHRoID0gdGhpcy51aUNvbnRyb2wuQ29udHJvbEZpZWxkcy5tYXAoXG4gICAgICAgICAgICAgICAgKGNmKSA9PiBjZi5Db2x1bW5XaWR0aCAqIGZpeGVkTXVsdGlwbGVcbiAgICAgICAgICAgICkucmVkdWNlKChzdW0sIGN1cnJlbnQpID0+IHN1bSArIGN1cnJlbnQpO1xuXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPiB0b3RhbEZpeGVkQ29sc1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNDb2x1bW5XaWR0aE9mVHlwZVBlcmNlbnRhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHRvdGFsQ2FsY0NvbHNXaWR0aCA9IDA7XG5cbiAgICAgICAgLy8gQ2FsYyBieSBwZXJjZW50YWdlXG4gICAgICAgIGlmICh0aGlzLmhhc0NvbHVtbldpZHRoT2ZUeXBlUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgY29uc3QgdG90YWxDb2xzV2lkdGg6IG51bWJlciA9IHRoaXMudWlDb250cm9sLkNvbnRyb2xGaWVsZHMubWFwKFxuICAgICAgICAgICAgICAgIChjZikgPT4gY2YuQ29sdW1uV2lkdGhcbiAgICAgICAgICAgICkucmVkdWNlKChzdW0sIGN1cnJlbnQpID0+IHN1bSArIGN1cnJlbnQpO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdWlDb250cm9sRmllbGQ6IFVJQ29udHJvbEZpZWxkID0gdGhpcy51aUNvbnRyb2xcbiAgICAgICAgICAgICAgICAgICAgLkNvbnRyb2xGaWVsZHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGNDb2x1bW5XaWR0aFBlcmNlbnRhZ2UgPVxuICAgICAgICAgICAgICAgICAgICAoMTAwIC8gdG90YWxDb2xzV2lkdGgpICogdWlDb250cm9sRmllbGQuQ29sdW1uV2lkdGg7XG5cbiAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGggPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5jb250YWluZXJXaWR0aCAqIGNhbGNDb2x1bW5XaWR0aFBlcmNlbnRhZ2UpIC8gMTAwXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjVGl0bGVDb2x1bW5XaWR0aFN0cmluZyA9IHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aFN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnY2FsYygxMDAlIC0gJyArIHRvdGFsQ2FsY0NvbHNXaWR0aCArICdweCknOyAvLyBGb3IgMTAwJVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLmNhbGNUaXRsZUNvbHVtbldpZHRoU3RyaW5nID0gdWlDb250cm9sRmllbGQuY2FsY0NvbHVtbldpZHRoU3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ2FsY0NvbHNXaWR0aCArPSB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgJ2luaGVyaXQnXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVpQ29udHJvbEZpZWxkOiBVSUNvbnRyb2xGaWVsZCA9IHRoaXMudWlDb250cm9sXG4gICAgICAgICAgICAgICAgICAgIC5Db250cm9sRmllbGRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Rml4ZWRXaWR0aCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLkNvbHVtbldpZHRoICogZml4ZWRNdWx0aXBsZVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sRmllbGQuY2FsY1RpdGxlQ29sdW1uV2lkdGhTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpeGVkV2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGhTdHJpbmcgPVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpeGVkV2lkdGggLSA0ICsgJ3B4JzsgLy8gLTQgZm9yIHRoZSByb3cgcGFkZGluZy5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjVGl0bGVDb2x1bW5XaWR0aFN0cmluZyA9IHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aFN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Rml4ZWRXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdG90YWxDYWxjQ29sc1dpZHRoICs9IGN1cnJlbnRGaXhlZFdpZHRoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgdG90YWxDYWxjQ29sc1dpZHRoICsgc2VsZWN0aW9uQ2hlY2tCb3hXaWR0aCArICdweCdcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGluaXRSZXNpemVEYXRhKCk6IHZvaWQge1xuICAgICAgICB0aGlzLnN0YXJ0WCA9IDA7XG4gICAgICAgIHRoaXMuc3RhcnRXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMudGFibGVTdGFydFdpZHRoID0gMDtcbiAgICAgICAgdGhpcy5wcmVzc2VkQ29sdW1uID0gJyc7XG4gICAgfVxuXG4gICAgb25MaXN0UmVzaXplU3RhcnQoZXZlbnQsIGNvbHVtbktleSk6IHZvaWQge1xuICAgICAgICB0aGlzLnByZXNzZWRDb2x1bW4gPSBjb2x1bW5LZXk7XG4gICAgICAgIHRoaXMuc3RhcnRYID0gZXZlbnQueDtcbiAgICAgICAgdGhpcy5zdGFydFdpZHRoID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5oZWFkZXItY29sdW1uJykub2Zmc2V0V2lkdGg7XG4gICAgICAgIC8vIFNldCB0aGUgdGFibGVTdGFydFdpZHRoIHRvIHRoZSBjb250YWluZXIgb2Zmc2V0V2lkdGhcbiAgICAgICAgdGhpcy50YWJsZVN0YXJ0V2lkdGggPSB0aGlzLm5vVmlydHVhbFNjcm9sbENvbnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBvbkxpc3RSZXNpemUoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucHJlc3NlZENvbHVtbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aFRvQWRkID0gdGhpcy5sYXlvdXRTZXJ2aWNlLmlzUnRsKClcbiAgICAgICAgICAgICAgICA/IHRoaXMuc3RhcnRYIC0gZXZlbnQueFxuICAgICAgICAgICAgICAgIDogZXZlbnQueCAtIHRoaXMuc3RhcnRYO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIHdpZHRoIG9mIHRoZSBjb2x1bW4gYW5kIHRoZSBjb250YWluZXIgb2YgdGhlIHdob2xlIGNvbHVtbnMuXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydFdpZHRoICsgd2lkdGhUb0FkZCA+PSA0OCB8fCB3aWR0aFRvQWRkID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMudWlDb250cm9sLkNvbnRyb2xGaWVsZHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxldCB0b3RhbENhbGNDb2xzV2lkdGggPSAwO1xuXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB1aUNvbnRyb2xGaWVsZDogVUlDb250cm9sRmllbGQgPSB0aGlzLnVpQ29udHJvbFxuICAgICAgICAgICAgICAgICAgICAgICAgLkNvbnRyb2xGaWVsZHNbaW5kZXhdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsYyB0aGUgbGFzdCBjb2x1bW4gb25seSBpbiBwZXJjZW50YWdlIHR5cGUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNDb2x1bW5XaWR0aE9mVHlwZVBlcmNlbnRhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjVGl0bGVDb2x1bW5XaWR0aFN0cmluZyA9IHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aFN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdjYWxjKDEwMCUgLSAnICsgdG90YWxDYWxjQ29sc1dpZHRoICsgJ3B4KSc7IC8vIEZvciAxMDAlXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1aUNvbnRyb2xGaWVsZC5BcGlOYW1lID09PSB0aGlzLnByZXNzZWRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sRmllbGQuY2FsY0NvbHVtbldpZHRoID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRXaWR0aCArIHdpZHRoVG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLmNhbGNUaXRsZUNvbHVtbldpZHRoU3RyaW5nID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aFN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGggLSA0ICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodWlDb250cm9sRmllbGQuQXBpTmFtZSA9PT0gdGhpcy5wcmVzc2VkQ29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGggPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRXaWR0aCArIHdpZHRoVG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aUNvbnRyb2xGaWVsZC5jYWxjVGl0bGVDb2x1bW5XaWR0aFN0cmluZyA9IHVpQ29udHJvbEZpZWxkLmNhbGNDb2x1bW5XaWR0aFN0cmluZyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlDb250cm9sRmllbGQuY2FsY0NvbHVtbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsQ2FsY0NvbHNXaWR0aCArPSB1aUNvbnRyb2xGaWVsZC5jYWxjQ29sdW1uV2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICd3aWR0aCcsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGFibGVTdGFydFdpZHRoICsgd2lkdGhUb0FkZCArICdweCdcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRm9yQ2hhbmdlcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50KGVsLCBwYXJlbnRTZWxlY3Rvcik6IGFueSB7XG4gICAgICAgIC8vIElmIG5vIHBhcmVudFNlbGVjdG9yIGRlZmluZWQgd2lsbCBidWJibGUgdXAgYWxsIHRoZSB3YXkgdG8gKmRvY3VtZW50KlxuICAgICAgICBpZiAocGFyZW50U2VsZWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyZW50U2VsZWN0b3IgPSBkb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBbXTtcbiAgICAgICAgbGV0IHAgPSBlbC5wYXJlbnROb2RlO1xuXG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgIHAgJiZcbiAgICAgICAgICAgIHAuY2xhc3NOYW1lICE9PSAnJyAmJlxuICAgICAgICAgICAgcC5jbGFzc05hbWUuaW5kZXhPZihwYXJlbnRTZWxlY3RvcikgPT09IC0xICYmXG4gICAgICAgICAgICBwYXJlbnRTZWxlY3RvciAhPT0gZG9jdW1lbnRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCBvID0gcDtcbiAgICAgICAgICAgIHAgPSBvLnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHAuY2xhc3NOYW1lLmluZGV4T2YocGFyZW50U2VsZWN0b3IpID4gLTEpIHtcbiAgICAgICAgICAgIHBhcmVudC5wdXNoKHApOyAvLyBQdXNoIHRoYXQgcGFyZW50U2VsZWN0b3IgeW91IHdhbnRlZCB0byBzdG9wIGF0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBvbkxpc3RSZXNpemVFbmQoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMucHJlc3NlZENvbHVtbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgZXZlbnQgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmdldFBhcmVudChldmVudC5zcmNFbGVtZW50LCAncmVzaXplLWJveCcpLmxlbmd0aCA+IDBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFJlc2l6ZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFJlc2l6ZURhdGEoKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uTGlzdEhlYWRlck1vdXNlRW50ZXIoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5oZWFkZXJJc0luRm9jdXMgPSB0cnVlO1xuICAgIH1cblxuICAgIG9uTGlzdEhlYWRlck1vdXNlTGVhdmUoZXZlbnQpOiB2b2lkIHtcbiAgICAgICAgLy8gdGhpcy5oZWFkZXJJc0luRm9jdXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkxpc3RSZXNpemVFbmQoZXZlbnQpO1xuICAgICAgICB0aGlzLmluaXRSZXNpemVEYXRhKCk7XG4gICAgfVxuXG4gICAgb25MaXN0Q2hhbmdlKGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZUV2ZW50cykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIG90aGVyIGV2ZW50cyBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZXZlbnQuc3RhcnQgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgICAgICAgICB0eXBlb2YgZXZlbnQuZW5kID09PSAndW5kZWZpbmVkJ1xuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2FsY3VsYXRlZE9iamVjdEhlaWdodCA9IGV2ZW50LmNhbGN1bGF0ZWRDaGlsZEhlaWdodCArICdweCc7XG5cbiAgICAgICAgaWYgKCF0aGlzLmxvY2tFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSXRlbXMoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxJdGVtcyhldmVudC5zdGFydCwgZXZlbnQuZW5kLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUl0ZW1zKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0UGFyZW50Q29udGFpbmVyKCk6IEVsZW1lbnQgfCBXaW5kb3cge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY3JvbGwgPyB0aGlzLnBhcmVudFNjcm9sbCA6IHdpbmRvdztcbiAgICB9XG5cbiAgICBvblZhbHVlQ2hhbmdlZCh2YWx1ZUNoYW5nZTogSVBlcEZvcm1GaWVsZFZhbHVlQ2hhbmdlRXZlbnQpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudmFsdWVDaGFuZ2UuZW1pdCh2YWx1ZUNoYW5nZSk7XG4gICAgfVxuXG4gICAgb25DdXN0b21pemVGaWVsZENsaWNrKFxuICAgICAgICBjdXN0b21pemVGaWVsZENsaWNrZWREYXRhOiBJUGVwRm9ybUZpZWxkQ2xpY2tFdmVudFxuICAgICk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWVsZENsaWNrLmVtaXQoY3VzdG9taXplRmllbGRDbGlja2VkRGF0YSk7XG4gICAgfVxuXG4gICAgZ2V0SXNEaXNhYmxlZChpdGVtOiBPYmplY3RzRGF0YVJvdyk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlU2VsZWN0aW9uSXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgSXNOb3RTZWxlY3RhYmxlRm9yQWN0aW9ucyA9XG4gICAgICAgICAgICAgICAgaXRlbSAmJiAhaXRlbS5Jc1NlbGVjdGFibGVGb3JBY3Rpb25zO1xuICAgICAgICAgICAgcmV0dXJuIElzTm90U2VsZWN0YWJsZUZvckFjdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJc0l0ZW1TZWxlY3RlZChpdGVtSWQ6IHN0cmluZywgaXRlbVR5cGUgPSAnJyk6IGJvb2xlYW4ge1xuICAgICAgICBsZXQgaXNTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGNvbnN0IHVuaXFJdGVtSWQgPSB0aGlzLmdldFVuaXFJdGVtSWQoaXRlbUlkLCBpdGVtVHlwZSk7XG4gICAgICAgIGlzU2VsZWN0ZWQgPSB1bmlxSXRlbUlkID09PSB0aGlzLnNlbGVjdGVkSXRlbUlkO1xuXG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH1cblxuICAgIHByaXZhdGUgc2V0SXRlbUNsaWNrZWQoXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgaXNTZWxlY3RhYmxlRm9yQWN0aW9uczogYm9vbGVhbixcbiAgICAgICAgaXRlbVR5cGU6IHN0cmluZyxcbiAgICAgICAgaXNDaGVja2VkOiBib29sZWFuXG4gICAgKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHVuaXFJdGVtSWQgPSB0aGlzLmdldFVuaXFJdGVtSWQoaXRlbUlkLCBpdGVtVHlwZSk7XG5cbiAgICAgICAgLy8gc2VsZWN0IHRoZSBzZWxlY3RlZCBpdGVtLlxuICAgICAgICBpZiAoaXNDaGVja2VkKSB7XG4gICAgICAgICAgICAvLyBTZXQgc2VsZXRlZCBpdGVtXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbUlkID0gdW5pcUl0ZW1JZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSXRlbUlkID09PSB1bmlxSXRlbUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEl0ZW1JZCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXRlbUNsaWNrZWQoZTogYW55LCBpdGVtOiBPYmplY3RzRGF0YVJvdyk6IHZvaWQge1xuICAgICAgICAvLyBTZXQgc2VsZXRlZCBpdGVtXG4gICAgICAgIGNvbnN0IGl0ZW1JZCA9IGl0ZW0uVUlELnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gaXRlbS5UeXBlLnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBpc0NoZWNrZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLklzU2VsZWN0YWJsZUZvckFjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJdGVtSWQgPSB0aGlzLmdldFVuaXFJdGVtSWQoaXRlbUlkLCBpdGVtVHlwZSk7XG4gICAgICAgICAgICBpc0NoZWNrZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNUYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRJdGVtQ2xpY2tlZChcbiAgICAgICAgICAgICAgICBpdGVtSWQsXG4gICAgICAgICAgICAgICAgaXRlbS5Jc1NlbGVjdGFibGVGb3JBY3Rpb25zLFxuICAgICAgICAgICAgICAgIGl0ZW1UeXBlLFxuICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoaXMuaXRlbUNsaWNrLmVtaXQoeyBzb3VyY2U6IGl0ZW0sIHZpZXdUeXBlOiB0aGlzLnZpZXdUeXBlIH0pO1xuICAgIH1cblxuICAgIG9uVGFibGVSb3dNb3VzZUVudGVyKGV2ZW50OiBhbnksIGl0ZW1JZDogc3RyaW5nLCBpdGVtVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kZXZpY2VIYXNNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pcUl0ZW1JZCA9IHRoaXMuZ2V0VW5pcUl0ZW1JZChpdGVtSWQsIGl0ZW1UeXBlKTtcbiAgICAgICAgdGhpcy5ob3ZlcmVkSXRlbUlkID0gdW5pcUl0ZW1JZDtcbiAgICB9XG5cbiAgICBvblRhYmxlUm93TW91c2VMZWF2ZShldmVudDogYW55LCBpdGVtSWQ6IHN0cmluZywgaXRlbVR5cGU6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLmhvdmVyZWRJdGVtSWQgPSAnJztcbiAgICB9XG5cbiAgICBvbkNhcmRNb3VzZUVudGVyKGV2ZW50OiBhbnksIGl0ZW1JZDogc3RyaW5nLCBpdGVtVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIGlmICghdGhpcy5kZXZpY2VIYXNNb3VzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdW5pcUl0ZW1JZCA9IHRoaXMuZ2V0VW5pcUl0ZW1JZChpdGVtSWQsIGl0ZW1UeXBlKTtcbiAgICAgICAgdGhpcy5ob3ZlcmVkSXRlbUlkID0gdW5pcUl0ZW1JZDtcbiAgICB9XG5cbiAgICBvbkNhcmRNb3VzZUxlYXZlKGV2ZW50OiBhbnksIGl0ZW1JZDogc3RyaW5nLCBpdGVtVHlwZTogc3RyaW5nKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaG92ZXJlZEl0ZW1JZCA9ICcnO1xuICAgIH1cblxuICAgIC8vIGNhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciByZXNpemUgKyBhbmltYXRpb24gZW5kXG4gICAgd2luUmVzaXplKGUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jb250YWluZXJXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMuc2V0TGF5b3V0KCk7XG4gICAgfVxuXG4gICAgdHJhY2tCeUZ1bmMoaW5kZXg6IG51bWJlciwgaXRlbTogT2JqZWN0c0RhdGFSb3cpOiBhbnkge1xuICAgICAgICByZXR1cm4gaXRlbSAmJiBpdGVtLlVJRCA/IGl0ZW0uVUlEIDogaW5kZXg7XG4gICAgfVxuXG4gICAgY2xlYW5JdGVtcygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pdGVtc0NvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLl9pdGVtcyA9XG4gICAgICAgICAgICB0aGlzLnRvdGFsUm93cyA+IDAgPyBBcnJheTxPYmplY3RzRGF0YVJvdz4odGhpcy50b3RhbFJvd3MpIDogW107XG4gICAgICAgIHRoaXMuc2Nyb2xsSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVkT2JqZWN0SGVpZ2h0ID0gJyc7XG4gICAgfVxuXG4gICAgZ2V0VUlDb250cm9sKCk6IFVJQ29udHJvbCB7XG4gICAgICAgIHJldHVybiB0aGlzLnVpQ29udHJvbDtcbiAgICB9XG5cbiAgICBpbml0TGlzdERhdGEoXG4gICAgICAgIHVpQ29udHJvbDogVUlDb250cm9sLFxuICAgICAgICB0b3RhbFJvd3M6IG51bWJlcixcbiAgICAgICAgaXRlbXM6IE9iamVjdHNEYXRhUm93W10sXG4gICAgICAgIHZpZXdUeXBlOiBQZXBMaXN0Vmlld1R5cGUgPSAndGFibGUnLFxuICAgICAgICBpdGVtQ2xhc3MgPSAnJ1xuICAgICk6IHZvaWQge1xuICAgICAgICB0aGlzLnZpZXdUeXBlID0gdmlld1R5cGU7XG4gICAgICAgIHRoaXMuaXNUYWJsZSA9IHZpZXdUeXBlID09PSAndGFibGUnO1xuICAgICAgICAvLyB0aGlzLmlzQ2FyZFZpZXcgPSB2aWV3VHlwZSA9PT0gJ2NhcmRzJztcbiAgICAgICAgdGhpcy51aUNvbnRyb2wgPSB1aUNvbnRyb2w7XG4gICAgICAgIHRoaXMuaXRlbUNsYXNzID0gaXRlbUNsYXNzO1xuICAgICAgICB0aGlzLnNlbGVjdGVkSXRlbUlkID0gJyc7XG4gICAgICAgIHRoaXMudG90YWxSb3dzID0gdG90YWxSb3dzO1xuXG4gICAgICAgIC8vIGZpeCBidWcgZm9yIHRoZSBzY3JvbGxUbyB0aGF0IGRvZXNuJ3Qgd29yayBvbiBlZGdlIGRpdiAsIG5vdCB3aW5kb3dcbiAgICAgICAgLy8gY29uc3Qgc2Nyb2xsaW5nRWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50Q29udGFpbmVyKCk7XG4gICAgICAgIC8vIHNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG8oMCwgMCk7XG5cbiAgICAgICAgdGhpcy5jbGVhbkl0ZW1zKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVJdGVtcyhpdGVtcyk7XG5cbiAgICAgICAgdGhpcy5zZXRMYXlvdXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUl0ZW1zKGl0ZW1zOiBPYmplY3RzRGF0YVJvd1tdKTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSXRlbXMgPSB0aGlzLl9pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLml0ZW1zQ291bnRlciA9IGl0ZW1zLmxlbmd0aDtcbiAgICB9XG5cbiAgICB1cGRhdGVJdGVtKGRhdGE6IGFueSk6IHZvaWQge1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBpdGVtcyBsaXN0XG4gICAgICAgIGluZGV4ID0gdGhpcy5pdGVtcy5maW5kSW5kZXgoKGkpID0+IGkgJiYgaS5VSUQgPT09IGRhdGEuVUlEKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0gPSBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIHNjcm9sbEl0ZW1zIGxpc3RcbiAgICAgICAgaW5kZXggPSB0aGlzLnNjcm9sbEl0ZW1zLmZpbmRJbmRleCgoaSkgPT4gaSAmJiBpLlVJRCA9PT0gZGF0YS5VSUQpO1xuXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zY3JvbGxJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSXRlbXNbaW5kZXhdID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JDaGFuZ2VzID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJc0l0ZW1FZGl0YWJsZSh1aWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5pdGVtcy5maWx0ZXIoKHgpID0+IHguVUlELnRvU3RyaW5nKCkgPT09IHVpZCk7XG4gICAgICAgIGlmIChpdGVtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtWzBdLklzRWRpdGFibGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRJdGVtRGF0YUJ5SUQodWlkOiBzdHJpbmcpOiBPYmplY3RzRGF0YVJvdyB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmZpbmQoKGl0ZW0pID0+IGl0ZW0uVUlELnRvU3RyaW5nKCkgPT09IHVpZCk7XG4gICAgfVxufVxuIl19