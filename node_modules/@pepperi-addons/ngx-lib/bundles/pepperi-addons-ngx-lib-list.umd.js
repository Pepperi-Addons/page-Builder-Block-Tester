(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common'), require('@angular/material/core'), require('@angular/material/button'), require('@angular/material/checkbox'), require('@angular/material/radio'), require('@angular/material/icon'), require('@angular/material/menu'), require('@pepperi-addons/ngx-lib'), require('@pepperi-addons/ngx-lib/bread-crumbs'), require('@pepperi-addons/ngx-lib/button'), require('@pepperi-addons/ngx-lib/carousel'), require('@pepperi-addons/ngx-lib/icon'), require('@pepperi-addons/ngx-lib/form'), require('@pepperi-addons/ngx-lib/menu'), require('@pepperi-addons/ngx-lib/textbox'), require('@tweenjs/tween.js'), require('@angular/cdk/coercion')) :
    typeof define === 'function' && define.amd ? define('@pepperi-addons/ngx-lib/list', ['exports', '@angular/core', '@angular/common', '@angular/material/core', '@angular/material/button', '@angular/material/checkbox', '@angular/material/radio', '@angular/material/icon', '@angular/material/menu', '@pepperi-addons/ngx-lib', '@pepperi-addons/ngx-lib/bread-crumbs', '@pepperi-addons/ngx-lib/button', '@pepperi-addons/ngx-lib/carousel', '@pepperi-addons/ngx-lib/icon', '@pepperi-addons/ngx-lib/form', '@pepperi-addons/ngx-lib/menu', '@pepperi-addons/ngx-lib/textbox', '@tweenjs/tween.js', '@angular/cdk/coercion'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global['pepperi-addons'] = global['pepperi-addons'] || {}, global['pepperi-addons']['ngx-lib'] = global['pepperi-addons']['ngx-lib'] || {}, global['pepperi-addons']['ngx-lib'].list = {}), global.ng.core, global.ng.common, global.ng.material.core, global.ng.material.button, global.ng.material.checkbox, global.ng.material.radio, global.ng.material.icon, global.ng.material.menu, global['pepperi-addons']['ngx-lib'], global['pepperi-addons']['ngx-lib']['bread-crumbs'], global['pepperi-addons']['ngx-lib'].button, global['pepperi-addons']['ngx-lib'].carousel, global['pepperi-addons']['ngx-lib'].icon, global['pepperi-addons']['ngx-lib'].form, global['pepperi-addons']['ngx-lib'].menu, global['pepperi-addons']['ngx-lib'].textbox, global.tween, global.ng.cdk.coercion));
}(this, (function (exports, core, common, core$1, button, checkbox, radio, icon$1, menu, ngxLib, breadCrumbs, button$1, carousel, icon, form, menu$1, textbox, tween, coercion) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var tween__namespace = /*#__PURE__*/_interopNamespace(tween);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    function VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY() {
        return {
            checkResizeInterval: 1000,
            modifyOverflowStyleOfParentScroll: true,
            resizeBypassRefreshThreshold: 5,
            scrollAnimationTime: 750,
            scrollDebounceTime: 0,
            scrollThrottlingTime: 0,
            stripedTable: false
        };
    }
    var VirtualScrollerComponent = /** @class */ (function () {
        function VirtualScrollerComponent(element, renderer, zone, changeDetectorRef, platformId, options) {
            this.element = element;
            this.renderer = renderer;
            this.zone = zone;
            this.changeDetectorRef = changeDetectorRef;
            this.window = window;
            this._disable = false;
            this.executeRefreshOutsideAngularZone = false;
            this._enableUnequalChildrenSizes = false;
            this.RTL = false;
            this.useMarginInsteadOfTranslate = false;
            this.ssrViewportWidth = 1920;
            this.ssrViewportHeight = 1080;
            this._items = [];
            this.compareItems = function (item1, item2) { return item1 === item2; };
            this.vsChildRectChange = new core.EventEmitter();
            this.vsUpdate = new core.EventEmitter();
            this.vsChange = new core.EventEmitter();
            this.vsStart = new core.EventEmitter();
            this.vsEnd = new core.EventEmitter();
            this.calculatedScrollbarWidth = 0;
            this.calculatedScrollbarHeight = 0;
            this.padding = 0;
            this.previousViewPort = {};
            this.cachedPageSize = 0;
            this.previousScrollNumberElements = 0;
            this.isAngularUniversalSSR = common.isPlatformServer(platformId);
            this.checkResizeInterval = options.checkResizeInterval;
            this.modifyOverflowStyleOfParentScroll = options.modifyOverflowStyleOfParentScroll;
            this.resizeBypassRefreshThreshold = options.resizeBypassRefreshThreshold;
            this.scrollAnimationTime = options.scrollAnimationTime;
            this.scrollDebounceTime = options.scrollDebounceTime;
            this.scrollThrottlingTime = options.scrollThrottlingTime;
            this.scrollbarHeight = options.scrollbarHeight;
            this.scrollbarWidth = options.scrollbarWidth;
            this.stripedTable = options.stripedTable;
            this.horizontal = false;
            this.resetWrapGroupDimensions();
        }
        Object.defineProperty(VirtualScrollerComponent.prototype, "viewPortInfo", {
            get: function () {
                var pageInfo = this.previousViewPort || {};
                return {
                    startIndex: pageInfo.startIndex || 0,
                    endIndex: pageInfo.endIndex || 0,
                    scrollStartPosition: pageInfo.scrollStartPosition || 0,
                    scrollEndPosition: pageInfo.scrollEndPosition || 0,
                    scrollDirection: pageInfo.scrollDirection || 'forward',
                    maxScrollPosition: pageInfo.maxScrollPosition || 0,
                    startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,
                    endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0,
                };
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "disable", {
            get: function () {
                return this._disable;
            },
            set: function (value) {
                if (this._disable === value) {
                    return;
                }
                this._disable = value;
                if (this._disable) {
                    this.removeScrollEventHandlers();
                }
                else {
                    this.addScrollEventHandlers();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "enableUnequalChildrenSizes", {
            get: function () {
                return this._enableUnequalChildrenSizes;
            },
            set: function (value) {
                if (this._enableUnequalChildrenSizes === value) {
                    return;
                }
                this._enableUnequalChildrenSizes = value;
                this.minMeasuredChildWidth = undefined;
                this.minMeasuredChildHeight = undefined;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "bufferAmount", {
            get: function () {
                if (typeof (this._bufferAmount) === 'number' && this._bufferAmount >= 0) {
                    return this._bufferAmount;
                }
                else {
                    return this.enableUnequalChildrenSizes ? 5 : 0;
                }
            },
            set: function (value) {
                this._bufferAmount = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "scrollThrottlingTime", {
            get: function () {
                return this._scrollThrottlingTime;
            },
            set: function (value) {
                this._scrollThrottlingTime = value;
                this.updateOnScrollFunction();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "scrollDebounceTime", {
            get: function () {
                return this._scrollDebounceTime;
            },
            set: function (value) {
                this._scrollDebounceTime = value;
                this.updateOnScrollFunction();
            },
            enumerable: false,
            configurable: true
        });
        VirtualScrollerComponent.prototype.updateOnScrollFunction = function () {
            var _this_1 = this;
            if (this.scrollDebounceTime) {
                this.onScroll = this.debounce(function () {
                    _this_1.refresh_internal(false);
                }, this.scrollDebounceTime);
            }
            else if (this.scrollThrottlingTime) {
                this.onScroll = this.throttleTrailing(function () {
                    _this_1.refresh_internal(false);
                }, this.scrollThrottlingTime);
            }
            else {
                this.onScroll = function () {
                    _this_1.refresh_internal(false);
                };
            }
        };
        Object.defineProperty(VirtualScrollerComponent.prototype, "checkResizeInterval", {
            get: function () {
                return this._checkResizeInterval;
            },
            set: function (value) {
                if (this._checkResizeInterval === value) {
                    return;
                }
                this._checkResizeInterval = value;
                this.addScrollEventHandlers();
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                if (value === this._items) {
                    return;
                }
                this._items = value || [];
                this.refresh_internal(true);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(VirtualScrollerComponent.prototype, "horizontal", {
            get: function () {
                return this._horizontal;
            },
            set: function (value) {
                this._horizontal = value;
                this.updateDirection();
            },
            enumerable: false,
            configurable: true
        });
        VirtualScrollerComponent.prototype.revertParentOverscroll = function () {
            var scrollElement = this.getScrollElement();
            if (scrollElement && this.oldParentScrollOverflow) {
                scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;
                scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;
            }
            this.oldParentScrollOverflow = undefined;
        };
        Object.defineProperty(VirtualScrollerComponent.prototype, "parentScroll", {
            get: function () {
                return this._parentScroll;
            },
            set: function (value) {
                if (this._parentScroll === value) {
                    return;
                }
                this.revertParentOverscroll();
                this._parentScroll = value;
                this.addScrollEventHandlers();
                var scrollElement = this.getScrollElement();
                if (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {
                    this.oldParentScrollOverflow = { x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y'] };
                    scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';
                    scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';
                }
            },
            enumerable: false,
            configurable: true
        });
        VirtualScrollerComponent.prototype.ngOnInit = function () {
            this.addScrollEventHandlers();
        };
        VirtualScrollerComponent.prototype.ngOnDestroy = function () {
            this.removeScrollEventHandlers();
            this.revertParentOverscroll();
        };
        VirtualScrollerComponent.prototype.ngOnChanges = function (changes) {
            var indexLengthChanged = this.cachedItemsLength !== this.items.length;
            this.cachedItemsLength = this.items.length;
            var firstRun = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0;
            this.refresh_internal(indexLengthChanged || firstRun);
        };
        VirtualScrollerComponent.prototype.ngDoCheck = function () {
            if (this.cachedItemsLength !== this.items.length) {
                this.cachedItemsLength = this.items.length;
                this.refresh_internal(true);
                return;
            }
            if (this.previousViewPort && this.viewPortItems && this.viewPortItems.length > 0) {
                var itemsArrayChanged = false;
                for (var i = 0; i < this.viewPortItems.length; ++i) {
                    if (!this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])) {
                        itemsArrayChanged = true;
                        break;
                    }
                }
                if (itemsArrayChanged) {
                    this.refresh_internal(true);
                }
            }
        };
        VirtualScrollerComponent.prototype.refresh = function () {
            this.refresh_internal(true);
        };
        VirtualScrollerComponent.prototype.invalidateAllCachedMeasurements = function () {
            this.wrapGroupDimensions = {
                maxChildSizePerWrapGroup: [],
                numberOfKnownWrapGroupChildSizes: 0,
                sumOfKnownWrapGroupChildWidths: 0,
                sumOfKnownWrapGroupChildHeights: 0
            };
            this.minMeasuredChildWidth = undefined;
            this.minMeasuredChildHeight = undefined;
            this.refresh_internal(false);
        };
        VirtualScrollerComponent.prototype.invalidateCachedMeasurementForItem = function (item) {
            if (this.enableUnequalChildrenSizes) {
                var index = this.items && this.items.indexOf(item);
                if (index >= 0) {
                    this.invalidateCachedMeasurementAtIndex(index);
                }
            }
            else {
                this.minMeasuredChildWidth = undefined;
                this.minMeasuredChildHeight = undefined;
            }
            this.refresh_internal(false);
        };
        VirtualScrollerComponent.prototype.invalidateCachedMeasurementAtIndex = function (index) {
            if (this.enableUnequalChildrenSizes) {
                var cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];
                if (cachedMeasurement) {
                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;
                    --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;
                }
            }
            else {
                this.minMeasuredChildWidth = undefined;
                this.minMeasuredChildHeight = undefined;
            }
            this.refresh_internal(false);
        };
        VirtualScrollerComponent.prototype.scrollInto = function (item, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {
            if (alignToBeginning === void 0) { alignToBeginning = true; }
            if (additionalOffset === void 0) { additionalOffset = 0; }
            if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }
            if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }
            var index = this.items.indexOf(item);
            if (index === -1) {
                return;
            }
            this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);
        };
        VirtualScrollerComponent.prototype.scrollToIndex = function (index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {
            var _this_1 = this;
            if (alignToBeginning === void 0) { alignToBeginning = true; }
            if (additionalOffset === void 0) { additionalOffset = 0; }
            if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }
            if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }
            var maxRetries = 5;
            var retryIfNeeded = function () {
                --maxRetries;
                if (maxRetries <= 0) {
                    if (animationCompletedCallback) {
                        animationCompletedCallback();
                    }
                    return;
                }
                var dimensions = _this_1.calculateDimensions();
                var desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);
                if (_this_1.previousViewPort.startIndex === desiredStartIndex) {
                    if (animationCompletedCallback) {
                        animationCompletedCallback();
                    }
                    return;
                }
                _this_1.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);
            };
            this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);
        };
        VirtualScrollerComponent.prototype.scrollToIndex_internal = function (index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {
            if (alignToBeginning === void 0) { alignToBeginning = true; }
            if (additionalOffset === void 0) { additionalOffset = 0; }
            if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }
            if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }
            animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;
            var dimensions = this.calculateDimensions();
            var scroll = this.calculatePadding(index, dimensions) + additionalOffset;
            if (!alignToBeginning) {
                scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];
            }
            this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);
        };
        VirtualScrollerComponent.prototype.scrollToPosition = function (scrollPosition, animationMilliseconds, animationCompletedCallback) {
            var _this_1 = this;
            if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }
            if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }
            scrollPosition += this.getElementsOffset();
            animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;
            var scrollElement = this.getScrollElement();
            var animationRequest;
            if (this.currentTween) {
                this.currentTween.stop();
                this.currentTween = undefined;
            }
            if (!animationMilliseconds) {
                this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);
                this.refresh_internal(false, animationCompletedCallback);
                return;
            }
            var tweenConfigObj = { scrollPosition: scrollElement[this._scrollType] };
            var newTween = new tween__namespace.Tween(tweenConfigObj)
                .to({ scrollPosition: scrollPosition }, animationMilliseconds)
                .easing(tween__namespace.Easing.Quadratic.Out)
                .onUpdate(function (data) {
                if (isNaN(data.scrollPosition)) {
                    return;
                }
                _this_1.renderer.setProperty(scrollElement, _this_1._scrollType, data.scrollPosition);
                _this_1.refresh_internal(false);
            })
                .onStop(function () {
                cancelAnimationFrame(animationRequest);
            })
                .start();
            var animate = function (time) {
                if (!newTween["isPlaying"]()) {
                    return;
                }
                newTween.update(time);
                if (tweenConfigObj.scrollPosition === scrollPosition) {
                    _this_1.refresh_internal(false, animationCompletedCallback);
                    return;
                }
                _this_1.zone.runOutsideAngular(function () {
                    animationRequest = requestAnimationFrame(animate);
                });
            };
            animate();
            this.currentTween = newTween;
        };
        VirtualScrollerComponent.prototype.getElementSize = function (element) {
            var result = element.getBoundingClientRect();
            var styles = getComputedStyle(element);
            var marginTop = parseInt(styles['margin-top'], 10) || 0;
            var marginBottom = parseInt(styles['margin-bottom'], 10) || 0;
            var marginLeft = parseInt(styles['margin-left'], 10) || 0;
            var marginRight = parseInt(styles['margin-right'], 10) || 0;
            return {
                top: result.top + marginTop,
                bottom: result.bottom + marginBottom,
                left: result.left + marginLeft,
                right: result.right + marginRight,
                width: result.width + marginLeft + marginRight,
                height: result.height + marginTop + marginBottom
            };
        };
        VirtualScrollerComponent.prototype.checkScrollElementResized = function () {
            var boundingRect = this.getElementSize(this.getScrollElement());
            var sizeChanged;
            if (!this.previousScrollBoundingRect) {
                sizeChanged = true;
            }
            else {
                var widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);
                var heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);
                sizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;
            }
            if (sizeChanged) {
                this.previousScrollBoundingRect = boundingRect;
                if (boundingRect.width > 0 && boundingRect.height > 0) {
                    this.refresh_internal(false);
                }
            }
        };
        VirtualScrollerComponent.prototype.updateDirection = function () {
            if (this.horizontal) {
                this._childScrollDim = 'childWidth';
                this._invisiblePaddingProperty = 'scaleX';
                this._marginDir = 'margin-left';
                this._offsetType = 'offsetLeft';
                this._pageOffsetType = 'pageXOffset';
                this._scrollType = 'scrollLeft';
                this._translateDir = 'translateX';
            }
            else {
                this._childScrollDim = 'childHeight';
                this._invisiblePaddingProperty = 'scaleY';
                this._marginDir = 'margin-top';
                this._offsetType = 'offsetTop';
                this._pageOffsetType = 'pageYOffset';
                this._scrollType = 'scrollTop';
                this._translateDir = 'translateY';
            }
        };
        VirtualScrollerComponent.prototype.debounce = function (func, wait) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var throttled = this.throttleTrailing(func, wait);
            var result = function () {
                throttled['cancel']();
                throttled.apply(this, args);
            };
            result['cancel'] = function () {
                throttled['cancel']();
            };
            return result;
        };
        VirtualScrollerComponent.prototype.throttleTrailing = function (func, wait) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var timeout = undefined;
            var _arguments = args;
            var result = function () {
                var _this = this;
                _arguments = args;
                if (timeout) {
                    return;
                }
                if (wait <= 0) {
                    func.apply(_this, _arguments);
                }
                else {
                    timeout = setTimeout(function () {
                        timeout = undefined;
                        func.apply(_this, _arguments);
                    }, wait);
                }
            };
            result['cancel'] = function () {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = undefined;
                }
            };
            return result;
        };
        VirtualScrollerComponent.prototype.refresh_internal = function (itemsArrayModified, refreshCompletedCallback, maxRunTimes) {
            var _this_1 = this;
            if (refreshCompletedCallback === void 0) { refreshCompletedCallback = undefined; }
            if (maxRunTimes === void 0) { maxRunTimes = 2; }
            //note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).
            //The default of 2x max will probably be accurate enough without causing too large a performance bottleneck
            //The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.
            //Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent this.
            if (itemsArrayModified && this.previousViewPort && this.previousViewPort.scrollStartPosition > 0) {
                //if items were prepended, scroll forward to keep same items visible
                var oldViewPort_1 = this.previousViewPort;
                var oldViewPortItems_1 = this.viewPortItems;
                var oldRefreshCompletedCallback_1 = refreshCompletedCallback;
                refreshCompletedCallback = function () {
                    var scrollLengthDelta = _this_1.previousViewPort.scrollLength - oldViewPort_1.scrollLength;
                    if (scrollLengthDelta > 0 && _this_1.viewPortItems) {
                        var oldStartItem_1 = oldViewPortItems_1[0];
                        var oldStartItemIndex = _this_1.items.findIndex(function (x) { return _this_1.compareItems(oldStartItem_1, x); });
                        if (oldStartItemIndex > _this_1.previousViewPort.startIndexWithBuffer) {
                            var itemOrderChanged = false;
                            for (var i = 1; i < _this_1.viewPortItems.length; ++i) {
                                if (!_this_1.compareItems(_this_1.items[oldStartItemIndex + i], oldViewPortItems_1[i])) {
                                    itemOrderChanged = true;
                                    break;
                                }
                            }
                            if (!itemOrderChanged) {
                                _this_1.scrollToPosition(_this_1.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback_1);
                                return;
                            }
                        }
                    }
                    if (oldRefreshCompletedCallback_1) {
                        oldRefreshCompletedCallback_1();
                    }
                };
            }
            this.zone.runOutsideAngular(function () {
                requestAnimationFrame(function () {
                    if (itemsArrayModified) {
                        _this_1.resetWrapGroupDimensions();
                    }
                    var viewport = _this_1.calculateViewport();
                    var startChanged = itemsArrayModified || viewport.startIndex !== _this_1.previousViewPort.startIndex;
                    var endChanged = itemsArrayModified || viewport.endIndex !== _this_1.previousViewPort.endIndex;
                    var scrollLengthChanged = viewport.scrollLength !== _this_1.previousViewPort.scrollLength;
                    var paddingChanged = viewport.padding !== _this_1.previousViewPort.padding;
                    var scrollPositionChanged = viewport.scrollStartPosition !== _this_1.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !== _this_1.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !== _this_1.previousViewPort.maxScrollPosition;
                    var scrollDirection = _this_1.previousViewPort.endIndex <= viewport.endIndex ? 'forward' : 'backward';
                    _this_1.previousViewPort = viewport;
                    if (scrollLengthChanged) {
                        _this_1.renderer.setStyle(_this_1.invisiblePaddingElementRef.nativeElement, 'transform', _this_1._invisiblePaddingProperty + "(" + viewport.scrollLength + ")");
                        _this_1.renderer.setStyle(_this_1.invisiblePaddingElementRef.nativeElement, 'webkitTransform', _this_1._invisiblePaddingProperty + "(" + viewport.scrollLength + ")");
                    }
                    if (paddingChanged) {
                        if (_this_1.useMarginInsteadOfTranslate) {
                            _this_1.renderer.setStyle(_this_1.contentElementRef.nativeElement, _this_1._marginDir, viewport.padding + "px");
                        }
                        else {
                            _this_1.renderer.setStyle(_this_1.contentElementRef.nativeElement, 'transform', _this_1._translateDir + "(" + viewport.padding + "px)");
                            _this_1.renderer.setStyle(_this_1.contentElementRef.nativeElement, 'webkitTransform', _this_1._translateDir + "(" + viewport.padding + "px)");
                        }
                    }
                    if (_this_1.headerElementRef) {
                        var scrollPosition = _this_1.getScrollElement()[_this_1._scrollType];
                        var containerOffset = _this_1.getElementsOffset();
                        var offset = Math.max(scrollPosition - viewport.padding - containerOffset + _this_1.headerElementRef.nativeElement.clientHeight, 0);
                        _this_1.renderer.setStyle(_this_1.headerElementRef.nativeElement, 'transform', _this_1._translateDir + "(" + offset + "px)");
                        _this_1.renderer.setStyle(_this_1.headerElementRef.nativeElement, 'webkitTransform', _this_1._translateDir + "(" + offset + "px)");
                    }
                    var changeEventArg = (startChanged || endChanged) ? {
                        startIndex: viewport.startIndex,
                        endIndex: viewport.endIndex,
                        scrollStartPosition: viewport.scrollStartPosition,
                        scrollEndPosition: viewport.scrollEndPosition,
                        scrollDirection: scrollDirection,
                        startIndexWithBuffer: viewport.startIndexWithBuffer,
                        endIndexWithBuffer: viewport.endIndexWithBuffer,
                        maxScrollPosition: viewport.maxScrollPosition,
                    } : undefined;
                    if (startChanged || endChanged || scrollPositionChanged) {
                        var handleChanged = function () {
                            // update the scroll list to trigger re-render of components in viewport
                            _this_1.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? _this_1.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];
                            _this_1.vsUpdate.emit(_this_1.viewPortItems);
                            if (startChanged) {
                                _this_1.vsStart.emit(changeEventArg);
                            }
                            if (endChanged) {
                                _this_1.vsEnd.emit(changeEventArg);
                            }
                            if (startChanged || endChanged) {
                                _this_1.changeDetectorRef.markForCheck();
                                _this_1.vsChange.emit(changeEventArg);
                            }
                            if (maxRunTimes > 0) {
                                _this_1.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);
                                return;
                            }
                            if (refreshCompletedCallback) {
                                refreshCompletedCallback();
                            }
                        };
                        if (_this_1.executeRefreshOutsideAngularZone) {
                            handleChanged();
                        }
                        else {
                            _this_1.zone.run(handleChanged);
                        }
                    }
                    else {
                        if (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {
                            _this_1.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);
                            return;
                        }
                        if (refreshCompletedCallback) {
                            refreshCompletedCallback();
                        }
                    }
                });
            });
        };
        VirtualScrollerComponent.prototype.getScrollElement = function () {
            return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;
        };
        VirtualScrollerComponent.prototype.addScrollEventHandlers = function () {
            var _this_1 = this;
            if (this.isAngularUniversalSSR) {
                return;
            }
            var scrollElement = this.getScrollElement();
            this.removeScrollEventHandlers();
            this.zone.runOutsideAngular(function () {
                if (_this_1.parentScroll instanceof Window) {
                    _this_1.disposeScrollHandler = _this_1.renderer.listen('window', 'scroll', _this_1.onScroll);
                    _this_1.disposeResizeHandler = _this_1.renderer.listen('window', 'resize', _this_1.onScroll);
                }
                else {
                    _this_1.disposeScrollHandler = _this_1.renderer.listen(scrollElement, 'scroll', _this_1.onScroll);
                    if (_this_1._checkResizeInterval > 0) {
                        _this_1.checkScrollElementResizedTimer = setInterval(function () { _this_1.checkScrollElementResized(); }, _this_1._checkResizeInterval);
                    }
                }
            });
        };
        VirtualScrollerComponent.prototype.removeScrollEventHandlers = function () {
            if (this.checkScrollElementResizedTimer) {
                clearInterval(this.checkScrollElementResizedTimer);
            }
            if (this.disposeScrollHandler) {
                this.disposeScrollHandler();
                this.disposeScrollHandler = undefined;
            }
            if (this.disposeResizeHandler) {
                this.disposeResizeHandler();
                this.disposeResizeHandler = undefined;
            }
        };
        VirtualScrollerComponent.prototype.getElementsOffset = function () {
            if (this.isAngularUniversalSSR) {
                return 0;
            }
            var offset = 0;
            if (this.containerElementRef && this.containerElementRef.nativeElement) {
                offset += this.containerElementRef.nativeElement[this._offsetType];
            }
            if (this.parentScroll) {
                var scrollElement = this.getScrollElement();
                var elementClientRect = this.getElementSize(this.element.nativeElement);
                var scrollClientRect = this.getElementSize(scrollElement);
                if (this.horizontal) {
                    offset += elementClientRect.left - scrollClientRect.left;
                }
                else {
                    offset += elementClientRect.top - scrollClientRect.top;
                }
                if (!(this.parentScroll instanceof Window)) {
                    offset += scrollElement[this._scrollType];
                }
            }
            return offset;
        };
        VirtualScrollerComponent.prototype.countItemsPerWrapGroup = function () {
            if (this.isAngularUniversalSSR) {
                return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);
            }
            var propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';
            var children = ((this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;
            var childrenLength = children ? children.length : 0;
            if (childrenLength === 0) {
                return 1;
            }
            var firstOffset = children[0][propertyName];
            var result = 1;
            while (result < childrenLength && firstOffset === children[result][propertyName]) {
                ++result;
            }
            return result;
        };
        VirtualScrollerComponent.prototype.getScrollStartPosition = function () {
            var windowScrollValue = undefined;
            if (this.parentScroll instanceof Window) {
                windowScrollValue = window[this._pageOffsetType];
            }
            return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;
        };
        VirtualScrollerComponent.prototype.resetWrapGroupDimensions = function () {
            var oldWrapGroupDimensions = this.wrapGroupDimensions;
            this.invalidateAllCachedMeasurements();
            if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {
                return;
            }
            var itemsPerWrapGroup = this.countItemsPerWrapGroup();
            for (var wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {
                var oldWrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
                if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {
                    continue;
                }
                if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {
                    return;
                }
                var itemsChanged = false;
                var arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;
                for (var i = 0; i < itemsPerWrapGroup; ++i) {
                    if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {
                        itemsChanged = true;
                        break;
                    }
                }
                if (!itemsChanged) {
                    ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;
                    this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;
                    this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;
                }
            }
        };
        VirtualScrollerComponent.prototype.calculateDimensions = function () {
            var _a, _b;
            var scrollElement = this.getScrollElement();
            var maxCalculatedScrollBarSize = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll, so we default to this if not set by consuming application
            this.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);
            this.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);
            var viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));
            var viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));
            var content = (this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;
            var itemsPerWrapGroup = this.countItemsPerWrapGroup();
            var wrapGroupsPerPage;
            var defaultChildWidth;
            var defaultChildHeight;
            if (this.isAngularUniversalSSR) {
                viewportWidth = this.ssrViewportWidth;
                viewportHeight = this.ssrViewportHeight;
                defaultChildWidth = this.ssrChildWidth;
                defaultChildHeight = this.ssrChildHeight;
                var itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);
                var itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);
                wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;
            }
            else if (!this.enableUnequalChildrenSizes) {
                if (content.children.length > 0) {
                    if (!this.childWidth || !this.childHeight) {
                        if (!this.minMeasuredChildWidth && viewportWidth > 0) {
                            this.minMeasuredChildWidth = viewportWidth;
                        }
                        if (!this.minMeasuredChildHeight && viewportHeight > 0) {
                            this.minMeasuredChildHeight = viewportHeight;
                        }
                    }
                    var child = content.children[0];
                    var clientRect = this.getElementSize(child);
                    this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);
                    this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);
                    // Added for getting the child height (for card view, return all the clientRect object).
                    if (((_a = this._lastChildRect) === null || _a === void 0 ? void 0 : _a.height) !== (clientRect === null || clientRect === void 0 ? void 0 : clientRect.height) ||
                        ((_b = this._lastChildRect) === null || _b === void 0 ? void 0 : _b.width) !== (clientRect === null || clientRect === void 0 ? void 0 : clientRect.width)) {
                        this._lastChildRect = clientRect;
                        this.vsChildRectChange.emit(clientRect);
                    }
                }
                defaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;
                defaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;
                var itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);
                var itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);
                wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;
            }
            else {
                var scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);
                var arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;
                var wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);
                var maxWidthForWrapGroup = 0;
                var maxHeightForWrapGroup = 0;
                var sumOfVisibleMaxWidths = 0;
                var sumOfVisibleMaxHeights = 0;
                wrapGroupsPerPage = 0;
                for (var i = 0; i < content.children.length; ++i) {
                    ++arrayStartIndex;
                    var child = content.children[i];
                    var clientRect = this.getElementSize(child);
                    maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);
                    maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);
                    if (arrayStartIndex % itemsPerWrapGroup === 0) {
                        var oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];
                        if (oldValue) {
                            --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                            this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;
                            this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;
                        }
                        ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                        var items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex);
                        this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {
                            childWidth: maxWidthForWrapGroup,
                            childHeight: maxHeightForWrapGroup,
                            items: items
                        };
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;
                        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;
                        if (this.horizontal) {
                            var maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));
                            if (scrollOffset > 0) {
                                var scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);
                                maxVisibleWidthForWrapGroup -= scrollOffsetToRemove;
                                scrollOffset -= scrollOffsetToRemove;
                            }
                            sumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;
                            if (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {
                                ++wrapGroupsPerPage;
                            }
                        }
                        else {
                            var maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));
                            if (scrollOffset > 0) {
                                var scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);
                                maxVisibleHeightForWrapGroup -= scrollOffsetToRemove;
                                scrollOffset -= scrollOffsetToRemove;
                            }
                            sumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;
                            if (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {
                                ++wrapGroupsPerPage;
                            }
                        }
                        ++wrapGroupIndex;
                        maxWidthForWrapGroup = 0;
                        maxHeightForWrapGroup = 0;
                    }
                }
                var averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                var averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;
                defaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;
                defaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;
                if (this.horizontal) {
                    if (viewportWidth > sumOfVisibleMaxWidths) {
                        wrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);
                    }
                }
                else {
                    if (viewportHeight > sumOfVisibleMaxHeights) {
                        wrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);
                    }
                }
            }
            var itemCount = this.items.length;
            var itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;
            var pageCount_fractional = itemCount / itemsPerPage;
            var numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);
            var scrollLength = 0;
            var defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;
            if (this.enableUnequalChildrenSizes) {
                var numUnknownChildSizes = 0;
                for (var i = 0; i < numberOfWrapGroups; ++i) {
                    var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                    if (childSize) {
                        scrollLength += childSize;
                    }
                    else {
                        ++numUnknownChildSizes;
                    }
                }
                scrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);
            }
            else {
                scrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;
            }
            if (this.headerElementRef) {
                scrollLength += this.headerElementRef.nativeElement.clientHeight;
            }
            var viewportLength = this.horizontal ? viewportWidth : viewportHeight;
            var maxScrollPosition = Math.max(scrollLength - viewportLength, 0);
            return {
                childHeight: defaultChildHeight,
                childWidth: defaultChildWidth,
                itemCount: itemCount,
                itemsPerPage: itemsPerPage,
                itemsPerWrapGroup: itemsPerWrapGroup,
                maxScrollPosition: maxScrollPosition,
                pageCount_fractional: pageCount_fractional,
                scrollLength: scrollLength,
                viewportLength: viewportLength,
                wrapGroupsPerPage: wrapGroupsPerPage,
            };
        };
        VirtualScrollerComponent.prototype.calculatePadding = function (arrayStartIndexWithBuffer, dimensions) {
            if (dimensions.itemCount === 0) {
                return 0;
            }
            var defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];
            var startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;
            if (!this.enableUnequalChildrenSizes) {
                return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;
            }
            var numUnknownChildSizes = 0;
            var result = 0;
            for (var i = 0; i < startingWrapGroupIndex; ++i) {
                var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                if (childSize) {
                    result += childSize;
                }
                else {
                    ++numUnknownChildSizes;
                }
            }
            result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);
            return result;
        };
        VirtualScrollerComponent.prototype.calculatePageInfo = function (scrollPosition, dimensions) {
            var scrollPercentage = 0;
            if (this.enableUnequalChildrenSizes) {
                var numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);
                var totalScrolledLength = 0;
                var defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];
                for (var i = 0; i < numberOfWrapGroups; ++i) {
                    var childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];
                    if (childSize) {
                        totalScrolledLength += childSize;
                    }
                    else {
                        totalScrolledLength += defaultScrollLengthPerWrapGroup;
                    }
                    if (scrollPosition < totalScrolledLength) {
                        scrollPercentage = i / numberOfWrapGroups;
                        break;
                    }
                }
            }
            else {
                scrollPercentage = scrollPosition / dimensions.scrollLength;
            }
            var startingArrayIndex_fractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;
            var maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;
            var arrayStartIndex = Math.min(Math.floor(startingArrayIndex_fractional), maxStart);
            arrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup
            if (this.stripedTable) {
                var bufferBoundary = 2 * dimensions.itemsPerWrapGroup;
                if (arrayStartIndex % bufferBoundary !== 0) {
                    arrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);
                }
            }
            var arrayEndIndex = Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;
            var endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;
            if (endIndexWithinWrapGroup > 0) {
                arrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup
            }
            if (isNaN(arrayStartIndex)) {
                arrayStartIndex = 0;
            }
            if (isNaN(arrayEndIndex)) {
                arrayEndIndex = 0;
            }
            arrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);
            arrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);
            var bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;
            var startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);
            var endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);
            return {
                startIndex: arrayStartIndex,
                endIndex: arrayEndIndex,
                startIndexWithBuffer: startIndexWithBuffer,
                endIndexWithBuffer: endIndexWithBuffer,
                scrollStartPosition: scrollPosition,
                scrollEndPosition: scrollPosition + dimensions.viewportLength,
                maxScrollPosition: dimensions.maxScrollPosition
            };
        };
        VirtualScrollerComponent.prototype.calculateViewport = function () {
            var dimensions = this.calculateDimensions();
            var offset = this.getElementsOffset();
            var scrollStartPosition = this.getScrollStartPosition();
            if (scrollStartPosition > (dimensions.scrollLength + offset) && !(this.parentScroll instanceof Window)) {
                scrollStartPosition = dimensions.scrollLength;
            }
            else {
                scrollStartPosition -= offset;
            }
            scrollStartPosition = Math.max(0, scrollStartPosition);
            var pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);
            var newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);
            var newScrollLength = dimensions.scrollLength;
            return {
                startIndex: pageInfo.startIndex,
                endIndex: pageInfo.endIndex,
                startIndexWithBuffer: pageInfo.startIndexWithBuffer,
                endIndexWithBuffer: pageInfo.endIndexWithBuffer,
                padding: Math.round(newPadding),
                scrollLength: Math.round(newScrollLength),
                scrollStartPosition: pageInfo.scrollStartPosition,
                scrollEndPosition: pageInfo.scrollEndPosition,
                maxScrollPosition: pageInfo.maxScrollPosition
            };
        };
        return VirtualScrollerComponent;
    }());
    VirtualScrollerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'virtual-scroller,[virtualScroller]',
                    exportAs: 'virtualScroller',
                    template: "\n    <div class=\"total-padding\" #invisiblePadding></div>\n    <div class=\"scrollable-content\" #content>\n      <ng-content></ng-content>\n    </div>\n  ",
                    host: {
                        '[class.horizontal]': "horizontal",
                        '[class.vertical]': "!horizontal",
                        '[class.selfScroll]': "!parentScroll",
                        '[class.rtl]': "RTL"
                    },
                    styles: ["\n    :host {\n      position: relative;\n\t  \tdisplay: block;\n      -webkit-overflow-scrolling: touch;\n    }\n\t\t:host.horizontal.selfScroll {\n      overflow-y: visible;\n      overflow-x: auto;\n\t\t}\n\t\t:host.horizontal.selfScroll.rtl {\n\t\t\ttransform: scaleX(-1);\n\t\t}\n\t\t:host.vertical.selfScroll {\n      overflow-y: auto;\n      overflow-x: visible;\n\t\t}\n    .scrollable-content {\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      max-width: 100vw;\n      max-height: 100vh;\n      position: absolute;\n    }\n\t\t.scrollable-content ::ng-deep > * {\n\t\t\tbox-sizing: border-box;\n\t\t}\n\t\t:host.horizontal {\n\t\t\twhite-space: nowrap;\n\t\t}\n\t\t:host.horizontal .scrollable-content {\n\t\t\tdisplay: flex;\n\t\t}\n\t\t:host.horizontal .scrollable-content ::ng-deep > * {\n\t\t\tflex-shrink: 0;\n\t\t\tflex-grow: 0;\n\t\t\twhite-space: initial;\n\t\t}\n\t\t:host.horizontal.rtl .scrollable-content ::ng-deep > * {\n\t\t\ttransform:scaleX(-1);\n\t\t}\n    .total-padding {\n      position: absolute;\n      top: 0;\n      left: 0;\n      height: 1px;\n      width: 1px;\n      transform-origin: 0 0;\n      opacity: 0;\n    }\n    :host.horizontal .total-padding {\n      height: 100%;\n    }\n  "]
                },] }
    ];
    VirtualScrollerComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: core.Renderer2 },
        { type: core.NgZone },
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: ['virtual-scroller-default-options',] }] }
    ]; };
    VirtualScrollerComponent.propDecorators = {
        disable: [{ type: core.Input }],
        executeRefreshOutsideAngularZone: [{ type: core.Input }],
        enableUnequalChildrenSizes: [{ type: core.Input }],
        RTL: [{ type: core.Input }],
        useMarginInsteadOfTranslate: [{ type: core.Input }],
        modifyOverflowStyleOfParentScroll: [{ type: core.Input }],
        stripedTable: [{ type: core.Input }],
        scrollbarWidth: [{ type: core.Input }],
        scrollbarHeight: [{ type: core.Input }],
        childWidth: [{ type: core.Input }],
        childHeight: [{ type: core.Input }],
        ssrChildWidth: [{ type: core.Input }],
        ssrChildHeight: [{ type: core.Input }],
        ssrViewportWidth: [{ type: core.Input }],
        ssrViewportHeight: [{ type: core.Input }],
        bufferAmount: [{ type: core.Input }],
        scrollAnimationTime: [{ type: core.Input }],
        resizeBypassRefreshThreshold: [{ type: core.Input }],
        scrollThrottlingTime: [{ type: core.Input }],
        scrollDebounceTime: [{ type: core.Input }],
        checkResizeInterval: [{ type: core.Input }],
        items: [{ type: core.Input }],
        compareItems: [{ type: core.Input }],
        horizontal: [{ type: core.Input }],
        parentScroll: [{ type: core.Input }],
        vsChildRectChange: [{ type: core.Output }],
        vsUpdate: [{ type: core.Output }],
        vsChange: [{ type: core.Output }],
        vsStart: [{ type: core.Output }],
        vsEnd: [{ type: core.Output }],
        contentElementRef: [{ type: core.ViewChild, args: ['content', { read: core.ElementRef, static: true },] }],
        invisiblePaddingElementRef: [{ type: core.ViewChild, args: ['invisiblePadding', { read: core.ElementRef, static: true },] }],
        headerElementRef: [{ type: core.ContentChild, args: ['header', { read: core.ElementRef, static: false },] }],
        containerElementRef: [{ type: core.ContentChild, args: ['container', { read: core.ElementRef, static: false },] }]
    };
    var VirtualScrollerModule = /** @class */ (function () {
        function VirtualScrollerModule() {
        }
        return VirtualScrollerModule;
    }());
    VirtualScrollerModule.decorators = [
        { type: core.NgModule, args: [{
                    exports: [VirtualScrollerComponent],
                    declarations: [VirtualScrollerComponent],
                    imports: [common.CommonModule],
                    providers: [
                        {
                            provide: 'virtual-scroller-default-options',
                            useFactory: VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY
                        }
                    ]
                },] }
    ];

    var PepSelectionData = /** @class */ (function () {
        function PepSelectionData() {
        }
        return PepSelectionData;
    }());
    var DEFAULT_PAGE_SIZE = 50;

    var PepListComponent = /** @class */ (function () {
        function PepListComponent(hostElement, layoutService, sessionService, cd, renderer, zone) {
            var _this = this;
            this.hostElement = hostElement;
            this.layoutService = layoutService;
            this.sessionService = sessionService;
            this.cd = cd;
            this.renderer = renderer;
            this.zone = zone;
            this.noDataFoundMsg = null;
            this.selectionTypeForActions = 'multi';
            this.showCardSelection = false;
            this.hideAllSelectionInMulti = false;
            this.cardSize = 'md';
            this._viewType = '';
            this.firstFieldAsLink = false;
            this.supportSorting = true;
            this.supportResizing = true;
            this._parentScroll = null;
            this.disabled = false;
            this._lockEvents = false;
            this.lockItemInnerEvents = false;
            this.printMode = false;
            this.isReport = false;
            this.totalsRow = [];
            this.pagerType = 'scroll';
            this.pageSize = DEFAULT_PAGE_SIZE;
            this.pageIndex = 0;
            // @Input() startIndex = 0;
            this.scrollAnimationTime = 500;
            this.scrollDebounceTime = 0;
            this.scrollThrottlingTime = 0;
            this._useAsWebComponent = false;
            this.itemClick = new core.EventEmitter();
            this.fieldClick = new core.EventEmitter();
            this.valueChange = new core.EventEmitter();
            this.sortingChange = new core.EventEmitter();
            this.selectedItemsChange = new core.EventEmitter();
            this.selectedItemChange = new core.EventEmitter();
            this.selectAllClick = new core.EventEmitter();
            // @Output()
            // singleActionClick: EventEmitter<any> = new EventEmitter<any>();
            this.listLoad = new core.EventEmitter();
            this.loadItems = new core.EventEmitter();
            this.loadPage = new core.EventEmitter();
            this.startIndexChange = new core.EventEmitter();
            this._layout = null;
            this.totalRows = -1;
            this.isTable = false;
            this.hasColumnWidthOfTypePercentage = true;
            this._items = null;
            this.itemsCounter = 0;
            this.SEPARATOR = ',';
            this.isAllSelected = false;
            this.selectedItems = new Map();
            this.unSelectedItems = new Map();
            this.selectedItemId = '';
            this.hoveredItemId = '';
            this.containerWidth = 0;
            this.tableScrollWidth = 0;
            this._loadingItemsFromApi = false;
            this.deviceHasMouse = false;
            // For resize
            this.pressedColumn = '';
            this.startX = 0;
            this.startWidth = 0;
            this.tableStartWidth = 0;
            // For sorting
            this.isAsc = true;
            this.sortBy = '';
            this.isUserSelected = false;
            this.checkForChanges = null;
            // this.nativeWindow = window;
            this.layoutService.onResize$.subscribe(function (size) {
                _this.screenSize = size;
            });
            this.layoutService.onMouseOver$.subscribe(function (deviceHasMouse) {
                _this.deviceHasMouse = deviceHasMouse;
            });
        }
        Object.defineProperty(PepListComponent.prototype, "viewType", {
            get: function () {
                return this._viewType;
            },
            set: function (value) {
                this._viewType = value;
                this.isTable = value === 'table';
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "parentScroll", {
            get: function () {
                return this._parentScroll;
            },
            set: function (value) {
                this._parentScroll = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "lockEvents", {
            get: function () {
                return this._lockEvents;
            },
            set: function (value) {
                this._lockEvents = value;
                if (this._lockEvents) {
                    this.renderer.addClass(this.hostElement.nativeElement, 'lock-events');
                }
                else {
                    this.renderer.removeClass(this.hostElement.nativeElement, 'lock-events');
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "useAsWebComponent", {
            get: function () {
                return this._useAsWebComponent;
            },
            set: function (value) {
                this._useAsWebComponent = value;
                if (value) {
                    this.exportFunctionsOnHostElement();
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "layout", {
            get: function () {
                return this._layout;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListComponent.prototype, "loadingItemsFromApi", {
            get: function () {
                return this._loadingItemsFromApi;
            },
            enumerable: false,
            configurable: true
        });
        PepListComponent.prototype.ngOnInit = function () {
            this.containerWidth = 0;
            this.deviceHasMouse = this.layoutService.getDeviceHasMouse();
        };
        PepListComponent.prototype.ngOnChanges = function (changes) {
            if (this.containerWidth <= 0) {
                this.setContainerWidth();
            }
        };
        PepListComponent.prototype.ngOnDestroy = function () {
            // if (this.valueChange) {
            //     this.valueChange.unsubscribe();
            // }
            // if (this.loadItems) {
            //     this.loadItems.unsubscribe();
            // }
            // if (this.loadPage) {
            //     this.loadPage.unsubscribe();
            // }
            // if (this.sortingChange) {
            //     this.sortingChange.unsubscribe();
            // }
            // if (this.fieldClick) {
            //     this.fieldClick.unsubscribe();
            // }
            // if (this.itemClick) {
            //     this.itemClick.unsubscribe();
            // }
            // if (this.listLoad) {
            //     this.listLoad.unsubscribe();
            // }
            this.saveSortingToSession();
        };
        PepListComponent.prototype.getScrollingElement = function () {
            var _a;
            return this.parentScroll ? this.parentScroll : (_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.contentElementRef.nativeElement.parentElement;
        };
        PepListComponent.prototype.scrollToTop = function (animate) {
            var _this = this;
            if (animate === void 0) { animate = true; }
            var scrollingElement = this.getScrollingElement();
            if (scrollingElement) {
                var scrollTop_1 = 0;
                // totally disable animate
                if (!animate || this.scrollAnimationTime === 0) {
                    if (scrollingElement instanceof Window) {
                        window.scrollTo(0, scrollTop_1);
                    }
                    else {
                        scrollingElement.scrollTop = scrollTop_1;
                    }
                }
                else {
                    var animationRequest_1;
                    var isWindow_1 = scrollingElement instanceof Window;
                    var currentScrollTop = scrollingElement instanceof Window
                        ? window.pageYOffset
                        : scrollingElement.scrollTop;
                    if (this.currentTween !== undefined) {
                        this.currentTween.stop();
                    }
                    this.currentTween = new tween__namespace.Tween({ scrollTop: currentScrollTop })
                        .to({ scrollTop: scrollTop_1 }, this.scrollAnimationTime)
                        .easing(tween__namespace.Easing.Quadratic.Out)
                        .onUpdate(function (data) {
                        if (isNaN(data.scrollTop)) {
                            return;
                        }
                        if (isWindow_1) {
                            window.scrollTo(0, data.scrollTop);
                        }
                        else {
                            _this.renderer.setProperty(scrollingElement, 'scrollTop', data.scrollTop);
                        }
                    })
                        .onStop(function () {
                        cancelAnimationFrame(animationRequest_1);
                    })
                        .start();
                    var animate_1 = function (time) {
                        _this.currentTween.update(time);
                        if (_this.currentTween._object.scrollTop !== scrollTop_1) {
                            _this.zone.runOutsideAngular(function () {
                                animationRequest_1 = requestAnimationFrame(animate_1);
                            });
                        }
                    };
                    animate_1();
                }
            }
        };
        PepListComponent.prototype.setContainerWidth = function () {
            var selectionCheckBoxWidth = this.selectionTypeForActions === 'multi' ? 44 : 0;
            var rowHeight = 40; // the table row height (2.5rem * 16font-size).
            var style = window.getComputedStyle(this.hostElement.nativeElement.parentElement);
            // The container-fluid class padding left + right + border
            var containerFluidSpacing = parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
            var parentContainer = this.hostElement.nativeElement.parentElement.parentElement > 0
                ? this.hostElement.nativeElement.parentElement.parentElement
                : this.hostElement.nativeElement.parentElement;
            // Calculate if vertical scroll should appear, if so set the scroll width. (this.totalRows + 1) + 1 is for the header row.
            this.tableScrollWidth = parentContainer.clientHeight < rowHeight * (this.totalRows + 1)
                ? this.layoutService.getScrollbarWidth()
                : 0;
            // The selectionCheckBoxWidth width + containerFluidSpacing + this.tableScrollWidth.
            var rowHeaderWidthToSub = containerFluidSpacing + selectionCheckBoxWidth + this.tableScrollWidth;
            this.containerWidth = parentContainer.offsetWidth - rowHeaderWidthToSub;
        };
        PepListComponent.prototype.saveSortingToSession = function () {
            this.sessionService.setObject(PepListComponent.SORT_BY_STATE_KEY, this.sortBy);
            this.sessionService.setObject(PepListComponent.ASCENDING_STATE_KEY, this.isAsc);
        };
        PepListComponent.prototype.getTopItems = function () {
            return this.isTable
                ? PepListComponent.TOP_ITEMS_TABLE
                : PepListComponent.TOP_ITEMS_THUMBNAILS;
        };
        // private disableScroll(disable: boolean) {
        //     if (disable) {
        //         this.renderer.addClass(this.getParentContainer(), 'lock-events');
        //     } else {
        //         this.renderer.removeClass(this.getParentContainer(), 'lock-events');
        //     }
        // }
        PepListComponent.prototype.toggleLoadingItemsFropApi = function (loadingItemsFromApi) {
            this._loadingItemsFromApi = loadingItemsFromApi;
            // this.disableScroll(loadingItemsFromApi);
        };
        PepListComponent.prototype.updateCurrentPageItems = function (startIndex, endIndex) {
            this.currentPageItems = this.items.slice(startIndex, endIndex);
        };
        PepListComponent.prototype.setSelectionItems = function (itemId, uniqItemId, isChecked) {
            // Set selected item checkbox
            if (this.isAllSelected) {
                if (isChecked) {
                    this.unSelectedItems.delete(itemId);
                    this.selectedItems.set(itemId, uniqItemId);
                }
                else {
                    this.selectedItems.delete(itemId);
                    this.unSelectedItems.set(itemId, uniqItemId);
                }
            }
            else {
                if (isChecked) {
                    this.unSelectedItems.delete(itemId);
                    this.selectedItems.set(itemId, uniqItemId);
                }
                else {
                    this.selectedItems.delete(itemId);
                    this.unSelectedItems.set(itemId, uniqItemId);
                }
            }
        };
        PepListComponent.prototype.getUniqItemId = function (itemId, itemType) {
            if (itemType === void 0) { itemType = ''; }
            return itemId + this.SEPARATOR + itemType;
        };
        PepListComponent.prototype.setLayout = function () {
            var _this = this;
            if (this.totalRows === 0 ||
                !this._layout ||
                !this._layout.ControlFields ||
                this._layout.ControlFields.length === 0) {
                return;
            }
            this._layout.ControlFields.forEach(function (cf) {
                if (cf.ColumnWidth === 0) {
                    cf.ColumnWidth = 10;
                }
                if (_this.isTable &&
                    (cf.FieldType === ngxLib.FIELD_TYPE.Image ||
                        // cf.FieldType === FIELD_TYPE.Indicators || ???
                        cf.FieldType === ngxLib.FIELD_TYPE.Signature ||
                        cf.FieldType === ngxLib.FIELD_TYPE.NumberIntegerQuantitySelector ||
                        cf.FieldType === ngxLib.FIELD_TYPE.NumberRealQuantitySelector ||
                        cf.FieldType === ngxLib.FIELD_TYPE.NumberIntegerForMatrix ||
                        cf.FieldType === ngxLib.FIELD_TYPE.NumberRealForMatrix ||
                        cf.FieldType === ngxLib.FIELD_TYPE.Package ||
                        cf.ApiName === 'UnitsQuantity' ||
                        cf.ApiName === 'QuantitySelector')) {
                    cf.Layout.XAlignment = 3;
                }
            });
            if (!this.cd['destroyed']) {
                this.cd.detectChanges();
            }
            // Set the columns width.
            if (this.containerWidth <= 0) {
                this.setContainerWidth();
            }
            this.calcColumnsWidth();
            this.checkForChanges = new Date().getTime();
        };
        PepListComponent.prototype.calcColumnsWidth = function () {
            var fixedMultiple = 3.78; // for converting em to pixel.
            var length = this._layout.ControlFields.length;
            var selectionCheckBoxWidth = this.selectionTypeForActions === 'multi' ? 44 : 0;
            // Is table AND there is at least one column of width type of percentage.
            if (this.isTable) {
                if (this._layout && this._layout.ControlFields) {
                    this.hasColumnWidthOfTypePercentage =
                        this._layout.ControlFields.filter(function (cf) { return cf.ColumnWidthType === 1; }).length === 0;
                }
            }
            // If the columns size is fixed and the total is small then the container change it to percentage.
            if (!this.hasColumnWidthOfTypePercentage) {
                var totalFixedColsWidth = this._layout.ControlFields.map(function (cf) { return cf.ColumnWidth * fixedMultiple; }).reduce(function (sum, current) { return sum + current; });
                if (window.innerWidth > totalFixedColsWidth) {
                    this.hasColumnWidthOfTypePercentage = true;
                }
            }
            var totalCalcColsWidth = 0;
            // Calc by percentage
            if (this.hasColumnWidthOfTypePercentage) {
                var totalColsWidth = this._layout.ControlFields.map(function (cf) { return cf.ColumnWidth; }).reduce(function (sum, current) { return sum + current; });
                for (var index = 0; index < length; index++) {
                    var uiControlField = this._layout.ControlFields[index];
                    var calcColumnWidthPercentage = (100 / totalColsWidth) * uiControlField.ColumnWidth;
                    uiControlField.calcColumnWidth = Math.floor((this.containerWidth * calcColumnWidthPercentage) / 100);
                    if (index === length - 1) {
                        uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString = 'calc(100% - ' + totalCalcColsWidth + 'px)'; // For 100%
                    }
                    else {
                        uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString = uiControlField.calcColumnWidth + 'px';
                        totalCalcColsWidth += uiControlField.calcColumnWidth;
                    }
                }
                this.renderer.setStyle(this.hostElement.nativeElement, 'width', 'inherit');
            }
            else {
                for (var index = 0; index < length; index++) {
                    var uiControlField = this._layout
                        .ControlFields[index];
                    var currentFixedWidth = Math.floor(uiControlField.ColumnWidth * fixedMultiple);
                    if (index === length - 1) {
                        uiControlField.calcTitleColumnWidthString = currentFixedWidth + 'px';
                        uiControlField.calcColumnWidthString = currentFixedWidth + 'px';
                    }
                    else {
                        uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString = currentFixedWidth + 'px';
                    }
                    totalCalcColsWidth += currentFixedWidth;
                }
                this.renderer.setStyle(this.hostElement.nativeElement, 'width', totalCalcColsWidth + selectionCheckBoxWidth + 'px');
            }
        };
        PepListComponent.prototype.initResizeData = function () {
            this.startX = 0;
            this.startWidth = 0;
            this.tableStartWidth = 0;
            this.pressedColumn = '';
        };
        PepListComponent.prototype.getParent = function (el, parentSelector) {
            // If no parentSelector defined will bubble up all the way to *document*
            if (parentSelector === undefined) {
                parentSelector = document;
            }
            var parent = [];
            var p = el.parentNode;
            while (p &&
                p.className !== '' &&
                p.className.indexOf(parentSelector) === -1 &&
                parentSelector !== document) {
                var o = p;
                p = o.parentNode;
            }
            if (p.className.indexOf(parentSelector) > -1) {
                parent.push(p); // Push that parentSelector you wanted to stop at
            }
            return parent;
        };
        PepListComponent.prototype.cleanItems = function () {
            this.itemsCounter = 0;
            this._items =
                this.totalRows > 0 ? Array(this.totalRows) : [];
            this.currentPageItems = [];
            this.calculatedObjectHeight = '';
        };
        PepListComponent.prototype.initVariablesFromSession = function (items) {
            var selectedItemsObject = this.sessionService.getObject(PepListComponent.SELECTED_ITEMS_STATE_KEY);
            var selectedItemsFromMap = selectedItemsObject && selectedItemsObject.length > 0
                ? new Map(selectedItemsObject)
                : null;
            if (selectedItemsFromMap != null &&
                typeof selectedItemsFromMap.size !== 'undefined' &&
                selectedItemsFromMap.size > 0) {
                this.selectedItems = selectedItemsFromMap;
                this.sessionService.removeObject(PepListComponent.SELECTED_ITEMS_STATE_KEY);
            }
            else {
                this.selectedItems.clear();
            }
            var unSelectedItemsObject = this.sessionService.getObject(PepListComponent.UN_SELECTED_ITEMS_STATE_KEY);
            var unSelectedItemsMap = unSelectedItemsObject && unSelectedItemsObject.length > 0
                ? new Map(unSelectedItemsObject)
                : null;
            if (unSelectedItemsMap != null &&
                typeof unSelectedItemsMap.size !== 'undefined' &&
                unSelectedItemsMap.size > 0) {
                this.unSelectedItems = unSelectedItemsMap;
                this.sessionService.removeObject(PepListComponent.UN_SELECTED_ITEMS_STATE_KEY);
            }
            else {
                this.unSelectedItems.clear();
            }
            var isAllSelected = this.sessionService.getObject(PepListComponent.ALL_SELECTED_STATE_KEY);
            if (isAllSelected != null) {
                this.isAllSelected = isAllSelected && this.getIsAllSelected(items);
                this.sessionService.removeObject(PepListComponent.ALL_SELECTED_STATE_KEY);
            }
            else {
                this.isAllSelected = false;
            }
            var sortBy = this.sessionService.getObject(PepListComponent.SORT_BY_STATE_KEY);
            if (sortBy && sortBy !== '') {
                this.sortBy = sortBy;
                this.sessionService.removeObject(PepListComponent.SORT_BY_STATE_KEY);
            }
            else {
                this.sortBy = '';
            }
            var isAsc = this.sessionService.getObject(PepListComponent.ASCENDING_STATE_KEY);
            if (isAsc != null) {
                this.isAsc = isAsc;
                this.sessionService.removeObject(PepListComponent.ASCENDING_STATE_KEY);
            }
            else {
                this.isAsc = true;
            }
        };
        PepListComponent.prototype.getIsAllSelected = function (items) {
            var e_1, _b;
            var _a;
            var result = true;
            if (((_a = this.selectedItems) === null || _a === void 0 ? void 0 : _a.size) > 0 && (items === null || items === void 0 ? void 0 : items.length) > 0) {
                try {
                    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                        var item = items_1_1.value;
                        if (!(item && this.selectedItems.has(item === null || item === void 0 ? void 0 : item.UID.toString()))) {
                            result = false;
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (items_1_1 && !items_1_1.done && (_b = items_1.return)) _b.call(items_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            else {
                result = false;
            }
            return result;
        };
        PepListComponent.prototype.getNumberOfStartItems = function () {
            var numberOfStartItems = 20;
            if (this.screenSize === ngxLib.PepScreenSizeType.XL ||
                this.screenSize === ngxLib.PepScreenSizeType.LG) {
                numberOfStartItems = this.isTable ? 50 : 40;
            }
            else if (this.screenSize === ngxLib.PepScreenSizeType.MD) {
                numberOfStartItems = this.isTable ? 30 : 20;
            }
            else if (this.screenSize === ngxLib.PepScreenSizeType.SM) {
                numberOfStartItems = this.isTable ? 20 : 10;
            }
            else if (this.screenSize === ngxLib.PepScreenSizeType.XS) {
                numberOfStartItems = this.isTable ? 15 : 5;
            }
            return numberOfStartItems;
        };
        PepListComponent.prototype.setItemClicked = function (itemId, isSelectableForActions, itemType, isChecked) {
            var uniqItemId = this.getUniqItemId(itemId, itemType);
            // select the selected item.
            if (isChecked) {
                // Set seleted item
                this.selectedItemId = uniqItemId;
            }
            else {
                if (this.selectedItemId === uniqItemId) {
                    this.selectedItemId = '';
                }
            }
            if (this.selectionTypeForActions === 'single') {
                this.selectedItemsChange.emit(this.selectedItemId.length === 0 ? 0 : 1);
            }
            else if (this.selectionTypeForActions === 'multi') {
                if (isSelectableForActions) {
                    this.setSelectionItems(itemId, uniqItemId, isChecked);
                    var currentList = this.isAllSelected
                        ? this.unSelectedItems
                        : this.selectedItems;
                    var currentListCount = this.isAllSelected
                        ? this.totalRows - currentList.size
                        : currentList.size;
                    this.selectedItemsChange.emit(currentListCount);
                }
            }
            // Raise selected item change event
            if (this.selectionTypeForActions !== 'none') {
                this.selectedItemChange.emit({
                    id: itemId,
                    selected: isChecked,
                });
            }
        };
        PepListComponent.prototype.exportFunctionsOnHostElement = function () {
            // This is for web component usage for use those functions.
            this.hostElement.nativeElement.clear = this.clear.bind(this);
            this.hostElement.nativeElement.initListData = this.initListData.bind(this);
            this.hostElement.nativeElement.updateItems = this.updateItems.bind(this);
            this.hostElement.nativeElement.updatePage = this.updatePage.bind(this);
            this.hostElement.nativeElement.updateItem = this.updateItem.bind(this);
        };
        // getIsDisabled(item: ObjectsDataRow): boolean {
        //     return (
        //         this.lockItemInnerEvents || (item && !item.IsSelectableForActions)
        //     );
        // }
        PepListComponent.prototype.getIsAllSelectedForActions = function () {
            var e_2, _b;
            var _a;
            var res = false;
            if (this.isAllSelected) {
                if (this.unSelectedItems.size === 0) {
                    res = true;
                }
            }
            else {
                if ((_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.viewPortItems) {
                    if (this.selectedItems.size === this.totalRows) {
                        res = this.getIsAllSelected(this.virtualScroller.viewPortItems);
                    }
                    else if (this.selectedItems.size < this.totalRows) {
                        try {
                            for (var _c = __values(this.virtualScroller.viewPortItems), _d = _c.next(); !_d.done; _d = _c.next()) {
                                var item = _d.value;
                                res =
                                    item && this.selectedItems.has(item === null || item === void 0 ? void 0 : item.UID.toString());
                                if (!res) {
                                    break;
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_b = _c.return)) _b.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
            }
            return res;
        };
        PepListComponent.prototype.setIsAllSelected = function (isChecked) {
            if (this.selectionTypeForActions === 'multi') {
                this.selectAllCB.checked = isChecked;
                this.isAllSelected = isChecked;
            }
        };
        PepListComponent.prototype.selectAllItemsForActions = function (e) {
            // For material checkbox || radio.
            var isChecked = e.source.checked;
            // Indeterminate mode
            var isIndeterminate = false;
            var currentList = this.isAllSelected
                ? this.unSelectedItems
                : this.selectedItems;
            if (currentList.size > 0) {
                isIndeterminate = true;
                this.isAllSelected = false;
                this.selectedItemsChange.emit(0);
                e.source.checked = false;
            }
            this.selectedItems.clear();
            this.unSelectedItems.clear();
            if (!isIndeterminate) {
                this.isAllSelected = isChecked;
                this.selectAllClick.emit(isChecked);
                if (this.selectionTypeForActions === 'multi') {
                    if (!isChecked) {
                        this.selectedItemsChange.emit(0);
                        this.selectedItemId = '';
                    }
                    else {
                        var filteredItems = this.items.filter(function (item) { return item && item.IsSelectableForActions; });
                        this.selectedItemsChange.emit(filteredItems.length);
                    }
                }
            }
            else {
                // Remove all
                if (this.selectionTypeForActions === 'multi') {
                    this.selectAllClick.emit(false);
                }
            }
        };
        PepListComponent.prototype.raiseStartIndexChange = function (startIndex) {
            if (startIndex === void 0) { startIndex = 0; }
            // this.startIndex = startIndex;
            this.startIndexChange.emit({ startIndex: startIndex });
        };
        PepListComponent.prototype.getIsItemSelected = function (item) {
            var isSelected = false;
            if (item) {
                if (this.selectionTypeForActions === 'single') {
                    isSelected = this.selectedItemId === this.getUniqItemId(item.UID, item.Type.toString());
                }
                else if (this.selectionTypeForActions === 'multi') {
                    if (item.IsSelectableForActions) {
                        isSelected = (this.isAllSelected && !this.unSelectedItems.has(item.UID)) || this.selectedItems.has(item.UID);
                    }
                }
            }
            return isSelected;
        };
        PepListComponent.prototype.selectItemForActions = function (e, itemId, isSelectableForActions, itemType) {
            if (itemType === void 0) { itemType = ''; }
            // For material checkbox || radio.
            var isChecked = e.source.checked;
            this.setItemClicked(itemId, isSelectableForActions, itemType, isChecked);
        };
        PepListComponent.prototype.itemClicked = function (e, item) {
            // Set seleted item
            var itemId = item === null || item === void 0 ? void 0 : item.UID.toString();
            var itemType = item === null || item === void 0 ? void 0 : item.Type.toString();
            var isChecked = false;
            if (item && item.IsSelectableForActions) {
                this.selectedItemId = this.getUniqItemId(itemId, itemType);
                isChecked = true;
            }
            if (this.isTable) {
                if (this.selectionTypeForActions === 'single') {
                    this.setItemClicked(itemId, item.IsSelectableForActions, itemType, isChecked);
                }
                else if (this.selectionTypeForActions === 'none') {
                    // Just mark the row as highlighted
                    this.setItemClicked(itemId, item.IsSelectableForActions, itemType, true);
                }
            }
            else {
                if (this.disabled) {
                    return;
                }
            }
            this.itemClick.emit({ source: item, viewType: this.viewType });
        };
        PepListComponent.prototype.onTableRowMouseEnter = function (event, itemId, itemType) {
            if (!this.deviceHasMouse) {
                return;
            }
            var uniqItemId = this.getUniqItemId(itemId, itemType);
            this.hoveredItemId = uniqItemId;
        };
        PepListComponent.prototype.onTableRowMouseLeave = function (event, itemId, itemType) {
            this.hoveredItemId = '';
        };
        PepListComponent.prototype.onCardMouseEnter = function (event, itemId, itemType) {
            if (!this.deviceHasMouse) {
                return;
            }
            var uniqItemId = this.getUniqItemId(itemId, itemType);
            this.hoveredItemId = uniqItemId;
        };
        PepListComponent.prototype.onCardMouseLeave = function (event, itemId, itemType) {
            this.hoveredItemId = '';
        };
        // trackByFunc(index: number, item: ObjectsDataRow): any {
        //     return item && item?.UID ? item?.UID : index;
        //     // let res: string = "";
        //     // if (item && item?.UID) {
        //     //    res = item?.UID + "_" + this.listType + "_" + (this.isTable ? "Table" : "Thumbnails");
        //     // }
        //     // else {
        //     //    res = index + "_" + this.listType + "_" + (this.isTable ? "Table" : "Thumbnails");
        //     // }
        //     // return res;
        // }
        PepListComponent.prototype.clear = function () {
            this.cleanItems();
            this._layout = null;
        };
        PepListComponent.prototype.setSelectedIds = function (selectedIds, items) {
            var e_3, _b;
            if (items === void 0) { items = null; }
            var _a;
            this.selectedItems.clear();
            this.isAllSelected = false;
            if (selectedIds) {
                try {
                    // for (let i = 0; i < selected.length; i++) {
                    for (var selectedIds_1 = __values(selectedIds), selectedIds_1_1 = selectedIds_1.next(); !selectedIds_1_1.done; selectedIds_1_1 = selectedIds_1.next()) {
                        var selectedId = selectedIds_1_1.value;
                        var tmp = selectedId.split(this.SEPARATOR);
                        if (tmp && tmp.length > 0) {
                            var itemId = tmp[0];
                            var itemType = tmp.length > 1 ? tmp[1] : '';
                            this.selectedItems.set(itemId, this.getUniqItemId(itemId, itemType));
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (selectedIds_1_1 && !selectedIds_1_1.done && (_b = selectedIds_1.return)) _b.call(selectedIds_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
                this.isAllSelected = this.getIsAllSelected(items ? items : (_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.viewPortItems);
                this.setSelectionDataInSession();
            }
            this.refresh();
        };
        PepListComponent.prototype.setSelectionDataInSession = function () {
            if (this.selectedItems.size > 0) {
                this.sessionService.setObject(PepListComponent.SELECTED_ITEMS_STATE_KEY, JSON.stringify(__spreadArray([], __read(this.selectedItems))));
            }
            if (this.unSelectedItems.size > 0) {
                this.sessionService.setObject(PepListComponent.UN_SELECTED_ITEMS_STATE_KEY, JSON.stringify(__spreadArray([], __read(this.unSelectedItems))));
            }
            this.sessionService.setObject(PepListComponent.ALL_SELECTED_STATE_KEY, this.isAllSelected);
        };
        PepListComponent.prototype.initListData = function (layout, totalRows, items) {
            this.initVariablesFromSession(items);
            var currentList = this.isAllSelected
                ? this.unSelectedItems
                : this.selectedItems;
            var currentListCount = this.isAllSelected
                ? this.totalRows - currentList.size
                : currentList.size;
            this.selectedItemsChange.emit(currentListCount);
            this._layout = layout;
            this.selectedItemId = '';
            this.totalRows = totalRows;
            this.scrollToTop(false);
            this.cleanItems();
            if (items) {
                if (this.pagerType === 'pages') {
                    // If page index out of bounds - init to 0.
                    var numberOfPages = Math.ceil(totalRows / this.pageSize);
                    if (this.pageIndex >= numberOfPages) {
                        this.pageIndex = 0;
                    }
                    this.updatePage(items, {
                        pageIndex: this.pageIndex,
                        pageSize: this.pageSize,
                    });
                }
                else {
                    var numberOfStartItems = this.getNumberOfStartItems();
                    var event = {
                        fromIndex: 0,
                        toIndex: numberOfStartItems,
                    };
                    this.updateItems(items, event);
                    this.refresh();
                }
            }
            this.setLayout();
            this.onListLoad();
        };
        PepListComponent.prototype.updateItems = function (items, event) {
            if (event === void 0) { event = null; }
            var _a;
            if (!event) {
                return; // Event isn't supplied.
            }
            // Clean array
            if (this.itemsCounter + items.length > PepListComponent.TOP_ITEMS_ARRAY) {
                this.cleanItems();
            }
            var startIndex = (_a = event.fromIndex) !== null && _a !== void 0 ? _a : 0;
            for (var i = 0; i < items.length; i++) {
                if (!this.items[i + startIndex]) {
                    this.items[i + startIndex] = items[i];
                    this.itemsCounter += 1;
                }
            }
            this.toggleLoadingItemsFropApi(false);
        };
        PepListComponent.prototype.updatePage = function (items, event) {
            if (!event) {
                return; // Event isn't supplied.
            }
            // Clean array
            if (this.itemsCounter + items.length > PepListComponent.TOP_ITEMS_ARRAY) {
                this.cleanItems();
            }
            // const loadInChunks = this.itemsCounter === 0;
            var startIndex = Math.min(event.pageIndex * event.pageSize, this.totalRows);
            var endIndex = Math.min(startIndex + event.pageSize, this.totalRows);
            for (var i = 0; i < items.length; i++) {
                if (!this.items[i + startIndex]) {
                    this.items[i + startIndex] = items[i];
                    this.itemsCounter += 1;
                }
            }
            this.updateCurrentPageItems(startIndex, endIndex);
            this.toggleLoadingItemsFropApi(false);
        };
        PepListComponent.prototype.updateItem = function (data) {
            var index = this.items.findIndex(function (i) { return i && (i === null || i === void 0 ? void 0 : i.UID) === (data === null || data === void 0 ? void 0 : data.UID); });
            if (index >= 0 && index < this.items.length) {
                this.updateItemProperties(this.items[index], data);
            }
        };
        PepListComponent.prototype.scrollToIndex = function (index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback) {
            if (alignToBeginning === void 0) { alignToBeginning = true; }
            if (additionalOffset === void 0) { additionalOffset = 0; }
            if (animationMilliseconds === void 0) { animationMilliseconds = undefined; }
            if (animationCompletedCallback === void 0) { animationCompletedCallback = undefined; }
            var _a;
            (_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);
        };
        PepListComponent.prototype.updateItemProperties = function (itemToUpdate, data) {
            Object.assign(itemToUpdate, data);
        };
        PepListComponent.prototype.getSelectedItemsData = function (isForEdit) {
            var _this = this;
            if (isForEdit === void 0) { isForEdit = false; }
            var res = new PepSelectionData();
            if (this.selectionTypeForActions === 'single') {
                var tmp = this.selectedItemId.split(this.SEPARATOR);
                res.selectionType = 1;
                res.rows = [tmp[0]];
                res.rowTypes = [tmp[1]];
            }
            else if (this.selectionTypeForActions === 'multi') {
                var items_2 = [];
                var itemTypes_1 = [];
                var selectionType = 1;
                var currentList_1 = [];
                // For edit - only the selected items.
                if (isForEdit) {
                    if (!this.isAllSelected) {
                        currentList_1 = Array.from(this.selectedItems.values());
                    }
                    else {
                        // Get the id's of the items that not founded in unSelectedItems.
                        this.items.forEach(function (item) {
                            if (item &&
                                !_this.unSelectedItems.has(item === null || item === void 0 ? void 0 : item.UID.toString())) {
                                currentList_1.push(_this.getUniqItemId(item === null || item === void 0 ? void 0 : item.UID.toString(), item === null || item === void 0 ? void 0 : item.Type.toString()));
                            }
                        });
                    }
                }
                else {
                    // For delete - can be the unselected with select_all functionality.
                    currentList_1 = Array.from(this.isAllSelected
                        ? this.unSelectedItems.values()
                        : this.selectedItems.values());
                    selectionType = this.isAllSelected ? 0 : 1;
                }
                currentList_1.forEach(function (item) {
                    var tmp = item.split(_this.SEPARATOR);
                    if (tmp.length === 2) {
                        items_2.push(tmp[0]);
                        itemTypes_1.push(tmp[1]);
                    }
                });
                res.selectionType = selectionType;
                res.rows = items_2;
                res.rowTypes = itemTypes_1;
            }
            return res;
        };
        PepListComponent.prototype.getIsItemEditable = function (uid) {
            var item = this.items.filter(function (x) { return (x === null || x === void 0 ? void 0 : x.UID.toString()) === uid; });
            if (item.length > 0) {
                return item[0].IsEditable;
            }
            else {
                return false;
            }
        };
        PepListComponent.prototype.getItemDataByID = function (uid) {
            return this.items.find(function (item) { return (item === null || item === void 0 ? void 0 : item.UID.toString()) === uid; });
        };
        PepListComponent.prototype.refresh = function () {
            var _a;
            (_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.refresh();
        };
        // ---------------------------------------------------------------
        //              Events handlers.
        // ---------------------------------------------------------------
        PepListComponent.prototype.onWinResize = function (e) {
            this.refresh();
            this.containerWidth = 0;
            this.setLayout();
        };
        PepListComponent.prototype.onListResizeStart = function (event, columnKey) {
            var _a;
            this.pressedColumn = columnKey;
            this.startX = event.x;
            this.startWidth = event.target.closest('.header-column').offsetWidth;
            this.tableStartWidth = (_a = this.virtualScroller) === null || _a === void 0 ? void 0 : _a.contentElementRef.nativeElement.offsetWidth;
        };
        PepListComponent.prototype.onListResize = function (event) {
            if (this.pressedColumn.length > 0) {
                var widthToAdd = this.layoutService.isRtl() ? this.startX - event.x : event.x - this.startX;
                // Set the width of the column and the container of the whole columns.
                if (this.startWidth + widthToAdd >= PepListComponent.MINIMUM_COLUMN_WIDTH || widthToAdd > 0) {
                    var length = this._layout.ControlFields.length;
                    var totalCalcColsWidth = 0;
                    for (var index = 0; index < length; index++) {
                        var uiControlField = this._layout
                            .ControlFields[index];
                        if (index === length - 1) {
                            // Calc the last column only in percentage type.
                            if (this.hasColumnWidthOfTypePercentage) {
                                var scrollWidth = this.layoutService.getScrollbarWidth();
                                widthToAdd += scrollWidth;
                                uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString = 'calc(100% - ' + (totalCalcColsWidth + scrollWidth) + 'px)'; // For 100%
                            }
                            else {
                                if (uiControlField.ApiName === this.pressedColumn) {
                                    uiControlField.calcColumnWidth = this.startWidth + widthToAdd;
                                    uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidth + 'px';
                                    uiControlField.calcColumnWidthString = uiControlField.calcColumnWidth + 'px';
                                }
                            }
                        }
                        else if (uiControlField.ApiName === this.pressedColumn) {
                            uiControlField.calcColumnWidth = this.startWidth + widthToAdd;
                            uiControlField.calcTitleColumnWidthString = uiControlField.calcColumnWidthString = uiControlField.calcColumnWidth + 'px';
                        }
                        totalCalcColsWidth += uiControlField.calcColumnWidth;
                    }
                    this.renderer.setStyle(this.hostElement.nativeElement, 'width', this.tableStartWidth + widthToAdd + 'px');
                }
                this.checkForChanges = new Date().getTime();
            }
        };
        PepListComponent.prototype.onListResizeEnd = function (event) {
            var _this = this;
            if (this.pressedColumn.length > 0) {
                if (event &&
                    this.getParent(event.srcElement, 'resize-box').length > 0) {
                    this.initResizeData();
                }
                else {
                    // Set timeout 0 for onListSortingChange will have the pressedColumn.
                    setTimeout(function () {
                        _this.initResizeData();
                    }, 0);
                }
                event.stopPropagation();
            }
        };
        PepListComponent.prototype.onListSortingChange = function (sortBy, isAsc, event) {
            if (event === void 0) { event = null; }
            if (this.pressedColumn.length > 0 ||
                (event && this.getParent(event.srcElement, 'resize-box').length > 0)) {
                return;
            }
            if (this.sortBy !== sortBy || this.isAsc !== isAsc) {
                this.sortBy = sortBy;
                this.isAsc = isAsc;
                this.saveSortingToSession();
                this.sortingChange.emit({ sortBy: sortBy, isAsc: isAsc });
            }
        };
        PepListComponent.prototype.onListHeaderMouseEnter = function (event) {
            // this.headerIsInFocus = true;
        };
        PepListComponent.prototype.onListHeaderMouseLeave = function (event) {
            // this.headerIsInFocus = false;
            this.onListResizeEnd(event);
            this.initResizeData();
        };
        PepListComponent.prototype.onPagerChange = function (event) {
            var _this = this;
            this.pageIndex = event.pageIndex;
            // Scroll to top.
            this.scrollToTop();
            var startIndex = event.pageIndex * event.pageSize;
            var endIndex = Math.min(startIndex + event.pageSize, this.totalRows);
            var shouldGetItemsFromApi = false;
            var index = startIndex;
            while (!shouldGetItemsFromApi && index < endIndex) {
                if (!this.items[index]) {
                    shouldGetItemsFromApi = true;
                }
                index++;
            }
            // Get bulk from api.
            if (shouldGetItemsFromApi) {
                if (!this.loadingItemsFromApi) {
                    this.toggleLoadingItemsFropApi(true);
                    this.loadPage.emit({
                        pageIndex: event.pageIndex,
                        pageSize: event.pageSize,
                    });
                }
            }
            else {
                setTimeout(function () {
                    _this.updateCurrentPageItems(startIndex, endIndex);
                }, this.scrollAnimationTime);
            }
        };
        PepListComponent.prototype.onVirtualScrollerChange = function (event) {
            this.raiseStartIndexChange(event.startIndex);
            if (this.pagerType === 'scroll') {
                // For other events do nothing.
                if (typeof event.startIndex === 'undefined' || event.startIndex < 0 ||
                    typeof event.endIndex === 'undefined' || event.endIndex < 0) {
                    return;
                }
                var addAtStart = event.scrollDirection === 'backward';
                var shouldGetItemsFromApi = false;
                var indexOfMissingItem = void 0;
                if (addAtStart) {
                    indexOfMissingItem = event.endIndex;
                    while (!shouldGetItemsFromApi && indexOfMissingItem >= event.startIndex) {
                        if (!this.items[indexOfMissingItem]) {
                            shouldGetItemsFromApi = true;
                        }
                        if (!shouldGetItemsFromApi) {
                            indexOfMissingItem--;
                        }
                    }
                }
                else {
                    indexOfMissingItem = event.startIndex;
                    while (!shouldGetItemsFromApi && indexOfMissingItem <= event.endIndex) {
                        if (!this.items[indexOfMissingItem]) {
                            shouldGetItemsFromApi = true;
                        }
                        if (!shouldGetItemsFromApi) {
                            indexOfMissingItem++;
                        }
                    }
                }
                // Get bulk from api.
                if (shouldGetItemsFromApi) {
                    if (!this.loadingItemsFromApi) {
                        this.toggleLoadingItemsFropApi(true);
                        var top = this.getTopItems() - 1;
                        var fromIndex = addAtStart ? Math.max(indexOfMissingItem - top, 0) : indexOfMissingItem;
                        var toIndex = addAtStart ? indexOfMissingItem : Math.min(indexOfMissingItem + top, this.totalRows);
                        this.loadItems.emit({
                            fromIndex: fromIndex,
                            toIndex: toIndex,
                        });
                    }
                }
            }
        };
        PepListComponent.prototype.onListLoad = function () {
            var _this = this;
            setTimeout(function () {
                _this.listLoad.emit();
            }, 0);
        };
        PepListComponent.prototype.onChildRectChange = function (event) {
            var _this = this;
            setTimeout(function () {
                _this.calculatedObjectHeight = (event === null || event === void 0 ? void 0 : event.height) + 'px';
            }, 0);
        };
        PepListComponent.prototype.onValueChanged = function (valueChange) {
            if (this.disabled) {
                return;
            }
            this.valueChange.emit(valueChange);
        };
        PepListComponent.prototype.onCustomizeFieldClick = function (customizeFieldClickedData) {
            if (this.disabled) {
                return;
            }
            this.fieldClick.emit(customizeFieldClickedData);
        };
        return PepListComponent;
    }());
    PepListComponent.TOP_ITEMS_DEFAULT = 100;
    PepListComponent.TOP_ITEMS_TABLE = 100;
    PepListComponent.TOP_ITEMS_THUMBNAILS = 100;
    PepListComponent.TOP_ITEMS_ARRAY = 2500;
    PepListComponent.SELECTED_ITEMS_STATE_KEY = 'SelectedItems';
    PepListComponent.UN_SELECTED_ITEMS_STATE_KEY = 'UnSelectedItems';
    PepListComponent.ALL_SELECTED_STATE_KEY = 'AllSelected';
    PepListComponent.SORT_BY_STATE_KEY = 'SortBy';
    PepListComponent.ASCENDING_STATE_KEY = 'IsAscending';
    PepListComponent.MINIMUM_COLUMN_WIDTH = 48;
    PepListComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list',
                    template: "<ng-container *ngIf=\"totalRows == 0\">\n    <ng-container *ngIf=\"noDataFoundMsg; then noDataMsgInputBlock; else noDataMsgDefaultBlock\"></ng-container>\n    <ng-template #noDataMsgInputBlock>\n        <div class=\"pep-border-bottom\">\n            <p class=\"title-xl no-data\">\n                {{ noDataFoundMsg }}\n            </p>\n        </div>\n    </ng-template>\n    <ng-template #noDataMsgDefaultBlock>\n        <div class=\"pep-border-bottom\">\n            <p class=\"title-xl no-data\">\n                {{ 'LIST.NO_DATA_FOUND' | translate}}\n            </p>\n        </div>\n        <div class=\"no-data-suggestions\">\n            <p class=\"suggestions-title title-lg\">\n                {{ 'LIST.NO_DATA_FOUND_SUGGESTIONS_TITLE' | translate}}\n            </p>\n            <ul class=\"suggestions-list body-lg\" [innerHtml]=\"'LIST.NO_DATA_FOUND_SUGGESTIONS_LIST' | translate\"></ul>\n        </div>\n    </ng-template>\n</ng-container>\n<ng-container *ngIf=\"totalRows > 0\">\n    <ng-container *ngTemplateOutlet=\"tableHeader\"></ng-container>\n\n    <virtual-scroller #scroller [items]=\"pagerType === 'pages' ? currentPageItems : items\"\n        [scrollDebounceTime]=\"scrollDebounceTime\" [scrollThrottlingTime]=\"scrollThrottlingTime\"\n        [bufferAmount]=\"printMode ? totalRows : -1\" [parentScroll]=\"parentScroll\" [disable]=\"loadingItemsFromApi\"\n        class=\"virtual-scroller\" [ngClass]=\"{ 'table-body': isTable, 'cards-body': !isTable }\"\n        (vsChange)=\"onVirtualScrollerChange($event)\" (vsChildRectChange)=\"onChildRectChange($event)\">\n        <ng-container *ngFor=\"let item of scroller.viewPortItems; let index; let isFirst = first;\">\n            <ng-container *ngTemplateOutlet=\"listData; context: {item: item}\"></ng-container>\n        </ng-container>\n    </virtual-scroller>\n\n    <pep-list-pager *ngIf=\"pagerType === 'pages'\" class=\" list-pager\" [disabled]=\"loadingItemsFromApi\"\n        [length]=\"totalRows\" [pageSize]=\"pageSize\" [pageIndex]=\"pageIndex\" (pagerChange)=\"onPagerChange($event)\">\n    </pep-list-pager>\n\n    <ng-container *ngTemplateOutlet=\"tableTotal\"></ng-container>\n</ng-container>\n\n<ng-template #listData let-item=\"item\">\n    <ng-container *ngIf=\"isTable\">\n        <!-- getIsItemSelected(item) -> item | isItemSelected: selectionTypeForActions : selectedItemId : isAllSelected : selectedItems : unSelectedItems -->\n        <div class=\"table-row\" (mouseenter)=\"onTableRowMouseEnter($event, item?.UID, item?.Type)\"\n            (mouseleave)=\"onTableRowMouseLeave($event, item?.UID, item?.Type)\" [ngClass]=\"{\n                    selected: getIsItemSelected(item),\n                    highlighted: item?.UID + SEPARATOR + item?.Type === selectedItemId\n                }\" [ngStyle]=\"{ visibility: !loadingItemsFromApi || item ? 'visible' : 'hidden' }\">\n            <fieldset class=\"table-row-fieldset\" [ngStyle]=\"{ 'background-color': item?.BackgroundColor }\">\n                <mat-checkbox *ngIf=\"selectionTypeForActions == 'multi'\" type=\"checkbox\"\n                    class=\"pull-left flip row-selection\"\n                    [disabled]=\"item | isItemDisabled: lockItemInnerEvents : printMode\" [ngStyle]=\"{\n                            visibility: !deviceHasMouse ||\n                            item?.UID + SEPARATOR + item?.Type === hoveredItemId || isAllSelected || selectedItems.size > 0 ? 'visible' : 'hidden'\n                        }\" [checked]=\"getIsItemSelected(item)\"\n                    (change)=\"selectItemForActions($event, item?.UID, item?.IsSelectableForActions, item?.Type)\">\n                </mat-checkbox>\n                <mat-radio-button *ngIf=\"selectionTypeForActions == 'single'\" name=\"selection\"\n                    class=\"pull-left flip row-selection pep-radio-button\"\n                    [disabled]=\"item | isItemDisabled: lockItemInnerEvents : printMode\"\n                    [checked]=\"getIsItemSelected(item)\"\n                    (change)=\"selectItemForActions($event, item?.UID, item?.IsSelectableForActions, item?.Type)\">\n                </mat-radio-button>\n                <pep-form [layoutType]=\"'table'\" [checkForChanges]=\"checkForChanges\" [layout]=\"layout\"\n                    [firstFieldAsLink]=\"firstFieldAsLink\" [data]=\"item\" [canEditObject]=\"!disabled\"\n                    [lockEvents]=\"lockItemInnerEvents || printMode\" [isReport]=\"isReport\" [isActive]=\"\n                            (item?.UID + SEPARATOR + item?.Type === selectedItemId ||\n                            item?.UID + SEPARATOR + item?.Type === hoveredItemId) && deviceHasMouse\n                        \" (valueChange)=\"onValueChanged($event)\" (fieldClick)=\"onCustomizeFieldClick($event)\"\n                    (click)=\"itemClicked($event, item)\">\n                </pep-form>\n            </fieldset>\n        </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"!isTable\">\n        <div (mouseenter)=\"onCardMouseEnter($event, item?.UID, item?.Type)\"\n            (mouseleave)=\"onCardMouseLeave($event, item?.UID, item?.Type)\" [ngClass]=\"{\n                    selected: getIsItemSelected(item),\n                    highlighted: item?.UID + SEPARATOR + item?.Type === selectedItemId,\n                    'line-view': viewType === 'lines',\n                    'card-view': viewType === 'cards',\n                    'small-card': cardSize === 'sm'\n                }\" class=\"pull-left flip\"\n            [ngStyle]=\"{ height: calculatedObjectHeight, visibility: !loadingItemsFromApi || item ? 'visible' : 'hidden' }\">\n            <mat-checkbox *ngIf=\"showCardSelection\" class=\"pull-left flip card-selection\"\n                [disabled]=\"item | isItemDisabled: lockItemInnerEvents : printMode\" [checked]=\"getIsItemSelected(item)\"\n                (change)=\"selectItemForActions($event, item?.UID, item?.IsSelectableForActions, item?.Type)\">\n            </mat-checkbox>\n            <pep-form [layoutType]=\"'card'\" [firstFieldAsLink]=\"firstFieldAsLink\" [checkForChanges]=\"checkForChanges\"\n                [layout]=\"layout\" [data]=\"item\" [canEditObject]=\"!disabled\"\n                [lockEvents]=\"lockItemInnerEvents || printMode\" [isActive]=\"\n                        (item?.UID + SEPARATOR + item?.Type === selectedItemId ||\n                        item?.UID + SEPARATOR + item?.Type === hoveredItemId) && deviceHasMouse\n                    \" (valueChange)=\"onValueChanged($event)\" (fieldClick)=\"onCustomizeFieldClick($event)\"\n                (click)=\"itemClicked($event, item)\">\n            </pep-form>\n        </div>\n    </ng-container>\n</ng-template>\n\n<ng-template #tableHeader>\n    <div *ngIf=\"isTable\" class=\"table-header\" (mouseup)=\"onListResizeEnd($event)\"\n        (mouseenter)=\"onListHeaderMouseEnter($event)\" (mouseleave)=\"onListHeaderMouseLeave($event)\"\n        (mousemove)=\"onListResize($event)\">\n\n        <div class=\"table-header-padding-top\"></div>\n        <fieldset class=\"table-header-fieldset\">\n            <mat-checkbox *ngIf=\"selectionTypeForActions !== 'none'\" #selectAllCB class=\"pull-left flip row-selection\"\n                type=\"checkbox\" [ngStyle]=\"{\n                        visibility:\n                            selectionTypeForActions == 'single' || \n                            (selectionTypeForActions == 'multi' && hideAllSelectionInMulti) ? 'hidden' : 'visible'\n                    }\"\n                [indeterminate]=\"isAllSelected ? unSelectedItems.size > 0 && unSelectedItems.size < totalRows : (selectedItems.size > 0 && !getIsAllSelectedForActions())\"\n                [disabled]=\"disabled || selectionTypeForActions === 'single'\" [checked]=\"getIsAllSelectedForActions()\"\n                (change)=\"selectAllItemsForActions($event)\"></mat-checkbox>\n            <fieldset>\n                <div *ngFor=\"let field of layout?.ControlFields; let j = index\" class=\"header-column pull-left flip\"\n                    [ngStyle]=\"{ width: field.calcTitleColumnWidthString }\" [ngClass]=\"{\n                            'support-sorting': supportSorting,\n                            'has-sorting': field.ApiName === sortBy,\n                            'is-resizing': field.ApiName === pressedColumn,\n                            'is-first': j === 0 && selectionTypeForActions !== 'multi',\n                            'is-last': j === layout?.ControlFields?.length - 1\n                        }\"\n                    (click)=\"supportSorting ? (onListSortingChange(field.ApiName, sortBy !== null && sortBy != field.ApiName ? true : !isAsc, $event)) : false\">\n\n                    <label id=\"{{ field.ApiName }}\"\n                        class=\"header-label body-sm pull-left flip text-align-{{ field.Layout.XAlignment }}\"\n                        title=\"{{ field.Title }}\">\n                        <span *ngIf=\"field.Mandatory\" class=\"mandatory\">\n                            <pep-icon name=\"system_must\"></pep-icon>\n                        </span>\n                        {{ field.Title != '' ? field.Title : ' '}}\n                    </label>\n\n                    <div *ngIf=\"supportResizing\" class=\"resize-box pull-right flip\"\n                        (mousedown)=\"onListResizeStart($event, field.ApiName)\">\n                        <div class=\"splitter\"></div>\n                    </div>\n\n                    <div *ngIf=\"supportSorting\" class=\"sorting-box pull-left flip\"\n                        [ngClass]=\"{ 'has-sorting': field.ApiName === sortBy }\">\n                        <mat-icon *ngIf=\"field.ApiName !== sortBy\">\n                            <pep-icon name=\"arrow_either\" class=\"asc\"></pep-icon>\n                        </mat-icon>\n                        <ng-container *ngIf=\"field.ApiName === sortBy\">\n                            <mat-icon *ngIf=\"!isAsc\" [ngClass]=\"{ 'sort-by': field.ApiName === sortBy && isAsc }\"\n                                title=\"{{ 'LIST.SORT_ASC' | translate }}\">\n                                <pep-icon name=\"arrow_up\" class=\"asc\"></pep-icon>\n                            </mat-icon>\n                            <mat-icon *ngIf=\"isAsc\" [ngClass]=\"{ 'sort-by': field.ApiName === sortBy && !isAsc }\"\n                                title=\"{{ 'LIST.SORT_DESC' | translate }}\">\n                                <pep-icon name=\"arrow_down\" class=\"desc\"></pep-icon>\n                            </mat-icon>\n                        </ng-container>\n                    </div>\n                </div>\n            </fieldset>\n        </fieldset>\n    </div>\n</ng-template>\n\n<ng-template #tableTotal>\n    <div *ngIf=\"isTable && totalsRow?.length > 0 && totalsRow.length <= layout?.ControlFields.length\"\n        class=\"table-total\">\n        <fieldset class=\"table-header-fieldset\">\n            <div *ngFor=\"let field of layout?.ControlFields; let j = index\" class=\"total-column pull-left flip\"\n                [ngStyle]=\"{ width: field.calcTitleColumnWidthString }\">\n                <label class=\"total-label body-sm text-align-{{ field.Layout.XAlignment }}\">\n                    {{ totalsRow[j] }}\n                </label>\n            </div>\n        </fieldset>\n    </div>\n</ng-template>",
                    host: {
                        '(window:resize)': 'onWinResize($event)',
                    },
                    styles: [":host{height:inherit;display:flex;flex-direction:column}.no-data{margin:2rem 0;margin:var(--pep-spacing-2xl,2rem) 0}.no-data-suggestions .suggestions-title{margin:1rem 0 .5rem;margin:var(--pep-spacing-lg,1rem) 0 var(--pep-spacing-sm,.5rem)}.no-data-suggestions .suggestions-list{margin:0;padding:0;-webkit-padding-start:2rem;padding-inline-start:2rem;-webkit-padding-start:var(--pep-spacing-2xl,2rem);padding-inline-start:var(--pep-spacing-2xl,2rem)}.virtual-scroller{min-height:5rem;height:inherit}"]
                },] }
    ];
    PepListComponent.ctorParameters = function () { return [
        { type: core.ElementRef },
        { type: ngxLib.PepLayoutService },
        { type: ngxLib.PepSessionService },
        { type: core.ChangeDetectorRef },
        { type: core.Renderer2 },
        { type: core.NgZone }
    ]; };
    PepListComponent.propDecorators = {
        noDataFoundMsg: [{ type: core.Input }],
        selectionTypeForActions: [{ type: core.Input }],
        showCardSelection: [{ type: core.Input }],
        hideAllSelectionInMulti: [{ type: core.Input }],
        cardSize: [{ type: core.Input }],
        viewType: [{ type: core.Input }],
        firstFieldAsLink: [{ type: core.Input }],
        supportSorting: [{ type: core.Input }],
        supportResizing: [{ type: core.Input }],
        parentScroll: [{ type: core.Input }],
        disabled: [{ type: core.Input }],
        lockEvents: [{ type: core.Input }],
        lockItemInnerEvents: [{ type: core.Input }],
        printMode: [{ type: core.Input }],
        isReport: [{ type: core.Input }],
        totalsRow: [{ type: core.Input }],
        pagerType: [{ type: core.Input }],
        pageSize: [{ type: core.Input }],
        pageIndex: [{ type: core.Input }],
        scrollAnimationTime: [{ type: core.Input }],
        scrollDebounceTime: [{ type: core.Input }],
        scrollThrottlingTime: [{ type: core.Input }],
        useAsWebComponent: [{ type: core.Input }],
        itemClick: [{ type: core.Output }],
        fieldClick: [{ type: core.Output }],
        valueChange: [{ type: core.Output }],
        sortingChange: [{ type: core.Output }],
        selectedItemsChange: [{ type: core.Output }],
        selectedItemChange: [{ type: core.Output }],
        selectAllClick: [{ type: core.Output }],
        listLoad: [{ type: core.Output }],
        loadItems: [{ type: core.Output }],
        loadPage: [{ type: core.Output }],
        startIndexChange: [{ type: core.Output }],
        virtualScroller: [{ type: core.ViewChild, args: [VirtualScrollerComponent,] }],
        selectAllCB: [{ type: core.ViewChild, args: ['selectAllCB',] }]
    };

    var PepListActionsComponent = /** @class */ (function () {
        function PepListActionsComponent() {
            this.actions = null;
            this.sizeType = 'md';
            this.xPosition = 'before';
            this.hidden = false;
            this.actionClick = new core.EventEmitter();
            this.stateChange = new core.EventEmitter();
            this.menuClick = new core.EventEmitter();
        }
        PepListActionsComponent.prototype.onActionClicked = function (action) {
            this.actionClick.emit(action);
        };
        PepListActionsComponent.prototype.onStateChanged = function (menuStateChangeEvent) {
            this.stateChange.emit(menuStateChangeEvent);
        };
        return PepListActionsComponent;
    }());
    PepListActionsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-actions',
                    template: "<pep-menu [xPosition]=\"xPosition\" [styleType]=\"'strong'\" [sizeType]=\"sizeType\" [items]=\"!hidden ? actions : null\"\n    [hideOnEmptyItems]=\"true\" [iconName]=\"'system_edit'\" (menuItemClick)=\"onActionClicked($event)\"\n    (stateChange)=\"onStateChanged($event)\" (menuClick)=\"menuClick.emit();\">\n</pep-menu>\n",
                    styles: [""]
                },] },
        { type: core.Injectable }
    ];
    PepListActionsComponent.propDecorators = {
        actions: [{ type: core.Input }],
        sizeType: [{ type: core.Input }],
        xPosition: [{ type: core.Input }],
        hidden: [{ type: core.Input }],
        actionClick: [{ type: core.Output }],
        stateChange: [{ type: core.Output }],
        menuClick: [{ type: core.Output }]
    };

    var PepListCarouselComponent = /** @class */ (function () {
        // deviceHasMouse = false;
        function PepListCarouselComponent(layoutService) {
            this.layoutService = layoutService;
            this.duration = 1000;
            this.layout = null;
            this.itemsToMove = 3;
            this.lockItemInnerEvents = true;
            this.hideArrowsInSmallScreen = true;
            this._items = null;
            this._itemSize = 'xs';
            this.itemClick = new core.EventEmitter();
            this.prevDisabled = false;
            this.nextDisabled = false;
            this.PepScreenSizeType = ngxLib.PepScreenSizeType;
            // this.deviceHasMouse = this.layoutService.getDeviceHasMouse();
        }
        Object.defineProperty(PepListCarouselComponent.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (value) {
                this._items = value;
                this.moveTo(0);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListCarouselComponent.prototype, "itemSize", {
            get: function () {
                return this._itemSize;
            },
            set: function (value) {
                this._itemSize = value;
                this.moveTo(0);
            },
            enumerable: false,
            configurable: true
        });
        PepListCarouselComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            this.layoutService.onResize$.subscribe(function (size) {
                _this.screenSize = size;
            });
            // this.layoutService.onMouseOver$.subscribe((deviceHasMouse: boolean) => {
            //     this.deviceHasMouse = deviceHasMouse;
            // });
        };
        PepListCarouselComponent.prototype.ngOnDestroy = function () {
            // if (this.itemClick) {
            //     this.itemClick.unsubscribe();
            // }
        };
        PepListCarouselComponent.prototype.itemClicked = function (item) {
            this.itemClick.emit({ source: item });
        };
        PepListCarouselComponent.prototype.moveLeft = function () {
            // this.carousel.moveLeft();
            var indexToMove = Math.max(this.carousel.currIndex - this.itemsToMove, 0);
            this.moveTo(indexToMove);
        };
        PepListCarouselComponent.prototype.moveRight = function () {
            // this.carousel.moveRight();
            var indexToMove = Math.min(this.carousel.currIndex + this.itemsToMove, this.items.length);
            this.moveTo(indexToMove);
        };
        PepListCarouselComponent.prototype.moveTo = function (index) {
            if (this.carousel) {
                this.carousel.moveTo(index);
            }
        };
        PepListCarouselComponent.prototype.onReachesLeftBound = function (event) {
            this.prevDisabled = event;
        };
        PepListCarouselComponent.prototype.onReachesRightBound = function (event) {
            this.nextDisabled = event;
        };
        return PepListCarouselComponent;
    }());
    PepListCarouselComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-carousel',
                    template: "<div class=\"carousel-container\">\n    <ng-container *ngIf=\"items?.length > 0; then carouselBlock; else emptyBlock\"></ng-container>\n    <ng-template #emptyBlock>\n        <!-- No items -->\n    </ng-template>\n    <ng-template #carouselBlock>\n        <pep-button *ngIf=\"!(hideArrowsInSmallScreen && screenSize > PepScreenSizeType.SM)\"\n            [iconName]=\"'arrow_left_alt'\" [styleType]=\"'regular'\" [disabled]=\"prevDisabled\" (click)=\"moveLeft()\"\n            class=\"carousel-arrow start-arrow\">\n        </pep-button>\n        <pep-carousel #carousel [xWheelEnabled]=\"false\" [snapDuration]=\"duration\"\n            (reachesLeftBound)=\"onReachesLeftBound($event)\" (reachesRightBound)=\"onReachesRightBound($event)\">\n            <ng-container *ngFor=\"let item of items\">\n                <pep-form pepCarouselItem [layout]=\"layout\" [data]=\"item\" [layoutType]=\"'card'\"\n                    (click)=\"itemClicked(item)\" class=\"card-view \" [lockEvents]=\"lockItemInnerEvents\"\n                    [ngClass]=\"{ 'x-small-card': itemSize === 'xs', 'small-card': itemSize === 'sm'}\">\n                </pep-form>\n            </ng-container>\n        </pep-carousel>\n        <pep-button *ngIf=\"!(hideArrowsInSmallScreen && screenSize > PepScreenSizeType.SM)\"\n            [iconName]=\"'arrow_right_alt'\" [styleType]=\"'regular'\" [disabled]=\"nextDisabled\" (click)=\"moveRight()\"\n            class=\"carousel-arrow end-arrow\">\n        </pep-button>\n    </ng-template>\n</div>",
                    styles: [".carousel-container{position:relative;margin:0 calc(.5rem * -1);margin:0 calc(var(--pep-spacing-sm, .5rem) * -1);display:grid}.carousel-container .carousel-arrow{position:absolute;top:50%;transform:translateY(-50%);z-index:1}.carousel-container .carousel-arrow.start-arrow{left:0}.carousel-container .carousel-arrow.end-arrow{right:0}.carousel-container ::ng-deep.carousel-content .card-view{padding:.5rem 0!important;padding:var(--pep-spacing-sm,.5rem) 0!important}.carousel-container ::ng-deep.carousel-content .card-view:first-child{-webkit-padding-start:.5rem!important;padding-inline-start:.5rem!important;-webkit-padding-start:var(--pep-spacing-sm,.5rem)!important;padding-inline-start:var(--pep-spacing-sm,.5rem)!important}.carousel-container ::ng-deep.carousel-content .card-view:last-child{-webkit-padding-end:.5rem!important;padding-inline-end:.5rem!important;-webkit-padding-end:var(--pep-spacing-sm,.5rem)!important;padding-inline-end:var(--pep-spacing-sm,.5rem)!important}"]
                },] },
        { type: core.Injectable }
    ];
    PepListCarouselComponent.ctorParameters = function () { return [
        { type: ngxLib.PepLayoutService }
    ]; };
    PepListCarouselComponent.propDecorators = {
        duration: [{ type: core.Input }],
        layout: [{ type: core.Input }],
        itemsToMove: [{ type: core.Input }],
        lockItemInnerEvents: [{ type: core.Input }],
        hideArrowsInSmallScreen: [{ type: core.Input }],
        items: [{ type: core.Input }],
        itemSize: [{ type: core.Input }],
        itemClick: [{ type: core.Output }],
        carousel: [{ type: core.ViewChild, args: ['carousel', { read: carousel.PepCarouselComponent },] }]
    };

    var IPepListChooserOption = /** @class */ (function () {
        function IPepListChooserOption() {
        }
        return IPepListChooserOption;
    }());
    var PepListChooserComponent = /** @class */ (function () {
        function PepListChooserComponent() {
            this._options = null;
            this._currentList = null;
            this.sizeType = 'md';
            this.change = new core.EventEmitter();
            this.breadCrumbsItems = null;
            this.menuItems = null;
            this.currentItem = null;
        }
        Object.defineProperty(PepListChooserComponent.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                var _a;
                this._options = value;
                this.menuItems = value.map(function (opt) {
                    return { key: opt.key, text: opt.text };
                });
                if (((_a = this.menuItems) === null || _a === void 0 ? void 0 : _a.length) === 1) {
                    this.breadCrumbsItems = [];
                    this.breadCrumbsItems.push(new breadCrumbs.PepBreadCrumbItem({
                        key: this.menuItems[0].key,
                        text: this.menuItems[0].text,
                    }));
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListChooserComponent.prototype, "currentList", {
            get: function () {
                return this._currentList;
            },
            set: function (value) {
                this._currentList = value;
                this.currentItem = this.menuItems.find(function (mi) { return mi.key === value.key; });
            },
            enumerable: false,
            configurable: true
        });
        PepListChooserComponent.prototype.onMenuItemClicked = function (menuItemClickEvent) {
            this.currentList = this.options.find(function (list) { return list.key === menuItemClickEvent.source.key; });
            this.change.emit({ source: this.currentList });
        };
        return PepListChooserComponent;
    }());
    PepListChooserComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-chooser',
                    template: "<ng-container *ngIf=\"menuItems?.length > 1\">\n    <pep-menu [type]=\"'select'\" [sizeType]=\"sizeType\" [items]=\"menuItems\" [selectedItem]=\"currentItem\"\n        [iconName]=\"'arrow_down'\" (menuItemClick)=\"onMenuItemClicked($event)\"></pep-menu>\n</ng-container>\n<ng-container *ngIf=\"menuItems?.length == 1\">\n    <pep-bread-crumbs [items]=\"breadCrumbsItems\" [addSpacing]=\"true\"></pep-bread-crumbs>\n</ng-container>",
                    styles: [""]
                },] },
        { type: core.Injectable }
    ];
    PepListChooserComponent.propDecorators = {
        options: [{ type: core.Input }],
        currentList: [{ type: core.Input }],
        sizeType: [{ type: core.Input }],
        change: [{ type: core.Output }]
    };

    var IPepListPagerChangeEvent = /** @class */ (function () {
        function IPepListPagerChangeEvent() {
        }
        return IPepListPagerChangeEvent;
    }());
    var PepListPagerComponent = /** @class */ (function () {
        function PepListPagerComponent(_changeDetectorRef, layoutService) {
            this._changeDetectorRef = _changeDetectorRef;
            this.layoutService = layoutService;
            this.disabled = false;
            this._pageIndex = 0;
            this.length = 0;
            this.pageSize = DEFAULT_PAGE_SIZE;
            this.pagerChange = new core.EventEmitter();
        }
        Object.defineProperty(PepListPagerComponent.prototype, "pageIndex", {
            get: function () {
                return this._pageIndex;
            },
            set: function (value) {
                this.setPageIndex(value);
            },
            enumerable: false,
            configurable: true
        });
        PepListPagerComponent.prototype.nextPage = function () {
            if (!this.hasNextPage()) {
                return;
            }
            this.setPageIndex(this.pageIndex + 1);
        };
        PepListPagerComponent.prototype.previousPage = function () {
            if (!this.hasPreviousPage()) {
                return;
            }
            this.setPageIndex(this.pageIndex - 1);
        };
        PepListPagerComponent.prototype.firstPage = function () {
            if (!this.hasPreviousPage()) {
                return;
            }
            this.setPageIndex(0);
        };
        PepListPagerComponent.prototype.lastPage = function () {
            if (!this.hasNextPage()) {
                return;
            }
            this.setPageIndex(this.getNumberOfPages() - 1);
        };
        PepListPagerComponent.prototype.hasPreviousPage = function () {
            return this.pageIndex >= 1 && this.pageSize != 0;
        };
        PepListPagerComponent.prototype.hasNextPage = function () {
            var maxPageIndex = this.getNumberOfPages() - 1;
            return this.pageIndex < maxPageIndex && this.pageSize != 0;
        };
        PepListPagerComponent.prototype.getNumberOfPages = function () {
            if (!this.pageSize) {
                return 0;
            }
            return Math.ceil(this.length / this.pageSize);
        };
        /** Checks whether the buttons for going forwards should be disabled. */
        PepListPagerComponent.prototype._nextButtonsDisabled = function () {
            return this.disabled || !this.hasNextPage();
        };
        /** Checks whether the buttons for going backwards should be disabled. */
        PepListPagerComponent.prototype._previousButtonsDisabled = function () {
            return this.disabled || !this.hasPreviousPage();
        };
        PepListPagerComponent.prototype.onValueChange = function (value) {
            var pageNumber = coercion.coerceNumberProperty(value);
            this.setPageIndex(pageNumber - 1); // - 1 to convert number into index.
        };
        PepListPagerComponent.prototype.setPageIndex = function (newIndex) {
            var previousPageIndex = this.pageIndex;
            if (newIndex >= 0 && newIndex < this.getNumberOfPages()) {
                this._pageIndex = newIndex;
            }
            else {
                this._pageIndex = 0;
            }
            if (this.pageIndex !== previousPageIndex) {
                this._emitChangeEvent(previousPageIndex);
            }
        };
        /** Emits an event notifying that a change of the paginator's properties has been triggered. */
        PepListPagerComponent.prototype._emitChangeEvent = function (previousPageIndex) {
            this.pagerChange.emit({
                previousPageIndex: previousPageIndex,
                pageIndex: this.pageIndex,
                pageSize: this.pageSize,
                length: this.length,
            });
        };
        return PepListPagerComponent;
    }());
    PepListPagerComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-pager',
                    template: "<div class=\"pager-container body-sm\">\n    <span class=\"pep-spacing-element\">{{ 'LIST.PAGER_PAGE' | translate }}</span>\n    <pep-textbox pepAutoWidth class=\"page-index pep-spacing-element\" [key]=\"'pageIndex'\" [type]=\"'int'\"\n        [disabled]=\"disabled\" [xAlignment]=\"'center'\" [renderTitle]=\"false\" [renderError]=\"false\" [renderSymbol]=\"false\"\n        [value]=\"pageIndex + 1\" [formattedValue]=\"pageIndex + 1\" [minValue]=\"1\" [maxValue]=\"this.getNumberOfPages()\"\n        [maxFieldCharacters]=\"6\" [mandatory]=\"true\" (valueChange)=\"onValueChange($event)\">\n    </pep-textbox>\n    <span class=\"pep-spacing-element\">{{ 'LIST.PAGER_OUT_OF' | translate }}</span>\n    <span class=\"pep-spacing-element\">{{ getNumberOfPages() }}</span>\n    <button mat-button [disabled]=\"disabled || _previousButtonsDisabled()\"\n        [ngClass]=\"{ disabled: disabled || _previousButtonsDisabled() }\"\n        class=\"pep-button icon-button pep-spacing-element sm weak\" pepRtlDirection pepMenuBlur (click)=\"previousPage()\"\n        [title]=\"('LIST.PAGER_PREVIOUS' | translate)\">\n        <mat-icon>\n            <pep-icon [name]=\"layoutService.isRtl() ? 'arrow_right' : 'arrow_left'\"></pep-icon>\n        </mat-icon>\n    </button>\n    <button mat-button [disabled]=\"disabled || _nextButtonsDisabled()\"\n        [ngClass]=\"{ disabled: disabled || _nextButtonsDisabled() }\"\n        class=\"pep-button icon-button pep-spacing-element sm weak\" pepRtlDirection pepMenuBlur (click)=\"nextPage()\"\n        [title]=\"('LIST.PAGER_NEXT' | translate)\">\n        <mat-icon>\n            <pep-icon [name]=\"layoutService.isRtl() ? 'arrow_left' : 'arrow_right'\"></pep-icon>\n        </mat-icon>\n    </button>\n</div>",
                    styles: [".pager-container{display:flex;justify-content:center;align-items:center;height:calc(2rem + calc(.5rem * 2));height:calc(2rem + calc(var(--pep-spacing-sm, .5rem) * 2));padding:.5rem;padding:var(--pep-spacing-sm,.5rem)}.pager-container .page-index{min-height:unset;margin-bottom:0}.pager-container .page-index ::ng-deep .mat-form-field-flex{padding:0 .5rem;min-height:2rem}.pager-container .page-index ::ng-deep .mat-form-field-flex .mat-input-element{min-width:1.25rem}"]
                },] },
        { type: core.Injectable }
    ];
    PepListPagerComponent.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: ngxLib.PepLayoutService }
    ]; };
    PepListPagerComponent.propDecorators = {
        disabled: [{ type: core.Input }],
        pageIndex: [{ type: core.Input }],
        length: [{ type: core.Input }],
        pageSize: [{ type: core.Input }],
        pagerChange: [{ type: core.Output }]
    };

    var IPepListSortingOption = /** @class */ (function () {
        function IPepListSortingOption() {
        }
        return IPepListSortingOption;
    }());
    var PepListSortingComponent = /** @class */ (function () {
        function PepListSortingComponent() {
            this._options = null;
            this._currentSorting = null;
            this.sizeType = 'md';
            this.change = new core.EventEmitter();
            this.menuItems = null;
            this.currentItem = null;
        }
        Object.defineProperty(PepListSortingComponent.prototype, "options", {
            get: function () {
                return this._options;
            },
            set: function (value) {
                this._options = value;
                this.menuItems = value.map(function (opt) {
                    return { key: opt.sortBy, text: opt.title, iconName: opt.iconName };
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListSortingComponent.prototype, "currentSorting", {
            get: function () {
                return this._currentSorting;
            },
            set: function (value) {
                this._currentSorting = value;
                this.currentItem = this.menuItems.find(function (mi) { return mi.key === value.sortBy; });
            },
            enumerable: false,
            configurable: true
        });
        PepListSortingComponent.prototype.ngOnInit = function () {
            if (this.currentSorting === null &&
                this.options &&
                this.options.length > 0) {
                this.currentSorting = this.options[0];
            }
        };
        PepListSortingComponent.prototype.onMenuItemClicked = function (menuItemClickEvent) {
            this.currentSorting = this.options.find(function (sorting) { return sorting.sortBy === menuItemClickEvent.source.key; });
            this.change.emit({ source: this.currentSorting });
        };
        return PepListSortingComponent;
    }());
    PepListSortingComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-sorting',
                    template: "<div class=\"sorting-container\">\n    <div class=\"body-xs sort-by\">\n        <span>{{ 'LIST.SORT_BY' | translate }}</span>\n    </div>\n    <pep-menu [type]=\"'select'\" [sizeType]=\"sizeType\" [items]=\"menuItems\" [selectedItem]=\"currentItem\"\n        [iconName]=\"'arrow_down'\" (menuItemClick)=\"onMenuItemClicked($event)\"></pep-menu>\n</div>",
                    styles: [".sorting-container{display:flex;align-items:center}.sorting-container .sort-by{-webkit-margin-end:.5rem;margin-inline-end:.5rem;-webkit-margin-end:var(--pep-spacing-sm,.5rem);margin-inline-end:var(--pep-spacing-sm,.5rem)}"]
                },] },
        { type: core.Injectable }
    ];
    PepListSortingComponent.propDecorators = {
        options: [{ type: core.Input }],
        currentSorting: [{ type: core.Input }],
        sizeType: [{ type: core.Input }],
        change: [{ type: core.Output }]
    };

    var PepListTotalComponent = /** @class */ (function () {
        function PepListTotalComponent() {
            this.totalRows = -1;
            this.totalAmount = -1;
            this.isMapView = false;
        }
        return PepListTotalComponent;
    }());
    PepListTotalComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-total',
                    template: "<div class=\"total-items-container\">\n    <ng-container *ngIf=\"isMapView; then mapTemplate; else notMapTemplate\"></ng-container>\n\n    <ng-template #notMapTemplate>\n        <ng-container *ngIf=\"totalRows >= 0\">\n            <div class=\"body-md total-items\"\n                [innerHtml]=\"(totalRows === 1 ? 'LIST.TOTAL_RESULT' : 'LIST.TOTAL_RESULTS') | translate: { totalRows: totalRows }\">\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"totalAmount > 0\"> {{ 'LIST.TOTAL_OF' | translate }} {{ totalAmount }} </ng-container>\n    </ng-template>\n\n    <ng-template #mapTemplate>\n        <ng-container *ngIf=\"totalAmount >= 0\">\n        </ng-container>\n        <ng-container *ngIf=\"totalRows >= 0\">\n            <div class=\"body-md total-items\"\n                [innerHtml]=\"(totalRows === 1 ? 'LIST.TOTAL_RESULT_OUT_OF_RESULT' : 'LIST.TOTAL_RESULTS_OUT_OF') | translate: { xRows: totalAmount, totalRows: totalRows }\">\n            </div>\n        </ng-container>\n    </ng-template>\n</div>",
                    styles: [".total-items-container{height:calc(.5rem + 2.5rem);height:calc(var(--pep-top-bar-spacing-bottom, .5rem) + var(--pep-top-bar-field-height, 2.5rem));display:flex;align-items:center}"]
                },] },
        { type: core.Injectable }
    ];
    PepListTotalComponent.propDecorators = {
        totalRows: [{ type: core.Input }],
        totalAmount: [{ type: core.Input }],
        isMapView: [{ type: core.Input }]
    };

    var IPepListView = /** @class */ (function () {
        function IPepListView() {
        }
        return IPepListView;
    }());
    var PepListViewsComponent = /** @class */ (function () {
        function PepListViewsComponent() {
            this._views = null;
            this._currentView = null;
            this.displayType = 'menu';
            this.styleType = 'weak';
            this.sizeType = 'md';
            this.classNames = '';
            this.change = new core.EventEmitter();
            this.menuItems = null;
            this.currentItem = null;
        }
        Object.defineProperty(PepListViewsComponent.prototype, "views", {
            get: function () {
                return this._views;
            },
            set: function (value) {
                this._views = value;
                this.menuItems = value.map(function (opt) {
                    return { key: opt.key, text: opt.title, iconName: opt.iconName };
                });
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(PepListViewsComponent.prototype, "currentView", {
            get: function () {
                return this._currentView;
            },
            set: function (value) {
                this._currentView = value;
                if (this.displayType === 'menu') {
                    this.currentItem = this.menuItems.find(function (mi) { return mi.key === value.key; });
                }
            },
            enumerable: false,
            configurable: true
        });
        PepListViewsComponent.prototype.ngOnInit = function () {
            if (this.displayType === 'buttons') {
                if (this.currentView === null &&
                    this.views &&
                    this.views.length > 0) {
                    this.currentView = this.views[0];
                }
            }
        };
        PepListViewsComponent.prototype.onMenuItemClicked = function (menuItemClickEvent) {
            this.currentView = this.views.find(function (list) { return list.key === menuItemClickEvent.source.key; });
            this.raiseChangeEvent();
        };
        PepListViewsComponent.prototype.onViewChanged = function (view) {
            this.currentView = view;
            this.raiseChangeEvent();
        };
        PepListViewsComponent.prototype.raiseChangeEvent = function () {
            this.change.emit({ source: this.currentView });
        };
        return PepListViewsComponent;
    }());
    PepListViewsComponent.decorators = [
        { type: core.Component, args: [{
                    selector: 'pep-list-views',
                    template: "<ng-container *ngIf=\"displayType === 'menu' then menuTemplate else buttonsTemplate\">\n</ng-container>\n<ng-template #menuTemplate>\n    <pep-menu [type]=\"'select'\" [styleType]=\"styleType\" [sizeType]=\"sizeType\" [classNames]=\"classNames\"\n        [items]=\"menuItems\" [selectedItem]=\"currentItem\"\n        [iconName]=\"currentItem?.iconName ? currentItem?.iconName : 'arrow_down'\"\n        (menuItemClick)=\"onMenuItemClicked($event)\"></pep-menu>\n</ng-template>\n<ng-template #buttonsTemplate>\n    <div class=\"buttons-wrapper pep-spacing-element-negative\">\n        <button *ngFor=\"let view of views\" mat-button [title]=\"view.title\" [disabled]=\"view.key === currentView?.key\"\n            class=\"pep-button icon-button pep-spacing-element {{ sizeType }} {{ styleType }} {{ classNames }}\"\n            pepRtlDirection pepMenuBlur (click)=\"onViewChanged(view)\">\n            <mat-icon>\n                <pep-icon name=\"{{ view?.iconName }}\"></pep-icon>\n            </mat-icon>\n        </button>\n    </div>\n</ng-template>",
                    styles: [".buttons-wrapper{display:flex}"]
                },] },
        { type: core.Injectable }
    ];
    PepListViewsComponent.propDecorators = {
        views: [{ type: core.Input }],
        currentView: [{ type: core.Input }],
        displayType: [{ type: core.Input }],
        styleType: [{ type: core.Input }],
        sizeType: [{ type: core.Input }],
        classNames: [{ type: core.Input }],
        change: [{ type: core.Output }]
    };

    var IsItemSelectedPipe = /** @class */ (function () {
        function IsItemSelectedPipe() {
            this.SEPARATOR = ',';
        }
        IsItemSelectedPipe.prototype.getUniqItemId = function (itemId, itemType) {
            if (itemType === void 0) { itemType = ''; }
            return itemId + this.SEPARATOR + itemType;
        };
        IsItemSelectedPipe.prototype.transform = function (item, selectionTypeForActions, selectedItemId, isAllSelected, selectedItems, unSelectedItems) {
            var isSelected = false;
            if (selectionTypeForActions === 'single') {
                isSelected = selectedItemId === this.getUniqItemId(item === null || item === void 0 ? void 0 : item.UID, item === null || item === void 0 ? void 0 : item.Type.toString());
            }
            // else if (selectionTypeForActions === 'single-action') {
            //     isSelected = (isAllSelected && !unSelectedItems.has(item?.UID)) || selectedItems.has(item?.UID);
            // }
            else if (selectionTypeForActions === 'multi') {
                if (item === null || item === void 0 ? void 0 : item.IsSelectableForActions) {
                    isSelected = (isAllSelected && !unSelectedItems.has(item === null || item === void 0 ? void 0 : item.UID)) || selectedItems.has(item === null || item === void 0 ? void 0 : item.UID);
                }
            }
            return isSelected;
        };
        return IsItemSelectedPipe;
    }());
    IsItemSelectedPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'isItemSelected'
                },] }
    ];
    var IsItemDisabledPipe = /** @class */ (function () {
        function IsItemDisabledPipe() {
        }
        IsItemDisabledPipe.prototype.transform = function (item, lockItemInnerEvents, printMode) {
            return (printMode || lockItemInnerEvents || (item && !item.IsSelectableForActions));
        };
        return IsItemDisabledPipe;
    }());
    IsItemDisabledPipe.decorators = [
        { type: core.Pipe, args: [{
                    name: 'isItemDisabled'
                },] }
    ];

    var listComponents = [
        // PepListOldComponent,
        PepListComponent,
        PepListActionsComponent,
        PepListCarouselComponent,
        PepListChooserComponent,
        PepListPagerComponent,
        PepListSortingComponent,
        PepListTotalComponent,
        PepListViewsComponent,
    ];
    var listPipes = [
        IsItemSelectedPipe,
        IsItemDisabledPipe
    ];
    // import { PepVirtualScrollComponent } from './virtual-scroll.component';
    var PepListModule = /** @class */ (function () {
        function PepListModule(pepIconRegistry) {
            this.pepIconRegistry = pepIconRegistry;
            this.pepIconRegistry.registerIcons([
                icon.pepIconArrowDown,
                icon.pepIconArrowEither,
                icon.pepIconArrowUp,
                icon.pepIconSystemMust,
                icon.pepIconArrowRight,
                icon.pepIconArrowRightAlt,
                icon.pepIconArrowLeft,
                icon.pepIconArrowLeftAlt,
            ]);
        }
        return PepListModule;
    }());
    PepListModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        // Material modules,
                        core$1.MatCommonModule,
                        button.MatButtonModule,
                        checkbox.MatCheckboxModule,
                        radio.MatRadioModule,
                        icon$1.MatIconModule,
                        menu.MatMenuModule,
                        // ngx-lib modules
                        ngxLib.PepNgxLibModule,
                        breadCrumbs.PepBreadCrumbsModule,
                        button$1.PepButtonModule,
                        carousel.PepCarouselModule,
                        icon.PepIconModule,
                        form.PepFormModule,
                        menu$1.PepMenuModule,
                        textbox.PepTextboxModule,
                        VirtualScrollerModule
                    ],
                    exports: [listComponents],
                    declarations: [listComponents, listPipes],
                },] }
    ];
    PepListModule.ctorParameters = function () { return [
        { type: icon.PepIconRegistry }
    ]; };

    /*
     * Public API Surface of ngx-lib/list
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DEFAULT_PAGE_SIZE = DEFAULT_PAGE_SIZE;
    exports.IPepListChooserOption = IPepListChooserOption;
    exports.IPepListPagerChangeEvent = IPepListPagerChangeEvent;
    exports.IPepListSortingOption = IPepListSortingOption;
    exports.IPepListView = IPepListView;
    exports.PepListActionsComponent = PepListActionsComponent;
    exports.PepListCarouselComponent = PepListCarouselComponent;
    exports.PepListChooserComponent = PepListChooserComponent;
    exports.PepListComponent = PepListComponent;
    exports.PepListModule = PepListModule;
    exports.PepListPagerComponent = PepListPagerComponent;
    exports.PepListSortingComponent = PepListSortingComponent;
    exports.PepListTotalComponent = PepListTotalComponent;
    exports.PepListViewsComponent = PepListViewsComponent;
    exports.PepSelectionData = PepSelectionData;
    exports.a = VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY;
    exports.b = VirtualScrollerComponent;
    exports.c = VirtualScrollerModule;
    exports.d = IsItemSelectedPipe;
    exports.e = IsItemDisabledPipe;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=pepperi-addons-ngx-lib-list.umd.js.map
