import * as i0 from '@angular/core';
import { Injectable, Injector, Directive, Optional, Renderer2, ElementRef, Pipe, Input, HostListener, Inject, TemplateRef, ViewContainerRef, NgModule, InjectionToken, PLATFORM_ID } from '@angular/core';
import * as i1$1 from '@angular/common';
import { DOCUMENT, CommonModule, isPlatformBrowser } from '@angular/common';
import * as i3 from '@angular/common/http';
import { HttpResponse, HTTP_INTERCEPTORS, HttpClientModule, HttpHeaders, HttpClient } from '@angular/common/http';
import * as i3$1 from '@angular/forms';
import { ReactiveFormsModule, FormControl, Validators, FormBuilder } from '@angular/forms';
import { throwError, BehaviorSubject, Subject } from 'rxjs';
import { catchError, distinctUntilChanged, finalize, tap } from 'rxjs/operators';
import * as i1 from '@ngx-translate/core';
import { TranslateService, TranslateModule } from '@ngx-translate/core';
import { DomSanitizer } from '@angular/platform-browser';
import { coerceNumberProperty } from '@angular/cdk/coercion';
import { MultiTranslateHttpLoader } from 'ngx-translate-multi-http-loader';

// import { ToastrService } from 'ngx-toastr';
class PepErrorInterceptor {
    // constructor() {} // private toastr: ToastrService
    intercept(req, next) {
        // console.warn('ErrorInterceptor');
        return next.handle(req).pipe(
        // retry(2), TODO: Check if we want to retry
        catchError((error) => {
            // 401 handled in auth.interceptor
            if (error.status !== 401) {
                // TODO: Show error in dialog.
                // this.toastr.error(error.message);
            }
            return throwError(error);
        }));
    }
}
PepErrorInterceptor.decorators = [
    { type: Injectable }
];

class PepLoaderService {
    constructor() {
        this.counter = 0;
        this.showLoaderSubject = new BehaviorSubject(false);
        // Raise custom event for showing the loader.
        this.onChanged$.subscribe((show) => {
            this.showLoaderChanged(show);
        });
    }
    get onChanged$() {
        return this.showLoaderSubject
            .asObservable()
            .pipe(distinctUntilChanged());
    }
    showLoaderChanged(show) {
        const eventData = {
            detail: {
                showLoader: show,
            },
        };
        const event = new CustomEvent('toggleLoader', eventData);
        window.dispatchEvent(event);
    }
    show() {
        this.counter++;
        this.showLoaderSubject.next(true);
    }
    hide() {
        this.counter--;
        if (this.counter < 0) {
            this.counter = 0;
        }
        if (this.counter === 0) {
            this.showLoaderSubject.next(false);
        }
    }
}
PepLoaderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepLoaderService_Factory() { return new PepLoaderService(); }, token: PepLoaderService, providedIn: "root" });
PepLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepLoaderService.ctorParameters = () => [];

class PepLoaderInterceptor {
    constructor(injector) {
        this.injector = injector;
    }
    intercept(req, next) {
        // console.warn('LoaderInterceptor');
        const loaderService = this.injector.get(PepLoaderService);
        loaderService.show();
        return next.handle(req).pipe(
        // delay(3000),
        catchError((err) => {
            loaderService.hide();
            return throwError(err);
        }), finalize(() => loaderService.hide()));
        // return next.handle(req).pipe(map(event => {
        //     if (event instanceof HttpResponse) {
        //        loaderService.hide();
        //     }
        //     return event;
        // }));
    }
}
PepLoaderInterceptor.decorators = [
    { type: Injectable }
];
PepLoaderInterceptor.ctorParameters = () => [
    { type: Injector }
];

class PepProfilerInterceptor {
    intercept(req, next) {
        // console.warn('ProfilerInterceptor');
        const started = Date.now();
        let ok;
        return next.handle(req).pipe(tap(
        // Succeeds when there is a response; ignore other events
        (event) => {
            if (event instanceof HttpResponse) {
                ok = 'succeeded';
            }
        }, 
        // Operation failed; error is an HttpErrorResponse
        (error) => (ok = 'failed')), 
        // Log when response observable either completes or errors
        finalize(() => {
            const elapsed = Date.now() - started;
            const msg = `${req.method} "${req.urlWithParams}" ${ok} in ${elapsed} ms.`;
            console.log(msg);
        }));
    }
}
PepProfilerInterceptor.decorators = [
    { type: Injectable }
];

const httpInterceptorProviders = [
    // { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    //   { provide: HTTP_INTERCEPTORS, useClass: CacheInterceptor, multi: true },
    //   { provide: HTTP_INTERCEPTORS, useClass: ConvertInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: PepErrorInterceptor, multi: true },
    //   { provide: HTTP_INTERCEPTORS, useClass: FakeInterceptor, multi: true },
    //   { provide: HTTP_INTERCEPTORS, useClass: HeaderInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: PepLoaderInterceptor, multi: true },
    {
        provide: HTTP_INTERCEPTORS,
        useClass: PepProfilerInterceptor,
        multi: true,
    },
];

// Import the core angular services.
// Import the application components and services.
// import { PepClipboardService } from './clipboard.service';
// This directive acts as a simple glue layer between the given [clipboard] property
// and the underlying ClipboardService. Upon the (click) event, the [clipboard] value
// will be copied to the ClipboardService and a (clipboardCopy) event will be emitted.
class PepClipboardDirective {
}
PepClipboardDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepClipboard]',
                inputs: ['value: clipboard'],
                outputs: ['copyEvent: clipboardCopy', 'errorEvent: clipboardError'],
                host: {
                    '(click)': 'copyToClipboard()',
                },
            },] }
];

// Const BIDI_RTL_LANGS Array
// BIDI_RTL_LANGS ref: http://en.wikipedia.org/wiki/Right-to-left
// Table of scripts in Unicode: https://en.wikipedia.org/wiki/Script_(Unicode)
const _BIDI_RTL_LANGS = [
    'ae' /* Avestan */,
    'ar' /* 'العربية', Arabic */,
    'arc' /* Aramaic */,
    'bcc' /* 'بلوچی مکرانی', Southern Balochi */,
    'bqi' /* 'بختياري', Bakthiari */,
    'ckb' /* 'Soranî / کوردی', Sorani */,
    'dv' /* Dhivehi */,
    'fa' /* 'فارسی', Persian */,
    'glk' /* 'گیلکی', Gilaki */,
    'he' /* 'עברית', Hebrew */,
    'ku' /* 'Kurdî / كوردی', Kurdish */,
    'mzn' /* 'مازِرونی', Mazanderani */,
    'nqo' /* N'Ko */,
    'pnb' /* 'پنجابی', Western Punjabi */,
    'ps' /* 'پښتو', Pashto, */,
    'sd' /* 'سنڌي', Sindhi */,
    'ug' /* 'Uyghurche / ئۇيغۇرچە', Uyghur */,
    'ur' /* 'اردو', Urdu */,
    'yi' /* 'ייִדיש', Yiddish */,
];
var PepScreenSizeType;
(function (PepScreenSizeType) {
    PepScreenSizeType[PepScreenSizeType["XL"] = 0] = "XL";
    PepScreenSizeType[PepScreenSizeType["LG"] = 1] = "LG";
    PepScreenSizeType[PepScreenSizeType["MD"] = 2] = "MD";
    PepScreenSizeType[PepScreenSizeType["SM"] = 3] = "SM";
    PepScreenSizeType[PepScreenSizeType["XS"] = 4] = "XS";
})(PepScreenSizeType || (PepScreenSizeType = {}));
// export type PepScreenSizeType = 'xl' | 'lg' | 'md' | 'sm' | 'xs';
class PepLayoutService {
    constructor(translate = null) {
        this.translate = translate;
        this.documentMouseoverListener = (event) => {
            this.deviceHasMouseSubject.next(true);
            this.deviceHasMouseSubject.complete();
            document.removeEventListener('mouseover', this.documentMouseoverListener, false);
        };
        this.resizeSubject = new BehaviorSubject(PepScreenSizeType.LG);
        this.deviceHasMouseSubject = new BehaviorSubject(false);
        document.addEventListener('mouseover', this.documentMouseoverListener, false);
        // document.addEventListener('touchstart', this._documentTouchstartListener, false);
    }
    get onResize$() {
        return this.resizeSubject.asObservable().pipe(distinctUntilChanged());
    }
    get onMouseOver$() {
        return this.deviceHasMouseSubject
            .asObservable()
            .pipe(distinctUntilChanged());
    }
    // private _documentTouchstartListener = (event: TouchEvent) => {
    //     debugger;
    //     this.isTouchDevice = true;
    //     document.removeEventListener('touchstart', this._documentTouchstartListener, false);
    // }
    /**
     * Set the current screen size.
     * @param size The size to change to.
     */
    onResize(size) {
        this.resizeSubject.next(size);
    }
    getDeviceHasMouse() {
        return this.deviceHasMouseSubject.getValue();
    }
    getOrintation() {
        if (window.innerHeight > window.innerWidth) {
            return 'portrait';
        }
        else {
            return 'landscape';
        }
    }
    getScreenWidth() {
        let retVal = 250.0;
        switch (this.resizeSubject.getValue()) {
            case PepScreenSizeType.XS: {
                retVal = this.getOrintation() === 'landscape' ? 130.0 : 65.0;
                break;
            }
            case PepScreenSizeType.SM:
            case PepScreenSizeType.MD: {
                retVal = this.getOrintation() === 'landscape' ? 220.0 : 140.0;
                break;
            }
            case PepScreenSizeType.LG:
            case PepScreenSizeType.XL: {
                retVal = this.getOrintation() === 'landscape' ? 400.0 : 250.0;
                break;
            }
        }
        return retVal;
    }
    getScreenHeight() {
        let retVal = 250.0;
        switch (this.resizeSubject.getValue()) {
            case PepScreenSizeType.XS: {
                retVal = this.getOrintation() === 'landscape' ? 65.0 : 130.0;
                break;
            }
            case PepScreenSizeType.SM:
            case PepScreenSizeType.MD: {
                retVal = this.getOrintation() === 'landscape' ? 140.0 : 220.0;
                break;
            }
            case PepScreenSizeType.LG:
            case PepScreenSizeType.XL: {
                retVal = this.getOrintation() === 'landscape' ? 250.0 : 400.0;
                break;
            }
        }
        return retVal;
    }
    getScreenHeightPx() {
        return (window.innerHeight ||
            document.documentElement.clientHeight ||
            document.body.clientHeight);
    }
    getScreenWidthPx() {
        return (window.innerWidth ||
            document.documentElement.clientWidth ||
            document.body.clientWidth);
    }
    getScrollbarWidth() {
        // Creating invisible container
        const outer = document.createElement('div');
        outer.style.visibility = 'hidden';
        outer.style.overflow = 'scroll'; // forcing scrollbar to appear
        // outer.style.msOverflowStyle = 'scrollbar'; // needed for WinJS apps
        document.body.appendChild(outer);
        // Creating inner element and placing it in the container
        const inner = document.createElement('div');
        outer.appendChild(inner);
        // Calculating difference between container's full width and the child width
        const scrollbarWidth = (outer.offsetWidth - inner.offsetWidth);
        // Removing temporary elements from the DOM
        outer.parentNode.removeChild(outer);
        return scrollbarWidth;
    }
    getCurrentLanguage() {
        var _a;
        return ((_a = this.translate) === null || _a === void 0 ? void 0 : _a.getBrowserCultureLang()) || navigator.language;
    }
    isRtl() {
        const userLang = this.getCurrentLanguage();
        const isRtl = _BIDI_RTL_LANGS.indexOf(userLang) >= 0;
        return isRtl;
    }
}
PepLayoutService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepLayoutService_Factory() { return new PepLayoutService(i0.ɵɵinject(i1.TranslateService, 8)); }, token: PepLayoutService, providedIn: "root" });
PepLayoutService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepLayoutService.ctorParameters = () => [
    { type: TranslateService, decorators: [{ type: Optional }] }
];

class PepRtlClassDirective {
    constructor(layoutService, renderer, element) {
        this.layoutService = layoutService;
        this.renderer = renderer;
        this.element = element;
    }
    ngOnInit() {
        const isRtl = this.layoutService.isRtl();
        if (isRtl) {
            this.renderer.addClass(this.element.nativeElement, 'rtl');
        }
    }
}
PepRtlClassDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepRtlClass]',
            },] }
];
PepRtlClassDirective.ctorParameters = () => [
    { type: PepLayoutService },
    { type: Renderer2 },
    { type: ElementRef }
];
class PepRtlDirectionDirective {
    constructor(layoutService, renderer, element) {
        this.layoutService = layoutService;
        this.renderer = renderer;
        this.element = element;
    }
    ngOnInit() {
        const isRtl = this.layoutService.isRtl();
        this.renderer.setAttribute(this.element.nativeElement, 'dir', isRtl ? 'rtl' : 'ltr');
    }
}
PepRtlDirectionDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepRtlDirection]',
            },] }
];
PepRtlDirectionDirective.ctorParameters = () => [
    { type: PepLayoutService },
    { type: Renderer2 },
    { type: ElementRef }
];

class PepCapitalizePipe {
    transform(value) {
        if (value) {
            return value.charAt(0).toUpperCase() + value.slice(1);
        }
        return value;
    }
}
PepCapitalizePipe.decorators = [
    { type: Pipe, args: [{ name: 'pepCapitalize' },] }
];
class PepEncodePipe {
    transform(value) {
        if (value) {
            const v = btoa(value);
            return v;
        }
        return value;
    }
}
PepEncodePipe.decorators = [
    { type: Pipe, args: [{ name: 'pepEncode' },] }
];
class PepEscapePipe {
    transform(value) {
        if (value) {
            const v = escape(value);
            return v;
        }
        return value;
    }
}
PepEscapePipe.decorators = [
    { type: Pipe, args: [{ name: 'pepEscape' },] }
];
class PepReplaceLineBreaksPipe {
    transform(value) {
        const newValue = value.replace(/(<br\ ?\/?>)/g, ' ');
        return newValue;
    }
}
PepReplaceLineBreaksPipe.decorators = [
    { type: Pipe, args: [{ name: 'pepReplaceLineBreaks' },] }
];
class PepDateFormatterPipe {
    transform(value, culture, showTime = false) {
        let res = '';
        value = new Date(value);
        if (value) {
            res = value.toLocaleDateString(culture || 'en-US');
            if (showTime) {
                res +=
                    ' ' +
                        value.toLocaleTimeString(culture || 'en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                        });
            }
        }
        return res;
    }
}
PepDateFormatterPipe.decorators = [
    { type: Pipe, args: [{ name: 'pepDateFormatter' },] }
];
class PepDateStringFormatterPipe {
    transform(value, culture, showTime = false) {
        let res = '';
        const tmpDate = new Date(value);
        if (value) {
            res = tmpDate.toLocaleDateString(culture || 'en-US');
            if (showTime) {
                res += ' ' + tmpDate.toLocaleTimeString(culture || 'en-US');
            }
        }
        return res;
    }
}
PepDateStringFormatterPipe.decorators = [
    { type: Pipe, args: [{ name: 'pepDateStringFormatter' },] }
];
class PepSafeHtmlPipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(html) {
        return this.sanitizer.bypassSecurityTrustHtml(html);
    }
}
PepSafeHtmlPipe.decorators = [
    { type: Pipe, args: [{ name: 'pepSafeHtml' },] }
];
PepSafeHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];
class PepSafePipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(value, type) {
        switch (type) {
            case 'html':
                return this.sanitizer.bypassSecurityTrustHtml(value);
            case 'style':
                return this.sanitizer.bypassSecurityTrustStyle(value);
            case 'script':
                return this.sanitizer.bypassSecurityTrustScript(value);
            case 'url':
                return this.sanitizer.bypassSecurityTrustUrl(value);
            case 'resourceUrl':
                return this.sanitizer.bypassSecurityTrustResourceUrl(value);
            default:
                throw new Error(`Invalid safe type specified: ${type}`);
        }
    }
}
PepSafePipe.decorators = [
    { type: Pipe, args: [{ name: 'pepSafe' },] }
];
PepSafePipe.ctorParameters = () => [
    { type: DomSanitizer }
];
class PepSplitUppercasePipe {
    transform(value) {
        const newValue = value.replace(/([a-z])([A-Z])/g, '$1 $2');
        return newValue;
    }
}
PepSplitUppercasePipe.decorators = [
    { type: Pipe, args: [{ name: 'pepSplitUppercase' },] }
];
class PepToNumberPipe {
    transform(value) {
        return parseInt(value);
    }
}
PepToNumberPipe.decorators = [
    { type: Pipe, args: [{ name: 'pepToNumber' },] }
];

class PepInputAutoWidthDirective {
    constructor(renderer, el) {
        this.renderer = renderer;
        this.el = el;
        this.includePadding = true;
        this.input = null;
    }
    ngAfterViewInit() {
        if (this.el.nativeElement.tagName.toLowerCase() === 'input') {
            this.input = this.el;
        }
        else {
            const list = this.el.nativeElement.querySelectorAll('input');
            this.input = list.length > 0 ? list[0] : null;
        }
        if (this.input) {
            this.input.addEventListener('blur', this.setWidthUsingText.bind(this));
            this.input.addEventListener('keyup', this.setWidthUsingText.bind(this));
        }
        this.setWidthUsingText();
    }
    ngOnDestroy() {
        this.input.removeEventListener('blur', this.setWidthUsingText.bind(this));
        this.input.removeEventListener('keyup', this.setWidthUsingText.bind(this));
    }
    get paddingWidth() {
        return this.includePadding
            ? this._sumPropertyValues(['padding-left', 'padding-right'])
            : 0;
    }
    get style() {
        return getComputedStyle(this.input, '');
    }
    setWidth(width) {
        this.renderer.setStyle(this.input, 'width', width + 'px');
    }
    setWidthUsingText() {
        if (this.input) {
            const text = this.input.value;
            this.setWidth(this.textWidth(text) + this.paddingWidth);
        }
    }
    _sumPropertyValues(properties) {
        return properties
            .map((property) => parseInt(this.style.getPropertyValue(property), 10))
            .reduce((a, b) => a + b, 0);
    }
    textWidth(value) {
        const ctx = this.renderer.createElement('canvas').getContext('2d');
        const { fontStyle, fontVariant, fontWeight, fontSize, fontFamily, } = this.style;
        // font string format: {normal, normal, 700, 20px, Roboto, "Helvetica Neue", sans-serif}
        ctx.font =
            fontStyle +
                ' ' +
                fontVariant +
                ' ' +
                fontWeight +
                ' ' +
                fontSize +
                ' ' +
                fontFamily;
        return ctx ? ctx.measureText(value).width : 0;
    }
}
PepInputAutoWidthDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepAutoWidth]',
            },] }
];
PepInputAutoWidthDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
PepInputAutoWidthDirective.propDecorators = {
    includePadding: [{ type: Input }]
};

class PepButtonBlurDirective {
    constructor(element) {
        this.element = element;
    }
    onClick() {
        setTimeout(() => {
            this.element.nativeElement.blur();
        }, 0);
    }
}
PepButtonBlurDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepButtonBlur]',
            },] }
];
PepButtonBlurDirective.ctorParameters = () => [
    { type: ElementRef }
];
PepButtonBlurDirective.propDecorators = {
    onClick: [{ type: HostListener, args: ['click',] }]
};

class PepUtilitiesService {
    constructor(translate = null) {
        var _a;
        this.translate = translate;
        this.culture = 'en-US';
        this.culture = ((_a = this.translate) === null || _a === void 0 ? void 0 : _a.getBrowserCultureLang()) || 'en-US';
        this.numberFormatter = new Intl.NumberFormat(this.culture, {
            maximumFractionDigits: 2,
        });
    }
    changeDecimalSeperator(value, reverse = false) {
        // If the decimal separator is ','
        if (this.getDecimalSeparator() === ',') {
            // If reverse change the number from '.' to ',' else do the opposite.
            value = reverse ? value.replace('.', ',') : value.replace(',', '.');
        }
        return value;
    }
    getDecimalSeparator() {
        const numberWithDecimalSeparator = 1.1;
        return numberWithDecimalSeparator
            .toLocaleString(this.culture)
            .substring(1, 2);
    }
    parseDate(dateStr, showTime = false) {
        let retVal = null;
        if (dateStr !== '') {
            retVal = new Date(dateStr);
            // Convert to date with no offset.
            if (!showTime) {
                const index = dateStr.indexOf('T');
                if (index > 0) {
                    dateStr = dateStr.substring(0, index);
                }
                const dateText = dateStr.split('-');
                if (dateText.length === 3) {
                    const year = Number(dateText[0]);
                    const month = Number(dateText[1]) - 1;
                    const day = Number(dateText[2]);
                    retVal = new Date(year, month, day);
                }
            }
        }
        if (retVal && isNaN(retVal.getTime())) {
            retVal = null;
        }
        return retVal;
    }
    stringifyDate(date, showTime = false) {
        if (date) {
            if (showTime) {
                return date.toISOString(); // include - offset
            }
            else {
                const dateText = [];
                dateText.push(date.getFullYear(), '-', date.getMonth() + 1, '-', date.getDate());
                return dateText.join('');
            }
        }
        else {
            return '';
        }
        // if (date) {
        //     const dateText = [];
        //     dateText.push(
        //         date.getFullYear(),
        //         '-',
        //         date.getMonth() + 1,
        //         '-',
        //         date.getDate()
        //     );
        //     if (showTime) {
        //         dateText.push(
        //             'T',
        //             (date.getHours() < 10 ? '0' : '') + date.getHours(),
        //             ':',
        //             (date.getMinutes() < 10 ? '0' : '') + date.getMinutes(),
        //             ':',
        //             (date.getSeconds() < 10 ? '0' : '') + date.getSeconds(),
        //             'Z'
        //         );
        //     }
        //     return dateText.join('');
        // } else {
        //     return '';
        // }
    }
    isValueHtml(value) {
        let res = false;
        const REGEXP = /<\/?[a-z][\s\S]*>/i;
        res = REGEXP.test(value);
        return res;
    }
    isJsonString(str) {
        try {
            JSON.parse(str);
        }
        catch (e) {
            return false;
        }
        return true;
    }
    getSvgElementFromString(document, svgContent) {
        const div = document.createElement('DIV');
        div.innerHTML = svgContent;
        return (div.querySelector('svg') ||
            document.createElementNS('http://www.w3.org/2000/svg', 'path'));
    }
    formatNumber(value) {
        const number = this.coerceNumberProperty(value);
        return this.numberFormatter.format(number);
    }
    incrementNumber(value) {
        let numberValue = this.coerceNumberProperty(value);
        const newNumber = this.changeDecimalSeperator((++numberValue).toString(), true);
        return newNumber;
    }
    decrementNumber(value) {
        let numberValue = this.coerceNumberProperty(value);
        const newNumber = this.changeDecimalSeperator((--numberValue).toString(), true);
        return newNumber;
    }
    coerceNumberProperty(value, fallbackValue = 0) {
        // If the decimal separator is ',' change it to '.'
        value = this.changeDecimalSeperator(value);
        return coerceNumberProperty(value, fallbackValue);
    }
}
PepUtilitiesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepUtilitiesService_Factory() { return new PepUtilitiesService(i0.ɵɵinject(i1.TranslateService, 8)); }, token: PepUtilitiesService, providedIn: "root" });
PepUtilitiesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepUtilitiesService.ctorParameters = () => [
    { type: TranslateService, decorators: [{ type: Optional }] }
];

class PepButtonLoaderDirective {
    constructor(renderer, element, utilitiesService, document) {
        this.renderer = renderer;
        this.element = element;
        this.utilitiesService = utilitiesService;
        this.document = document;
        this.loaderTime = 0;
        this.loaderColor = null;
        this.loaderWidth = '1.5rem';
        this.loaderHeight = 'inherit';
        this.ignoreDisabledStyle = false;
        this._isLoading = false;
        this._finish = null;
    }
    set finish(value) {
        this._finish = value;
        if (this._isLoading && value) {
            this.toggleLoading(false);
        }
    }
    clickEvent(event) {
        this.toggleLoading(true);
        // In case that the finish input is supplied - init it.
        if (this._finish !== null) {
            this._finish = false;
        }
        else {
            // Init loaderTime if is not supplied (3000 - default 3 seconds).
            if (this.loaderTime === 0) {
                this.loaderTime = 3000;
            }
        }
        if (this.loaderTime > 0) {
            setTimeout(() => {
                this.toggleLoading(false);
            }, this.loaderTime);
        }
    }
    ngOnInit() {
        this.setButtonStyle();
        const svgData = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128" preserveAspectRatio="xMidYMid" class="lds-ripple" style="background:0 0; "><circle cx="64" cy="64" r="0" fill="none" stroke-width="10"><animate attributeName="r" calcMode="spline" values="0;59" keyTimes="0;1" dur="2.4" keySplines="0 0.3 0.8 0.8" begin="-1.6s" repeatCount="indefinite"/><animate attributeName="opacity" calcMode="spline" values="1;0" keyTimes="0;1" dur="2.4" keySplines="0.3 0 0.8 1" begin="-1.6s" repeatCount="indefinite"/></circle><circle cx="64" cy="64" r="0" fill="none" stroke-width="10"><animate attributeName="r" calcMode="spline" values="0;59" keyTimes="0;1" dur="2.4" keySplines="0 0.3 0.8 0.8" begin="-0.8s" repeatCount="indefinite"/><animate attributeName="opacity" calcMode="spline" values="1;0" keyTimes="0;1" dur="2.4" keySplines="0.3 0 0.8 1" begin="-0.8s" repeatCount="indefinite"/></circle><circle cx="64" cy="64" r="0" fill="none" stroke-width="10"><animate attributeName="r" calcMode="spline" values="0;59" keyTimes="0;1" dur="2.4" keySplines="0 0.3 0.8 0.8" begin="0s" repeatCount="indefinite"/><animate attributeName="opacity" calcMode="spline" values="1;0" keyTimes="0;1" dur="2.4" keySplines="0.3 0 0.8 1" begin="0s" repeatCount="indefinite"/></circle></svg>';
        this.svgIcon = this.utilitiesService.getSvgElementFromString(this.document, svgData);
        this.setIconStyle();
    }
    setButtonStyle() {
        this.renderer.setStyle(this.element.nativeElement, 'display', 'flex');
        this.renderer.setStyle(this.element.nativeElement, 'justify-content', 'center');
        this.renderer.setStyle(this.element.nativeElement, 'align-items', 'center');
        if (this.ignoreDisabledStyle) {
            this.renderer.addClass(this.element.nativeElement, 'ignore-disabled');
        }
    }
    setIconStyle() {
        if (this.loaderColor) {
            this.renderer.setStyle(this.svgIcon, 'stroke', this.loaderColor);
        }
        this.renderer.setStyle(this.svgIcon, 'width', this.loaderWidth);
        this.renderer.setStyle(this.svgIcon, 'height', this.loaderHeight);
        this.renderer.setStyle(this.svgIcon, 'margin-inline-start', '0.5rem');
        this.renderer.addClass(this.svgIcon, 'svg-icon');
        this.renderer.addClass(this.svgIcon, 'stroke');
    }
    toggleLoading(show) {
        if (show) {
            this._isLoading = true;
            this.renderer.appendChild(this.element.nativeElement, this.svgIcon);
            this.renderer.setAttribute(this.element.nativeElement, 'disabled', 'true');
            this.renderer.addClass(this.element.nativeElement, 'lock-events');
        }
        else {
            if (this._isLoading) {
                this._isLoading = false;
                this.renderer.removeChild(this.element.nativeElement, this.svgIcon);
                this.renderer.removeAttribute(this.element.nativeElement, 'disabled');
                this.renderer.removeClass(this.element.nativeElement, 'lock-events');
            }
        }
    }
}
PepButtonLoaderDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepButtonLoader]',
            },] }
];
PepButtonLoaderDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: PepUtilitiesService },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
PepButtonLoaderDirective.propDecorators = {
    loaderTime: [{ type: Input }],
    loaderColor: [{ type: Input }],
    loaderWidth: [{ type: Input }],
    loaderHeight: [{ type: Input }],
    ignoreDisabledStyle: [{ type: Input }],
    finish: [{ type: Input }],
    clickEvent: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class PepMenuBlurDirective {
    constructor(element) {
        this.element = element;
    }
    menuClosedEvent() {
        setTimeout(() => {
            this.element.nativeElement.blur();
        }, 0);
    }
    menuOpenedEvent() {
        setTimeout(() => {
            this.element.nativeElement.blur();
        }, 0);
    }
}
PepMenuBlurDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepMenuBlur]',
            },] }
];
PepMenuBlurDirective.ctorParameters = () => [
    { type: ElementRef }
];
PepMenuBlurDirective.propDecorators = {
    menuClosedEvent: [{ type: HostListener, args: ['menuClosed',] }],
    menuOpenedEvent: [{ type: HostListener, args: ['menuOpened',] }]
};

class PepDataQaDirective {
    constructor(renderer, element) {
        this.renderer = renderer;
        this.element = element;
    }
    ngOnInit() {
        this.renderer.setAttribute(this.element.nativeElement, 'data-qa', this.dataQa);
    }
}
PepDataQaDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepDataQa]',
            },] }
];
PepDataQaDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef }
];
PepDataQaDirective.propDecorators = {
    dataQa: [{ type: Input, args: ['pepDataQa',] }]
};

class PepPreventMultiClickDirective {
    constructor() {
        this.disabledTime = 1000;
    }
    clickEvent(event) {
        event.srcElement.setAttribute('disabled', true);
        setTimeout(() => {
            event.srcElement.removeAttribute('disabled');
        }, this.disabledTime);
    }
}
PepPreventMultiClickDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepPreventMultiClick]',
            },] }
];
PepPreventMultiClickDirective.propDecorators = {
    disabledTime: [{ type: Input }],
    clickEvent: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class PepPrintDirective {
    constructor() {
        this._printStyle = [];
        /**
         * @memberof PepPrintDirective
         */
        this.useExistingCss = true;
        /**
         * A delay in milliseconds to force the print dialog to wait before opened. Default: 0
         *
         * @memberof PepPrintDirective
         */
        this.printDelay = 0;
        /**
         * @returns html for the given tag
         *
         * @memberof PepPrintDirective
         */
        this._styleSheetFile = '';
    }
    /**
     * @memberof PepPrintDirective
     */
    set printStyle(values) {
        for (const key in values) {
            if (values.hasOwnProperty(key)) {
                this._printStyle.push((key + JSON.stringify(values[key])).replace(/['"]+/g, ''));
            }
        }
        this.returnStyleValues();
    }
    /**
     *
     *
     * @returns the string that create the stylesheet which will be injected
     * later within <style></style> tag.
     *
     * - join/replace to transform an array objects to css-styled string
     * @memberof PepPrintDirective
     */
    returnStyleValues() {
        return `<style> ${this._printStyle.join(' ').replace(/,/g, ';')} </style>`;
    }
    /**
     * @memberof PepPrintDirective
     * @param cssList
     */
    set styleSheetFile(cssList) {
        const linkTagFn = function (cssFileName) {
            return `<link rel="stylesheet" type="text/css" href="${cssFileName}">`;
        };
        if (cssList.indexOf(',') !== -1) {
            const valueArr = cssList.split(',');
            for (const val of valueArr) {
                this._styleSheetFile = this._styleSheetFile + linkTagFn(val);
            }
        }
        else {
            this._styleSheetFile = linkTagFn(cssList);
        }
    }
    /**
     * @returns string which contains the link tags containing the css which will
     * be injected later within <head></head> tag.
     *
     */
    returnStyleSheetLinkTags() {
        return this._styleSheetFile;
    }
    getElementTag(tag) {
        const html = [];
        const elements = document.getElementsByTagName(tag);
        for (let index = 0; index < elements.length; index++) {
            html.push(elements[index].outerHTML);
        }
        return html.join('\r\n');
    }
    /**
     *
     * @param data the html element collection to save defaults to
     *
     */
    getFormData(data) {
        for (let i = 0; i < data.length; i++) {
            data[i].defaultValue = data[i].value;
            if (data[i].checked) {
                data[i].defaultChecked = true;
            }
        }
    }
    /**
     * @returns html section to be printed along with some associated inputs
     *
     */
    getHtmlContents() {
        const printContents = document.getElementById(this.printSectionId);
        const innards = printContents.getElementsByTagName('input');
        this.getFormData(innards);
        const txt = printContents.getElementsByTagName('textarea');
        this.getFormData(txt);
        return printContents.innerHTML;
    }
    /**
     * @memberof PepPrintDirective
     */
    print() {
        let styles = '', links = '';
        const baseTag = this.getElementTag('base');
        if (this.useExistingCss) {
            styles = this.getElementTag('style');
            links = this.getElementTag('link');
        }
        const printContents = this.getHtmlContents();
        const popupWin = window.open("", "_blank", "top=0,left=0,height=auto,width=auto");
        popupWin.document.open();
        popupWin.document.write(`
            <html>
                <head>
                <title>${this.printTitle ? this.printTitle : ""}</title>
                ${baseTag}
                ${this.returnStyleValues()}
                ${this.returnStyleSheetLinkTags()}
                ${styles}
                ${links}
                </head>
                <body>
                ${printContents}
                <script defer>
                    function triggerPrint(event) {
                    window.removeEventListener('load', triggerPrint, false);
                    setTimeout(function() {
                        closeWindow(window.print());
                    }, ${this.printDelay});
                    }
                    function closeWindow(){
                        window.close();
                    }
                    window.addEventListener('load', triggerPrint, false);
                </script>
                </body>
            </html>`);
        popupWin.document.close();
    }
}
PepPrintDirective.decorators = [
    { type: Directive, args: [{
                selector: "[pepPrint]"
            },] }
];
PepPrintDirective.propDecorators = {
    printSectionId: [{ type: Input }],
    printTitle: [{ type: Input }],
    useExistingCss: [{ type: Input }],
    printDelay: [{ type: Input }],
    printStyle: [{ type: Input }],
    styleSheetFile: [{ type: Input }],
    print: [{ type: HostListener, args: ['click',] }]
};

class PepPortalService {
    constructor() {
        this.targets = new Map();
    }
    addTarget(targetName, viewContainer) {
        this.targets.set(targetName, viewContainer);
    }
    attach(targetName, template) {
        const target = this.getTarget(targetName);
        if (target) {
            target.createEmbeddedView(template);
        }
    }
    clear(targetName) {
        const target = this.getTarget(targetName);
        if (target) {
            target.clear();
        }
    }
    getTarget(targetName) {
        return this.targets.has(targetName)
            ? this.targets.get(targetName)
            : null;
    }
}
PepPortalService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepPortalService_Factory() { return new PepPortalService(); }, token: PepPortalService, providedIn: "root" });
PepPortalService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepPortalService.ctorParameters = () => [];

class PepAttachDirective {
    constructor(portalService, templateRef) {
        this.portalService = portalService;
        this.templateRef = templateRef;
    }
    ngOnInit() {
        this.portalService.attach(this.targetName, this.templateRef);
    }
    ngOnDestroy() {
        this.portalService.clear(this.targetName);
    }
}
PepAttachDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepAttach]',
            },] }
];
PepAttachDirective.ctorParameters = () => [
    { type: PepPortalService },
    { type: TemplateRef }
];
PepAttachDirective.propDecorators = {
    targetName: [{ type: Input, args: ['pepAttach',] }]
};

class PepTargetDirective {
    constructor(portalService, viewContainer) {
        this.portalService = portalService;
        this.viewContainer = viewContainer;
    }
    ngOnInit() {
        this.portalService.addTarget(this.targetName, this.viewContainer);
    }
}
PepTargetDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepTarget]',
            },] }
];
PepTargetDirective.ctorParameters = () => [
    { type: PepPortalService },
    { type: ViewContainerRef }
];
PepTargetDirective.propDecorators = {
    targetName: [{ type: Input, args: ['pepTarget',] }]
};

const clipboardList = [PepClipboardDirective];
const layoutList = [PepRtlClassDirective, PepRtlDirectionDirective];
const pipeList = [
    PepCapitalizePipe,
    PepEncodePipe,
    PepEscapePipe,
    PepReplaceLineBreaksPipe,
    PepDateFormatterPipe,
    PepDateStringFormatterPipe,
    PepSafeHtmlPipe,
    PepSafePipe,
    PepSplitUppercasePipe,
    PepToNumberPipe,
];
const utilitiesList = [
    PepInputAutoWidthDirective,
    PepButtonBlurDirective,
    PepButtonLoaderDirective,
    PepMenuBlurDirective,
    PepDataQaDirective,
    // PreventDoubleClickDirective,
    PepPreventMultiClickDirective,
    PepPrintDirective,
];
const portalList = [PepAttachDirective, PepTargetDirective];
class PepNgxLibModule {
}
PepNgxLibModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    pipeList,
                    utilitiesList,
                    clipboardList,
                    layoutList,
                    portalList,
                ],
                providers: [
                    httpInterceptorProviders,
                    // TranslateService
                ],
                imports: [CommonModule, HttpClientModule, ReactiveFormsModule],
                exports: [
                    pipeList,
                    utilitiesList,
                    clipboardList,
                    layoutList,
                    portalList,
                    TranslateModule,
                ],
            },] }
];

// Import the core angular services.
class PepClipboardService {
}
PepClipboardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepClipboardService_Factory() { return new PepClipboardService(); }, token: PepClipboardService, providedIn: "root" });
PepClipboardService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

/*
 * Public API Surface of ngx-lib/core/clipboard
 */

/*
 * export from ngx-lib/core/clipboard
 */

/*
 * Public API Surface of ngx-lib/core/common/directives
 */

/*
 * export from ngx-lib/core/common/directives
 */

class Test {
}

class PepGuid {
    static pad4(num) {
        let ret = num.toString(16);
        while (ret.length < 4) {
            ret = '0' + ret;
        }
        return ret;
    }
    static random4() {
        return Math.floor((1 + Math.random()) * 0x10000)
            .toString(16)
            .substring(1);
    }
    static newGuid() {
        // This is not build for -prod
        // return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        //     const r = Math.random() * 16 | 0;
        //     const v = c === 'x' ? r : (r & 0x3 | 0x8);
        //     return v.toString(16);
        // });
        // If we have a cryptographically secure PRNG, use that
        if (typeof window !== 'undefined' &&
            typeof window.crypto !== 'undefined' &&
            typeof window.crypto.getRandomValues !== 'undefined') {
            const buf = new Uint16Array(8);
            window.crypto.getRandomValues(buf);
            return (this.pad4(buf[0]) +
                this.pad4(buf[1]) +
                '-' +
                this.pad4(buf[2]) +
                '-' +
                this.pad4(buf[3]) +
                '-' +
                this.pad4(buf[4]) +
                '-' +
                this.pad4(buf[5]) +
                this.pad4(buf[6]) +
                this.pad4(buf[7]));
        }
        else {
            // Otherwise, just use Math.random
            return (this.random4() +
                this.random4() +
                '-' +
                this.random4() +
                '-' +
                this.random4() +
                '-' +
                this.random4() +
                '-' +
                this.random4() +
                this.random4() +
                this.random4());
        }
    }
}

var FIELD_TYPE;
(function (FIELD_TYPE) {
    // specify text field
    FIELD_TYPE[FIELD_TYPE["Default"] = 0] = "Default";
    FIELD_TYPE[FIELD_TYPE["TextBox"] = 1] = "TextBox";
    FIELD_TYPE[FIELD_TYPE["LimitedLengthTextBox"] = 2] = "LimitedLengthTextBox";
    // specify text area field
    FIELD_TYPE[FIELD_TYPE["TextArea"] = 3] = "TextArea";
    FIELD_TYPE[FIELD_TYPE["TextHeader"] = 4] = "TextHeader";
    // specify date field
    FIELD_TYPE[FIELD_TYPE["Date"] = 5] = "Date";
    // specify date & time field
    FIELD_TYPE[FIELD_TYPE["DateAndTime"] = 6] = "DateAndTime";
    // specify integer field
    FIELD_TYPE[FIELD_TYPE["NumberInteger"] = 7] = "NumberInteger";
    // specify decimal field
    FIELD_TYPE[FIELD_TYPE["NumberReal"] = 8] = "NumberReal";
    // specify currency field
    FIELD_TYPE[FIELD_TYPE["Currency"] = 9] = "Currency";
    // specify boolean field
    FIELD_TYPE[FIELD_TYPE["Boolean"] = 10] = "Boolean";
    // specify multiple options field
    FIELD_TYPE[FIELD_TYPE["ComboBox"] = 11] = "ComboBox";
    // specify multiple options field
    FIELD_TYPE[FIELD_TYPE["MultiTickBox"] = 12] = "MultiTickBox";
    // specify separator (view only) field
    FIELD_TYPE[FIELD_TYPE["Separator"] = 13] = "Separator";
    // specify address field
    FIELD_TYPE[FIELD_TYPE["Address"] = 14] = "Address";
    // specify percentage field
    FIELD_TYPE[FIELD_TYPE["Percentage"] = 15] = "Percentage";
    FIELD_TYPE[FIELD_TYPE["EmptyComboBox"] = 16] = "EmptyComboBox";
    FIELD_TYPE[FIELD_TYPE["InternalLink"] = 17] = "InternalLink";
    // specify email field
    FIELD_TYPE[FIELD_TYPE["Email"] = 18] = "Email";
    FIELD_TYPE[FIELD_TYPE["LimitedDate"] = 19] = "LimitedDate";
    // specify image field
    FIELD_TYPE[FIELD_TYPE["Image"] = 20] = "Image";
    FIELD_TYPE[FIELD_TYPE["MultiTickBoxToComboBox"] = 21] = "MultiTickBoxToComboBox";
    FIELD_TYPE[FIELD_TYPE["EmptyMultiTickBox"] = 22] = "EmptyMultiTickBox";
    FIELD_TYPE[FIELD_TYPE["Totals"] = 23] = "Totals";
    // specify attachment field
    FIELD_TYPE[FIELD_TYPE["Attachment"] = 24] = "Attachment";
    FIELD_TYPE[FIELD_TYPE["Signature"] = 25] = "Signature";
    // specify link field
    FIELD_TYPE[FIELD_TYPE["Link"] = 26] = "Link";
    // specify image url field
    FIELD_TYPE[FIELD_TYPE["ImageURL"] = 27] = "ImageURL";
    FIELD_TYPE[FIELD_TYPE["NumberIntegerQuantitySelector"] = 28] = "NumberIntegerQuantitySelector";
    FIELD_TYPE[FIELD_TYPE["NumberRealQuantitySelector"] = 29] = "NumberRealQuantitySelector";
    FIELD_TYPE[FIELD_TYPE["NumberIntegerForMatrix"] = 30] = "NumberIntegerForMatrix";
    FIELD_TYPE[FIELD_TYPE["NumberRealForMatrix"] = 31] = "NumberRealForMatrix";
    FIELD_TYPE[FIELD_TYPE["Images"] = 32] = "Images";
    FIELD_TYPE[FIELD_TYPE["Indicators"] = 33] = "Indicators";
    FIELD_TYPE[FIELD_TYPE["CalculatedReal"] = 34] = "CalculatedReal";
    FIELD_TYPE[FIELD_TYPE["CalculatedInt"] = 35] = "CalculatedInt";
    FIELD_TYPE[FIELD_TYPE["CalculatedString"] = 36] = "CalculatedString";
    FIELD_TYPE[FIELD_TYPE["CalculatedDate"] = 37] = "CalculatedDate";
    FIELD_TYPE[FIELD_TYPE["CalculatedBool"] = 38] = "CalculatedBool";
    FIELD_TYPE[FIELD_TYPE["MapDataDropDown"] = 39] = "MapDataDropDown";
    FIELD_TYPE[FIELD_TYPE["MapDataReal"] = 40] = "MapDataReal";
    FIELD_TYPE[FIELD_TYPE["MapDataString"] = 41] = "MapDataString";
    FIELD_TYPE[FIELD_TYPE["MapDataInt"] = 42] = "MapDataInt";
    FIELD_TYPE[FIELD_TYPE["Sum"] = 43] = "Sum";
    FIELD_TYPE[FIELD_TYPE["Phone"] = 44] = "Phone";
    FIELD_TYPE[FIELD_TYPE["UrlForApi"] = 45] = "UrlForApi";
    FIELD_TYPE[FIELD_TYPE["ManyToManyUrlForApi"] = 46] = "ManyToManyUrlForApi";
    FIELD_TYPE[FIELD_TYPE["ReferenceType"] = 47] = "ReferenceType";
    FIELD_TYPE[FIELD_TYPE["GuidReferenceType"] = 48] = "GuidReferenceType";
    FIELD_TYPE[FIELD_TYPE["Button"] = 49] = "Button";
    FIELD_TYPE[FIELD_TYPE["InternalPage"] = 50] = "InternalPage";
    FIELD_TYPE[FIELD_TYPE["Duration"] = 51] = "Duration";
    FIELD_TYPE[FIELD_TYPE["ListOfObjects"] = 52] = "ListOfObjects";
    FIELD_TYPE[FIELD_TYPE["Package"] = 53] = "Package";
    FIELD_TYPE[FIELD_TYPE["BooleanText"] = 55] = "BooleanText";
    FIELD_TYPE[FIELD_TYPE["RichTextHTML"] = 56] = "RichTextHTML";
})(FIELD_TYPE || (FIELD_TYPE = {}));
var X_ALIGNMENT_TYPE;
(function (X_ALIGNMENT_TYPE) {
    X_ALIGNMENT_TYPE[X_ALIGNMENT_TYPE["None"] = 0] = "None";
    X_ALIGNMENT_TYPE[X_ALIGNMENT_TYPE["Left"] = 1] = "Left";
    X_ALIGNMENT_TYPE[X_ALIGNMENT_TYPE["Right"] = 2] = "Right";
    X_ALIGNMENT_TYPE[X_ALIGNMENT_TYPE["Center"] = 3] = "Center";
})(X_ALIGNMENT_TYPE || (X_ALIGNMENT_TYPE = {}));
var Y_ALIGNMENT_TYPE;
(function (Y_ALIGNMENT_TYPE) {
    Y_ALIGNMENT_TYPE[Y_ALIGNMENT_TYPE["None"] = 0] = "None";
    Y_ALIGNMENT_TYPE[Y_ALIGNMENT_TYPE["Top"] = 1] = "Top";
    Y_ALIGNMENT_TYPE[Y_ALIGNMENT_TYPE["Bottom"] = 2] = "Bottom";
    Y_ALIGNMENT_TYPE[Y_ALIGNMENT_TYPE["Center"] = 3] = "Center";
})(Y_ALIGNMENT_TYPE || (Y_ALIGNMENT_TYPE = {}));
class FieldLayout {
    // constructor(
    //     x = 0,
    //     width = 1,
    //     xAlignment: X_ALIGNMENT_TYPE = 1, y: Y_ALIGNMENT_TYPE = 0, height = 1, yAlignment = 1, lineNumber = 1) {
    //     this.X = x;
    //     this.Width = width;
    //     this.XAlignment = xAlignment;
    //     this.Y = y;
    //     this.Height = height;
    //     this.YAlignment = yAlignment;
    //     this.LineNumber = lineNumber;
    // }
    constructor(data) {
        Object.assign(this, data);
    }
}
class UIControlField {
    constructor() {
        this.MandatoryField = false;
        this.Mandatory = false;
        this.minFieldWidth = 45;
        this.calcColumnWidth = 10;
        this.calcTitleColumnWidthString = '100%';
        this.calcColumnWidthString = '100%';
    }
}
class UIControl {
}
class ObjectsDataRowCell {
}
class ObjectsDataRow {
    constructor() {
        this.IsEditable = true;
        this.IsSelectableForActions = true;
    }
}
class ObjectSingleData {
    constructor(uiControl = null, data = null) {
        this.Success = true;
        this.ErrorMessage = '';
        this.Type = '';
        this.UIControl = uiControl;
        this.Data = data;
    }
}
class ObjectsData {
    // AllRows: Array<ObjectsDataRow>;
    // TotalAmount: any;
    // CurrencySymbol: any;
    constructor() {
        this.ErrorMessage = '';
        this.Success = true;
        // this.TotalAmount = '0';
        // this.CurrencySymbol = '$';
    }
}
class SmartSearchValues {
}
class SmartSearchResponse {
}
class KeyValuePair {
}

/*
 * Public API Surface of ngx-lib/core/common/model
 */

/*
 * export from ngx-lib/core/common/model
 */

/*
 * Public API Surface of ngx-lib/core/common/pipes
 */

/*
 * export from ngx-lib/core/common/pipes
 */

class PepJwtHelperService {
    urlBase64Decode(str) {
        let output = str.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new Error('Illegal base64url string!');
            }
        }
        return this.b64DecodeUnicode(output);
    }
    // credits for decoder goes to https://github.com/atk
    b64decode(str) {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        let output = '';
        str = String(str).replace(/=+$/, '');
        if (str.length % 4 === 1) {
            throw new Error("'atob' failed: The string to be decoded is not correctly encoded.");
        }
        for (
        // initialize result and counters
        let bc = 0, bs, buffer, idx = 0; 
        // get next character
        (buffer = str.charAt(idx++)); 
        // character found in table? initialize bit storage and add its ascii value;
        ~buffer &&
            ((bs = bc % 4 ? bs * 64 + buffer : buffer),
                // and if not first of each 4 characters,
                // convert the first 8 bits to one ascii character
                bc++ % 4)
            ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))
            : 0) {
            // try to find character in table (0-63, not found => -1)
            buffer = chars.indexOf(buffer);
        }
        return output;
    }
    b64DecodeUnicode(str) {
        return decodeURIComponent(Array.prototype.map
            .call(this.b64decode(str), (c) => {
            return ('%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2));
        })
            .join(''));
    }
    decodeToken(token) {
        if (!token || token === '') {
            return null;
        }
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error("The inspected token doesn't appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.");
        }
        const decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token.');
        }
        return JSON.parse(decoded);
    }
    getTokenExpirationDate(token) {
        const decoded = this.decodeToken(token);
        if (!decoded || !decoded.hasOwnProperty('exp')) {
            return null;
        }
        const date = new Date(0);
        date.setUTCSeconds(decoded.exp);
        return date;
    }
    isTokenExpired(token, offsetSeconds) {
        if (!token || token === '') {
            return true;
        }
        const date = this.getTokenExpirationDate(token);
        offsetSeconds = offsetSeconds || 0;
        if (date === null) {
            return false;
        }
        return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);
    }
    getAuthScheme(authScheme, request) {
        if (typeof authScheme === 'function') {
            return authScheme(request);
        }
        return authScheme;
    }
}
PepJwtHelperService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepJwtHelperService_Factory() { return new PepJwtHelperService(); }, token: PepJwtHelperService, providedIn: "root" });
PepJwtHelperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

class PepSessionService {
    // private readonly PEPPERI_CONSUMER_TOKEN: 'YY2pAwx6Exo2LWXrUllF9xzSfWF53wqc';
    constructor(jwtHelper) {
        this.jwtHelper = jwtHelper;
        this.IDP_TOKEN_KEY = 'idp_token';
        this.PAPI_BASE_URL_KEY = 'pepperi.baseurl';
        // private readonly WAPI_TOKEN_KEY = 'auth_token';
        this.WAPI_BASE_URL_KEY = 'serverHostURL'; // pepperi.webapibaseurl
    }
    getParseToken() {
        // debugger;
        // const tokenTest = "eyJhbGciOiJSUzI1NiIsImtpZCI6IjRiYTFjNzJmMTI3NThjYzEzMzg3ZWQ3YTBiZjNlODg3IiwidHlwIjoiSldUIn0.eyJuYmYiOjE1OTY3MjU5NjksImV4cCI6MTU5NjcyNjI2OSwiaXNzIjoiaHR0cHM6Ly9pZHAuc2FuZGJveC5wZXBwZXJpLmNvbSIsImF1ZCI6InBlcHBlcmkud2ViYXBwLmFwcC5zYW5kYm94LnBlcHBlcmkuY29tIiwiaWF0IjoxNTk2NzI1OTY5LCJhdF9oYXNoIjoiSGtmRXJ0Q2JzQ3NzOTVKUm05VmJTdyIsInNpZCI6IjJkNzFiM2JiNWUyNjRiNDk2Y2JmZDkzNmYyNTNhNWIzIiwic3ViIjoiZTJkZmQ0MDYtZDM4Yy00ZmYwLThhZGItMWRlMjI3ODIzYWEyIiwiYXV0aF90aW1lIjoxNTk2NzE4ODA5LCJpZHAiOiJsb2NhbCIsIm5hbWUiOiJkYW5pZWwgZGF2aWRvZmYiLCJlbWFpbCI6ImRhbmllbC5kQHBlcHBlcml0ZXN0LmNvbSIsInBlcHBlcmkuaWQiOjg2OTAzMDQsInBlcHBlcmkudXNlcnV1aWQiOiJlMmRmZDQwNi1kMzhjLTRmZjAtOGFkYi0xZGUyMjc4MjNhYTIiLCJwZXBwZXJpLmRpc3RyaWJ1dG9yaWQiOjMwMDEyMzUxLCJwZXBwZXJpLmRpc3RyaWJ1dG9ydXVpZCI6IjBiZDBlZDc5LThlOWUtNDRmYi05NmY0LThlNTNlZDljZTgyYiIsInBlcHBlcmkuZGF0YWNlbnRlciI6InNhbmRib3giLCJwZXBwZXJpLmtlZXBsb2dpbiI6ZmFsc2UsInBlcHBlcmkuaWRsZXRpbWV3ZWIiOjEyMCwidXBkYXRlZF9hdCI6MTU5NjcwMjgwMCwiZ2l2ZW5fbmFtZSI6ImRhbmllbCIsImZhbWlseV9uYW1lIjoiZGF2aWRvZmYiLCJwZXBwZXJpLmFwaW50YmFzZXVybCI6Imh0dHBzOi8vcmVzdGFwaS5zYW5kYm94LnBlcHBlcmkuY29tIiwicGVwcGVyaS53ZWJhcGliYXNldXJsIjoiaHR0cHM6Ly93ZWJhcGkuc2FuZGJveC5wZXBwZXJpLmNvbS9WMTZfNTAvV2ViQXBwXzYiLCJwZXBwZXJpLnB1YmxpY2FwaWJhc2V1cmwiOiJodHRwczovL2FwaS1zYW5kYm94LnBlcHBlcmkuY29tIiwicGVwcGVyaS5iYXNldXJsIjoiaHR0cHM6Ly9wYXBpLnNhbmRib3gucGVwcGVyaS5jb20vVjEuMCIsInBlcHBlcmkuZW1wbG95ZWV0eXBlIjoxLCJhbXIiOlsicHdkIl19.tNtZT3Cl4dMmTQftoaO2KP5BvHOlWGIP-5GpHrAhZoymBkxBSxpKprQGqr0ATtQlNHjX3gDV1W6k_avaSkyJgDiB2hcwr1tNRilasNuMzNV93gxLC9Oh_HdkIN4cZ0hahIcJvf_17PHpS8zD_MRwvGG_i45wRYJAtiGXChxCMzooethRsLOq5TEwuNbE3MxdjZOpImGYyytmsfdsdJRWQn1LQwQBt95ssuypcUzBsVB34P5XuFttjAe9dhTwHIfgsPG-VdfAWH_r-hVe834wKpKrplSWlC_MucgS0X4XP_tN4CtLnHO2wXKPsojqSTH2NQycfqh6YvT6rzRDBEdQIQ";
        const token = this.getIdpToken();
        // token = token || tokenTest;
        const decodedToken = this.jwtHelper.decodeToken(token);
        // const expirationDate = this.jwtHelper.getTokenExpirationDate(token);
        // const isExpired = this.jwtHelper.isTokenExpired(token);
        return decodedToken;
    }
    setObject(key, object) {
        const stringifiedObject = typeof object === 'string' || object instanceof String
            ? object
            : JSON.stringify(object);
        sessionStorage.setItem(key, stringifiedObject.toString());
    }
    getObject(key) {
        let result = null;
        const item = sessionStorage.getItem(key);
        try {
            result = item ? JSON.parse(item) : item;
        }
        catch (_a) {
            result = item;
        }
        return result;
    }
    // setObject(key: string, value: string): void {
    //     sessionStorage.setItem(key, value);
    // }
    // getObject(key: string): string | null {
    //     return sessionStorage.getItem(key);
    // }
    removeObject(key) {
        sessionStorage.removeItem(key);
    }
    // getWapiToken(): string {
    //     return this.getObject(this.WAPI_TOKEN_KEY);
    // }
    getWapiBaseUrl() {
        return this.getObject(this.WAPI_BASE_URL_KEY);
    }
    getIdpToken() {
        return this.getObject(this.IDP_TOKEN_KEY);
    }
    getPapiBaseUrl() {
        const tokenObj = this.getParseToken();
        return tokenObj ? tokenObj[this.PAPI_BASE_URL_KEY] : null;
    }
}
PepSessionService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepSessionService_Factory() { return new PepSessionService(i0.ɵɵinject(PepJwtHelperService)); }, token: PepSessionService, providedIn: "root" });
PepSessionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepSessionService.ctorParameters = () => [
    { type: PepJwtHelperService }
];

class PepCookieService {
    constructor(document, platformId) {
        this.document = document;
        this.platformId = platformId;
        this.documentIsAccessible = isPlatformBrowser(this.platformId);
    }
    /**
     * @param name Cookie name
     * @returns boolean - whether cookie with specified name exists
     */
    check(name) {
        if (!this.documentIsAccessible) {
            return false;
        }
        name = encodeURIComponent(name);
        const regExp = this.getCookieRegExp(name);
        const exists = regExp.test(this.document.cookie);
        return exists;
    }
    /**
     * @param name Cookie name
     * @returns property value
     */
    get(name) {
        if (this.documentIsAccessible && this.check(name)) {
            name = encodeURIComponent(name);
            const regExp = this.getCookieRegExp(name);
            const result = regExp.exec(this.document.cookie);
            return this.safeDecodeURIComponent(result[1]);
        }
        else {
            return '';
        }
    }
    /**
     * @returns all the cookies in json
     */
    getAll() {
        if (!this.documentIsAccessible) {
            return {};
        }
        const cookies = {};
        const document = this.document;
        if (document.cookie && document.cookie !== '') {
            document.cookie.split(';').forEach((currentCookie) => {
                const [cookieName, cookieValue] = currentCookie.split('=');
                cookies[this.safeDecodeURIComponent(cookieName.replace(/^ /, ''))] = this.safeDecodeURIComponent(cookieValue);
            });
        }
        return cookies;
    }
    /**
     * @param name     Cookie name
     * @param value    Cookie value
     * @param expires  Number of days until the cookies expires or an actual `Date`
     * @param path     Cookie path
     * @param domain   Cookie domain
     * @param secure   Secure flag
     * @param sameSite OWASP samesite token `Lax`, `None`, or `Strict`. Defaults to `Lax`
     */
    set(name, value, expires, path, domain, secure, sameSite = 'Lax') {
        if (!this.documentIsAccessible) {
            return;
        }
        let cookieString = encodeURIComponent(name) + '=' + encodeURIComponent(value) + ';';
        if (expires) {
            if (typeof expires === 'number') {
                const dateExpires = new Date(new Date().getTime() + expires * 1000 * 60 * 60 * 24);
                cookieString += 'expires=' + dateExpires.toUTCString() + ';';
            }
            else {
                cookieString += 'expires=' + expires.toUTCString() + ';';
            }
        }
        if (path) {
            cookieString += 'path=' + path + ';';
        }
        if (domain) {
            cookieString += 'domain=' + domain + ';';
        }
        if (secure === false && sameSite === 'None') {
            secure = true;
        }
        if (secure) {
            cookieString += 'secure;';
        }
        cookieString += 'sameSite=' + sameSite + ';';
        this.document.cookie = cookieString;
    }
    /**
     * @param name   Cookie name
     * @param path   Cookie path
     * @param domain Cookie domain
     */
    delete(name, path, domain, secure, sameSite = 'Lax') {
        if (!this.documentIsAccessible) {
            return;
        }
        this.set(name, '', new Date('Thu, 01 Jan 1970 00:00:01 GMT'), path, domain, secure, sameSite);
    }
    /**
     * @param path   Cookie path
     * @param domain Cookie domain
     */
    deleteAll(path, domain, secure, sameSite = 'Lax') {
        if (!this.documentIsAccessible) {
            return;
        }
        const cookies = this.getAll();
        for (const cookieName in cookies) {
            if (cookies.hasOwnProperty(cookieName)) {
                this.delete(cookieName, path, domain, secure, sameSite);
            }
        }
    }
    /**
     * @param name Cookie name
     * @returns property RegExp
     */
    getCookieRegExp(name) {
        const escapedName = name.replace(/([\[\]\{\}\(\)\|\=\;\+\?\,\.\*\^\$])/gi, '\\$1');
        return new RegExp('(?:^' + escapedName + '|;\\s*' + escapedName + ')=(.*?)(?:;|$)', 'g');
    }
    safeDecodeURIComponent(encodedURIComponent) {
        try {
            return decodeURIComponent(encodedURIComponent);
        }
        catch (_a) {
            // probably it is not uri encoded. return as is
            return encodedURIComponent;
        }
    }
}
PepCookieService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepCookieService_Factory() { return new PepCookieService(i0.ɵɵinject(i1$1.DOCUMENT, 8), i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PepCookieService, providedIn: "root" });
PepCookieService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepCookieService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },
    { type: InjectionToken, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

class PepHttpService {
    constructor(sessionService, cookieService, http) {
        this.sessionService = sessionService;
        this.cookieService = cookieService;
        this.http = http;
        this.AUTH_HEADER = 'Authorization';
        this.PEPPERI_TOKEN_HEADER = 'PepperiSessionToken';
        this.WAPI_TOKEN_KEY = 'auth_token';
        this.PEPPERI_TOKEN_COOKIE = 'PepperiUserSettings';
    }
    handleError(response) {
        let errorMessage = 'Unknown error!';
        if (response.error instanceof ErrorEvent) {
            // Client-side errors
            errorMessage = `Error: ${response.error.message}`;
        }
        else {
            // Server-side errors
            errorMessage = this.getServerErrorMessage(response);
        }
        return throwError(errorMessage);
    }
    getServerErrorMessage(response) {
        var _a, _b;
        if ((_b = (_a = response === null || response === void 0 ? void 0 : response.error) === null || _a === void 0 ? void 0 : _a.fault) === null || _b === void 0 ? void 0 : _b.faultstring) {
            return `${response.error.fault.faultstring}`;
        }
        else {
            switch (response.status) {
                case 404: {
                    return `Not Found: ${response.message}`;
                }
                case 403: {
                    return `Access Denied: ${response.message}`;
                }
                case 500: {
                    return `Internal Server Error: ${response.message}`;
                }
                default: {
                    return `Unknown Server Error\nError Code: ${response.status}\nMessage: ${response.message}`;
                }
            }
        }
    }
    // Add authorization token if the token exist.
    addAuthorizationToken(httpOptions = {}) {
        if (!httpOptions.headers.has(this.AUTH_HEADER)) {
            const idpToken = this.sessionService.getIdpToken();
            if (idpToken) {
                httpOptions.headers = httpOptions.headers.set(this.AUTH_HEADER, `Bearer ${idpToken}`);
            }
        }
        return httpOptions;
    }
    // Add web api token if calling to wapi domain.
    addWebApiToken(url, httpOptions = {}) {
        if (!httpOptions.headers.has(this.PEPPERI_TOKEN_HEADER)) {
            const wapiBaseUrl = this.sessionService.getWapiBaseUrl();
            if (wapiBaseUrl && url.match(new RegExp(wapiBaseUrl, 'g'))) {
                // TODO:
                // const webApiToken = this.sessionService.getWapiToken();
                try {
                    const userSettingCookie = this.cookieService.get(this.PEPPERI_TOKEN_COOKIE);
                    const webApiToken = JSON.parse(userSettingCookie).values
                        .items[this.WAPI_TOKEN_KEY];
                    if (webApiToken) {
                        httpOptions.headers = httpOptions.headers.set(this.PEPPERI_TOKEN_HEADER, webApiToken);
                    }
                }
                catch (_a) {
                    // Do nothing.
                }
            }
        }
        return httpOptions;
    }
    setDefaultHeaderOptions(url, httpOptions = {}) {
        if (!httpOptions.headers) {
            httpOptions.headers = new HttpHeaders();
        }
        // Add content type
        if (!httpOptions.headers.has('Content-Type')) {
            httpOptions.headers = httpOptions.headers.set('Content-Type', 'application/json');
        }
        httpOptions = this.addAuthorizationToken(httpOptions);
        httpOptions = this.addWebApiToken(url, httpOptions);
        return httpOptions;
    }
    // getTextFile(filename: string): void {
    //     // The Observable returned by get() is of type Observable<string>
    //     // because a text response was specified.
    //     // There's no need to pass a <string> type parameter to get().
    //     // return this.http.get(filename, {responseType: 'text'})
    //     //     .pipe(
    //     //         tap( // Log the result or error
    //     //         data => this.log(filename, data),
    //     //         error => this.logError(filename, error)
    //     //         )
    //     // );
    // }
    getHttpCall(url, httpOptions = {}) {
        httpOptions = this.setDefaultHeaderOptions(url, httpOptions);
        return this.http
            .get(url, httpOptions)
            .pipe(catchError(this.handleError.bind(this)));
        //     .subscribe(
        //         (res) => console.log(''),
        //         (error) => console.log(''),
        //         () => {}
        // );
    }
    postHttpCall(url, body, httpOptions = {}) {
        httpOptions = this.setDefaultHeaderOptions(url, httpOptions);
        return this.http
            .post(url, body, httpOptions)
            .pipe(catchError(this.handleError.bind(this)));
        //     .subscribe(
        //         (res) => console.log(''),
        //         (error) => console.log(''),
        //         () => {}
        // );
    }
    getWapiApiCall(url, httpOptions = {}) {
        const wapiBaseUrl = this.sessionService.getWapiBaseUrl();
        return this.getHttpCall(`${wapiBaseUrl}${url}`, httpOptions);
    }
    postWapiApiCall(url, body, httpOptions = {}) {
        const wapiBaseUrl = this.sessionService.getWapiBaseUrl();
        return this.postHttpCall(`${wapiBaseUrl}${url}`, body, httpOptions);
    }
    getPapiApiCall(url, httpOptions = {}) {
        const papiBaseUrl = this.sessionService.getPapiBaseUrl();
        return this.getHttpCall(`${papiBaseUrl}${url}`, httpOptions);
    }
    postPapiApiCall(url, body, httpOptions = {}) {
        const papiBaseUrl = this.sessionService.getPapiBaseUrl();
        return this.postHttpCall(`${papiBaseUrl}${url}`, body, httpOptions);
    }
}
PepHttpService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepHttpService_Factory() { return new PepHttpService(i0.ɵɵinject(PepSessionService), i0.ɵɵinject(PepCookieService), i0.ɵɵinject(i3.HttpClient)); }, token: PepHttpService, providedIn: "root" });
PepHttpService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepHttpService.ctorParameters = () => [
    { type: PepSessionService },
    { type: PepCookieService },
    { type: HttpClient }
];

/*
    This service is the webapp api for addon usege.
*/
class PepAddonService {
    constructor(sessionService, httpService, loaderService) {
        this.sessionService = sessionService;
        this.httpService = httpService;
        this.loaderService = loaderService;
        this.ADDON_ASSETS_PATH_KEY = 'AddonAssetsPath';
        this.ADDONS_DICTIONARY_ASSETS_PATH_KEY = 'AddonsDictionaryAssetsPath';
        this.ADDON_API_RELATIVE_PATH = '/addons/api';
        this.ADDON_API_ASYNC_RELATIVE_PATH = `${this.ADDON_API_RELATIVE_PATH}/async`;
        //
    }
    getAddonBaseRelativePath(isAsync) {
        return isAsync
            ? this.ADDON_API_ASYNC_RELATIVE_PATH
            : this.ADDON_API_RELATIVE_PATH;
    }
    getAddonStaticFolder(subAddonUUID = '') {
        if (subAddonUUID.length > 0) {
            const addonsDictionary = this.sessionService.getObject(this.ADDONS_DICTIONARY_ASSETS_PATH_KEY);
            return addonsDictionary && addonsDictionary[subAddonUUID] ? addonsDictionary[subAddonUUID] : '';
        }
        else {
            return this.sessionService.getObject(this.ADDON_ASSETS_PATH_KEY) || '';
        }
    }
    setAddonStaticFolder(path, subAddonUUID = '') {
        var _a;
        if (subAddonUUID.length > 0) {
            const addonsDictionary = (_a = this.sessionService.getObject(this.ADDONS_DICTIONARY_ASSETS_PATH_KEY)) !== null && _a !== void 0 ? _a : {};
            addonsDictionary[subAddonUUID] = path;
            this.sessionService.setObject(this.ADDONS_DICTIONARY_ASSETS_PATH_KEY, addonsDictionary);
        }
        else {
            return this.sessionService.setObject(this.ADDON_ASSETS_PATH_KEY, path);
        }
    }
    getAddonApiCall(addonUUID, fileName, functionName, httpOptions = {}, isAsync = false) {
        return this.httpService.getPapiApiCall(`${this.getAddonBaseRelativePath(isAsync)}/${addonUUID}/${fileName}/${functionName}`, httpOptions);
    }
    postAddonApiCall(addonUUID, fileName, functionName, body = {}, httpOptions = {}, isAsync = false) {
        return this.httpService.postPapiApiCall(`${this.getAddonBaseRelativePath(isAsync)}/${addonUUID}/${fileName}/${functionName}`, body, httpOptions);
    }
    // TODO: need to chek this if the loader is working.
    fetch(input, init) {
        this.loaderService.show();
        return window.fetch(input, init).finally(() => {
            this.loaderService.hide();
        });
    }
    static createDefaultMultiTranslateLoader(http, fileService, addonService, subAddonUUID = '') {
        const addonStaticFolder = addonService.getAddonStaticFolder(subAddonUUID);
        const translationsPath = fileService.getAssetsTranslationsPath(addonStaticFolder);
        const translationsSuffix = fileService.getAssetsTranslationsSuffix();
        const defaultSubFolder = 'assets/i18n/';
        return new MultiTranslateHttpLoader(http, [
            {
                prefix: translationsPath,
                suffix: translationsSuffix,
            },
            {
                prefix: addonStaticFolder.length > 0 ? `${addonStaticFolder}${defaultSubFolder}` : `/${defaultSubFolder}`,
                suffix: '.json',
            },
        ]);
    }
    setDefaultTranslateLang(translate, urlLangParam = 'userLang') {
        let userLang = 'en';
        translate.setDefaultLang(userLang);
        userLang = translate.getBrowserLang().split('-')[0]; // use navigator lang if available
        if (urlLangParam.length > 0) {
            const index = location.href.indexOf(urlLangParam);
            if (index > -1) {
                // urlLangParam=XX
                const startIndex = index + urlLangParam.length + '='.length;
                userLang = location.href.substring(startIndex, startIndex + 2);
            }
        }
        // the lang to use, if the lang isn't available, it will use the current loader to get them
        translate.use(userLang).subscribe((res) => {
            // In here you can put the code you want. At this point the lang will be loaded
        });
    }
}
PepAddonService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepAddonService_Factory() { return new PepAddonService(i0.ɵɵinject(PepSessionService), i0.ɵɵinject(PepHttpService), i0.ɵɵinject(PepLoaderService)); }, token: PepAddonService, providedIn: "root" });
PepAddonService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepAddonService.ctorParameters = () => [
    { type: PepSessionService },
    { type: PepHttpService },
    { type: PepLoaderService }
];

class PepColorService {
    constructor() {
        this.FLOAT_REGEX = /^\d+(\.\d+)?$/;
        this.THREE_DIGIT_HEX_COLOR_REGEX = /^[0-9a-fA-F]{3}$/;
        this.THREE_DIGIT_HEX_COLOR_WITH_HASH_REGEX = /^#[0-9a-fA-F]{3}$/;
        this.SIX_DIGIT_HEX_COLOR_REGEX = /^[0-9a-fA-F]{6}$/;
        this.SIX_DIGIT_HEX_COLOR_WITH_HASH_REGEX = /^#[0-9a-fA-F]{6}$/;
    }
    /**
     * Convert hex string to 6 digits hex string.
     * @param str The string to convert.
     */
    hex2sixDigitHex(str) {
        if (!str) {
            return null;
        }
        str = str.trim();
        if (this.SIX_DIGIT_HEX_COLOR_WITH_HASH_REGEX.test(str)) {
            return str;
        }
        if (this.SIX_DIGIT_HEX_COLOR_REGEX.test(str)) {
            return '#' + str;
        }
        if (this.THREE_DIGIT_HEX_COLOR_WITH_HASH_REGEX.test(str)) {
            return '#' + str[1] + str[1] + str[2] + str[2] + str[3] + str[3];
        }
        if (this.THREE_DIGIT_HEX_COLOR_REGEX.test(str)) {
            return '#' + str[0] + str[0] + str[1] + str[1] + str[2] + str[2];
        }
        return null;
    }
    /**
     * Convert rgb color to 6 digits hex string.
     * @param color The rgb color to convert.
     */
    rgb2sixDigitHex(color) {
        color.r = color.r.toString(16);
        color.g = color.g.toString(16);
        color.b = color.b.toString(16);
        if (color.r.length === 1) {
            color.r = '0' + color.r;
        }
        if (color.g.length === 1) {
            color.g = '0' + color.g;
        }
        if (color.b.length === 1) {
            color.b = '0' + color.b;
        }
        return '#' + color.r + color.g + color.b;
    }
    /**
     * Convert hex string to rgb color.
     * @param str The hex string to convert.
     */
    hex2rgb(str) {
        const sixDigitHex = this.hex2sixDigitHex(str);
        if (sixDigitHex === null) {
            return null;
        }
        return {
            r: parseInt(sixDigitHex.slice(1, 3), 16),
            g: parseInt(sixDigitHex.slice(3, 5), 16),
            b: parseInt(sixDigitHex.slice(5, 7), 16),
        };
    }
    rgbString2hsl(str) {
        const sep = str.indexOf(',') > -1 ? ',' : ' ';
        const rgbArr = str.substr(4).split(')')[0].split(sep);
        const r = rgbArr[0];
        const g = rgbArr[1].substr(0, rgbArr[1].length).trim();
        const b = rgbArr[2].substr(0, rgbArr[2].length).trim();
        return this.rgb2hsl({ r, g, b });
    }
    rgb2hsl({ r, g, b }) {
        r /= 255;
        g /= 255;
        b /= 255;
        // Find greatest and smallest channel values
        const cmin = Math.min(r, g, b);
        const cmax = Math.max(r, g, b);
        const delta = cmax - cmin;
        let h = 0;
        let s = 0;
        let l = 0;
        if (delta === 0) {
            h = 0;
        }
        else if (cmax === r) {
            h = ((g - b) / delta) % 6;
        }
        else if (cmax === g) {
            h = (b - r) / delta + 2;
        }
        else {
            h = (r - g) / delta + 4;
        }
        h = Math.round(h * 60);
        if (h < 0) {
            h += 360;
        }
        l = (cmax + cmin) / 2;
        s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
        s = +(s * 100).toFixed(1);
        l = +(l * 100).toFixed(1);
        return { h, s, l };
    }
    hslString2hsl(str) {
        const sep = str.indexOf(',') > -1 ? ',' : ' ';
        const hslArr = str.substr(4).split(')')[0].split(sep);
        let h = hslArr[0];
        let s = hslArr[1].substr(0, hslArr[1].length).trim();
        let l = hslArr[2].substr(0, hslArr[2].length).trim();
        // Strip label and convert to degrees (if necessary)
        if (h.indexOf('deg') > -1) {
            h = h.substr(0, h.length - 3);
        }
        else if (h.indexOf('rad') > -1) {
            h = Math.round(h.substr(0, h.length - 3) * (180 / Math.PI));
        }
        else if (h.indexOf('turn') > -1) {
            h = Math.round(h.substr(0, h.length - 4) * 360);
        }
        // Keep hue fraction of 360 if ending up over
        if (h >= 360) {
            h %= 360;
        }
        // Remove the %
        if (s.indexOf('%') > -1) {
            s = s.replace(/%/g, '');
        }
        // Remove the %
        if (l.indexOf('%') > -1) {
            l = l.replace(/%/g, '');
        }
        return { h, s, l };
    }
    hsl2rgb({ h, s, l }) {
        let r;
        let g;
        let b;
        if (!isFinite(h)) {
            h = 0;
        }
        if (!isFinite(s)) {
            s = 0;
        }
        if (!isFinite(l)) {
            l = 0;
        }
        h /= 60;
        if (h < 0) {
            h = 6 - (-h % 6);
        }
        h %= 6;
        s = Math.max(0, Math.min(1, s / 100));
        l = Math.max(0, Math.min(1, l / 100));
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h % 2) - 1));
        if (h < 1) {
            r = c;
            g = x;
            b = 0;
        }
        else if (h < 2) {
            r = x;
            g = c;
            b = 0;
        }
        else if (h < 3) {
            r = 0;
            g = c;
            b = x;
        }
        else if (h < 4) {
            r = 0;
            g = x;
            b = c;
        }
        else if (h < 5) {
            r = x;
            g = 0;
            b = c;
        }
        else {
            r = c;
            g = 0;
            b = x;
        }
        const m = l - c / 2;
        r = Math.round((r + m) * 255);
        g = Math.round((g + m) * 255);
        b = Math.round((b + m) * 255);
        return { r, g, b };
    }
    hex2hsl(str) {
        const sixDigitHex = this.hex2sixDigitHex(str);
        if (sixDigitHex === null) {
            return null;
        }
        const rgb = this.hex2rgb(sixDigitHex);
        if (rgb === null) {
            return null;
        }
        return this.rgb2hsl(rgb);
    }
    hsl2hex(hsl) {
        const rgb = this.hsl2rgb(hsl);
        return this.rgb2sixDigitHex(rgb);
    }
    relativeLuminance({ r, g, b }) {
        [r, g, b] = [r, g, b].map((c) => {
            c = c / 255;
            if (c <= 0.03928) {
                return c / 12.92;
            }
            return Math.pow((c + 0.055) / 1.055, 2.4);
        });
        return 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
    contrast(str1, str2) {
        const L1 = this.relativeLuminance(this.hex2rgb(str1));
        const L2 = this.relativeLuminance(this.hex2rgb(str2));
        if (L1 < L2) {
            return (L2 + 0.05) / (L1 + 0.05);
        }
        return (L1 + 0.05) / (L2 + 0.05);
    }
    findClosestAccessibleDarkerColor(adjustableColor, otherColor, contrastRatio) {
        const { h, s, l } = this.hex2hsl(adjustableColor);
        if (this.contrast(adjustableColor, otherColor) >= contrastRatio) {
            return {
                color: adjustableColor,
                lightness: l,
            };
        }
        let minColor = this.hsl2hex({ h, s, l: 0 });
        if (this.contrast(minColor, otherColor) < contrastRatio) {
            return null;
        }
        let min = 0;
        let max = l;
        let maxColor = this.hsl2hex({ h, s, l });
        let lastMinColor;
        let lastMaxColor;
        let lTemp;
        while (minColor !== lastMinColor || maxColor !== lastMaxColor) {
            lastMinColor = minColor;
            lastMaxColor = maxColor;
            lTemp = (min + max) / 2;
            adjustableColor = this.hsl2hex({ h, s, l: lTemp });
            if (this.contrast(adjustableColor, otherColor) < contrastRatio) {
                max = lTemp;
                maxColor = this.hsl2hex({ h, s, l: lTemp });
            }
            else {
                min = lTemp;
                minColor = this.hsl2hex({ h, s, l: lTemp });
            }
        }
        return {
            color: minColor,
            lightness: min,
        };
    }
    findClosestAccessibleLighterColor(adjustableColor, otherColor, contrastRatio) {
        const { h, s, l } = this.hex2hsl(adjustableColor);
        if (this.contrast(adjustableColor, otherColor) >= contrastRatio) {
            return {
                color: adjustableColor,
                lightness: l,
            };
        }
        let maxColor = this.hsl2hex({ h, s, l: 100 });
        if (this.contrast(maxColor, otherColor) < contrastRatio) {
            return null;
        }
        let min = l;
        let max = 100;
        let minColor = this.hsl2hex({ h, s, l });
        let lastMinColor;
        let lastMaxColor;
        let lTemp;
        while (minColor !== lastMinColor || maxColor !== lastMaxColor) {
            lastMinColor = minColor;
            lastMaxColor = maxColor;
            lTemp = (min + max) / 2;
            adjustableColor = this.hsl2hex({ h, s, l: lTemp });
            if (this.contrast(adjustableColor, otherColor) < contrastRatio) {
                min = lTemp;
                minColor = this.hsl2hex({ h, s, l: lTemp });
            }
            else {
                max = lTemp;
                maxColor = this.hsl2hex({ h, s, l: lTemp });
            }
        }
        return {
            color: maxColor,
            lightness: max,
        };
    }
    findClosestAccessibleColor(adjustableColor, otherColor, contrastRatio) {
        const closestDarkerColor = this.findClosestAccessibleDarkerColor(adjustableColor, otherColor, contrastRatio);
        const closestLighterColor = this.findClosestAccessibleLighterColor(adjustableColor, otherColor, contrastRatio);
        if (closestDarkerColor === null) {
            if (closestLighterColor === null) {
                return null;
            }
            return closestLighterColor.color;
        }
        if (closestLighterColor === null) {
            return closestDarkerColor.color;
        }
        const { l } = this.hex2hsl(adjustableColor);
        if (closestLighterColor.lightness - l <
            l - closestDarkerColor.lightness) {
            return closestLighterColor.color;
        }
        return closestDarkerColor.color;
    }
    convertHslToStringHsl(hsl) {
        return ('hsl(' +
            (hsl.h < 0 ? hsl.h + 360 : hsl.h) +
            ', ' +
            hsl.s +
            '%, ' +
            hsl.l +
            '%)');
    }
}
PepColorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepColorService_Factory() { return new PepColorService(); }, token: PepColorService, providedIn: "root" });
PepColorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

class PepFieldData {
    constructor(options = {}) {
        this.ApiName = options.ApiName;
        this.Enabled = !!options.Enabled;
        this.Value = options.Value;
        this.FormattedValue = options.FormattedValue || '';
        this.FieldType = options.FieldType;
        this.ReadOnly = !!options.ReadOnly;
        this.ColumnWidth = options.ColumnWidth;
        this.ColumnWidthType = options.ColumnWidthType;
        this.XAlignment = options.XAlignment || X_ALIGNMENT_TYPE.Left;
        this.Title = options.Title || '';
    }
}
class PepRowData {
}
class PepDataConvertorService {
    getUiControl(formData) {
        var _a;
        const uiControl = new UIControl();
        if (((_a = formData === null || formData === void 0 ? void 0 : formData.Fields) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            const uiRow = formData.Fields;
            uiControl.ControlFields = [];
            uiRow.forEach((field) => uiControl.ControlFields.push(this.setUIControlField(field)));
        }
        return uiControl;
    }
    convertFormData(formData) {
        const rowData = new ObjectsDataRow();
        rowData.Fields = [];
        rowData.Type = 0;
        rowData.UID = PepGuid.newGuid();
        formData.Fields.forEach((field) => rowData.Fields.push(this.setDataField(field)));
        return rowData;
    }
    convertListData(tableData, rowUUID = '') {
        const rows = new Array();
        if (tableData.length > 0) {
            tableData.forEach((row) => {
                const rowData = new ObjectsDataRow();
                rowData.Fields = [];
                rowData.Type = 0;
                rowData.UID = rowUUID
                    ? rowUUID
                    : row.UUID
                        ? row.UUID
                        : PepGuid.newGuid();
                row.Fields.forEach((field) => rowData.Fields.push(this.setDataField(field)));
                rows.push(rowData);
            });
        }
        return rows;
    }
    setUIControlField(field) {
        const controlField = new UIControlField();
        controlField.ApiName = field.ApiName;
        controlField.FieldType = field.FieldType;
        controlField.Layout = new FieldLayout({
            X: 1,
            Width: 1,
            XAlignment: field.XAlignment,
            Y: 1,
            Height: 1,
            YAlignment: 1,
        });
        controlField.Title = field.Title;
        controlField.ReadOnly = field.ReadOnly === true ? true : false;
        controlField.ColumnWidth = field.ColumnWidth;
        controlField.ColumnWidthType = field.ColumnWidthType || 1;
        return controlField;
    }
    setDataField(field) {
        const dataField = new ObjectsDataRowCell();
        dataField.AdditionalValue = field.AdditionalValue;
        dataField.ApiName = field.ApiName;
        dataField.Enabled = field.Enabled === false ? false : true;
        dataField.FieldType = field.FieldType;
        dataField.FormattedValue =
            field.FormattedValue || field.Value.toString();
        dataField.GroupFields = null;
        dataField.NotificationInfo = '';
        dataField.OptionalValues = field.OptionalValues;
        dataField.ReferenceObjectSubType = '';
        dataField.TextColor = '';
        dataField.Value = field.Value.toString();
        dataField.Visible = true;
        return dataField;
    }
    setFieldLayout(x, width, xAlignment, y, height, yAlignment, lineNumber) {
        const layout = new FieldLayout({
            X: x,
            Width: width,
            XAlignment: xAlignment,
            Y: y,
            Height: height,
            YAlignment: yAlignment,
            LineNumber: lineNumber,
        });
        return layout;
    }
}
PepDataConvertorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepDataConvertorService_Factory() { return new PepDataConvertorService(); }, token: PepDataConvertorService, providedIn: "root" });
PepDataConvertorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

class PepFileService {
    constructor() {
        this.scripts = new Map();
        this.styles = new Map();
    }
    loadFiles(files) {
        const promises = [];
        files.forEach((file) => {
            if (file.type === 'style') {
                promises.push(this.loadStyle(file.path));
            }
            else if (file.type === 'script') {
                promises.push(this.loadScript(file.path));
            }
        });
        return Promise.all(promises);
    }
    removeFiles(files) {
        for (let index = 0; index < files.length &&
            files[index].path &&
            files[index].path.trim() !== ''; index++) {
            const name = this.getFileName(files[index].path, true);
            const element = document.getElementById(name);
            element.parentNode.removeChild(element);
            if (files[index].type === 'script' && this.scripts.has(name)) {
                this.scripts.delete(name);
            }
            else if (files[index].type === 'style' && this.styles.has(name)) {
                this.styles.delete(name);
            }
        }
    }
    loadScript(path) {
        return new Promise((resolve, reject) => {
            const name = this.getFileName(path, true);
            // If the script isn't exist add it.
            if (!this.scripts.has(name)) {
                this.scripts.set(name, { loaded: false, src: path });
            }
            const scriptItem = this.scripts.get(name);
            // Resolve if already loaded
            if (scriptItem.loaded) {
                resolve({
                    script: name,
                    loaded: true,
                    status: 'Already Loaded',
                });
            }
            else {
                // Load script
                const script = document.createElement('script');
                script.type = 'text/javascript';
                script.src = scriptItem.src;
                script.setAttribute('id', name);
                script.async = false;
                if (script.readyState) {
                    // IE
                    script.onreadystatechange = () => {
                        if (script.readyState === 'loaded' ||
                            script.readyState === 'complete') {
                            script.onreadystatechange = null;
                            scriptItem.loaded = true;
                            resolve({
                                path,
                                type: 'script',
                                loaded: true,
                                status: 'Loaded',
                            });
                        }
                    };
                }
                else {
                    // Others
                    script.onload = () => {
                        scriptItem.loaded = true;
                        resolve({
                            path,
                            type: 'script',
                            loaded: true,
                            status: 'Loaded',
                        });
                    };
                }
                script.onerror = (error) => resolve({
                    path,
                    type: 'script',
                    loaded: false,
                    status: 'Loaded',
                });
                document.getElementsByTagName('head')[0].appendChild(script);
            }
        });
    }
    loadStyle(path) {
        return new Promise((resolve, reject) => {
            const name = this.getFileName(path, true);
            // If the style isn't exist add it.
            if (!this.styles.has(name)) {
                this.styles.set(name, { loaded: false, src: path });
            }
            const styleItem = this.styles.get(name);
            // Resolve if already loaded
            if (styleItem.loaded) {
                resolve({
                    path,
                    type: 'style',
                    loaded: true,
                    status: 'Already Loaded',
                });
            }
            else {
                // Load style
                const style = document.createElement('link');
                style.type = 'text/css';
                style.rel = 'stylesheet';
                style.href = styleItem.src;
                style.media = 'all';
                style.setAttribute('id', name);
                styleItem.loaded = true;
                resolve({
                    path,
                    type: 'style',
                    loaded: true,
                    status: 'Loaded',
                });
                document.getElementsByTagName('head')[0].appendChild(style);
            }
        });
    }
    loadFontStyle(styleId, href) {
        const head = document.getElementsByTagName('head')[0];
        const styleElement = document.getElementById(styleId);
        if (styleElement) {
            styleElement.href = href;
        }
        else {
            const style = document.createElement('link');
            style.id = styleId;
            style.rel = 'stylesheet';
            style.href = `${href}`;
            head.appendChild(style);
        }
    }
    getFileName(filePath, withExtenstion = false) {
        const lastIndex = withExtenstion
            ? filePath.length - 1
            : filePath.lastIndexOf('.');
        return filePath.substr(filePath.lastIndexOf('/') + 1, lastIndex);
    }
    getFileExtension(filePath) {
        const fileSplit = filePath.split('.');
        let fileExt = '';
        if (fileSplit.length > 1) {
            fileExt = fileSplit[fileSplit.length - 2];
        }
        return fileExt;
    }
    /* Returns true if url is valid */
    isValidUrl(url) {
        /* Try creating a valid URL */
        try {
            const tmp = new URL(url);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    convertFromb64toBlob(b64Data, contentType = '', sliceSize = 512) {
        const byteCharacters = atob(b64Data);
        const byteArrays = [];
        for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
            const slice = byteCharacters.slice(offset, offset + sliceSize);
            const byteNumbers = new Array(slice.length);
            for (let i = 0; i < slice.length; i++) {
                byteNumbers[i] = slice.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            byteArrays.push(byteArray);
        }
        const blob = new Blob(byteArrays, { type: contentType });
        return blob;
    }
    getAssetsPath(assetsDomain = '') {
        const concatChar = assetsDomain === '' || assetsDomain.endsWith('/') ? '' : '/';
        return `${assetsDomain}${concatChar}assets/ngx-lib/`;
    }
    getAssetsTranslationsSuffix() {
        return '.ngx-lib.json';
    }
    getAssetsTranslationsPath(assetsDomain = '') {
        return `${this.getAssetsPath(assetsDomain)}i18n/`;
    }
    getAssetsImagesPath(assetsDomain = '', image = '') {
        return `${this.getAssetsPath(assetsDomain)}images/${image}`;
    }
    getSvgAsImageSrc(svg) {
        const blob = new Blob([svg], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        return url;
    }
}
PepFileService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepFileService_Factory() { return new PepFileService(); }, token: PepFileService, providedIn: "root" });
PepFileService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepFileService.ctorParameters = () => [];

class PepValidatorService {
    constructor(translate = null) {
        var _a;
        this.translate = translate;
        //  Regular expressions
        this.integerUnsigned = '^[0-9]*$';
        this.integerSigned = '^-?[0-9]+$';
        this.decimalUnsigned = '^[0-9]+(.[0-9]+)?$';
        this.decimalSigned = '^-?[0-9]+(.[0-9]+)?$';
        this.phone = '^[+]*[(]{0,1}[0-9]{1,4}[)]{0,1}[-s./0-9]*$';
        this.decimalSeparator = '.';
        const currentLang = ((_a = this.translate) === null || _a === void 0 ? void 0 : _a.currentLang) || navigator.language;
        // Check for number with thousands seperator and if === ',' then the decimal seperator is '.' else ','
        const tmp = new Intl.NumberFormat(currentLang, {
            maximumSignificantDigits: 2,
        }).format(1000);
        this.decimalSeparator = tmp.indexOf(',') === 1 ? '.' : ',';
        this.decimalUnsigned = `^[0-9]+(${this.decimalSeparator}[0-9]+)?$`;
        this.decimalSigned = `^-?[0-9]+(${this.decimalSeparator}[0-9]+)?$`;
    }
    /*
        ValidatorFn functions
    */
    isEqual(target) {
        return (control) => {
            if (control.value) {
                return target.value !== control.value
                    ? { equal: { value: true } }
                    : null;
            }
            else {
                return null;
            }
        };
    }
    isGreaterThan(target) {
        return (control) => {
            if (control.value && typeof target.value === 'number') {
                return target.value > control.value
                    ? { greater: { value: true } }
                    : null;
            }
            else if (control.value && typeof target.value === 'string') {
                const controlValueNumer = coerceNumberProperty(control.value);
                const targetValueNumer = coerceNumberProperty(target.value);
                return targetValueNumer > controlValueNumer
                    ? { greater: { value: true } }
                    : null;
            }
            else {
                return null;
            }
        };
    }
    isLessThan(target) {
        return (control) => {
            if (control.value && typeof target.value === 'number') {
                return target.value < control.value
                    ? { less: { value: true } }
                    : null;
            }
            else if (control.value && typeof target.value === 'string') {
                const controlValueNumer = coerceNumberProperty(control.value);
                const targetValueNumer = coerceNumberProperty(target.value);
                return targetValueNumer < controlValueNumer
                    ? { less: { value: true } }
                    : null;
            }
            else {
                return null;
            }
        };
    }
    checkEmails(separator) {
        return (control) => {
            if (control.value) {
                const emails = control.value.split(separator ? separator : ',');
                const ctrl = new FormControl('', [
                    Validators.required,
                    Validators.email,
                ]);
                const result = emails.every((val) => {
                    ctrl.setValue(val);
                    return ctrl.valid;
                });
                return !result ? { emails: { value: true } } : null;
            }
            else {
                return null;
            }
        };
    }
    zipCodeValidator() {
        return Validators.pattern(/^(\d{5}(-\d{4})?|[A-Z]\d[A-Z] *\d[A-Z]\d)$/);
    }
    allowableCharactersValidator() {
        return Validators.pattern(/^[a-zA-Z0-9`~!@#$%^&*()_+}{|":?><,./;'\\\]\[=\- ]+$/);
    }
    allowableCharactersWithoutNumberValidator() {
        return Validators.pattern(/^[a-zA-Z`~!@#$%^&*()_+}{|":?><,./;'\\\]\[=\- ]+$/);
    }
    allowableCharactersWithoutSpecialValidator() {
        return Validators.pattern(/^[a-zA-Z0-9 ]+$/);
    }
    dateValidator() {
        return Validators.pattern(/^(?:(0[1-9]|1[012])[\/.](0[1-9]|[12][0-9]|3[01])[\/.](19|20)[0-9]{2})$/);
    }
    numberValidator() {
        return Validators.pattern(/^[0-9]*$/);
    }
    /*
        RegExp functions
    */
    validateNumber(value, allowDecimal) {
        // choose the appropiate regular expression
        let regex;
        if (allowDecimal) {
            regex = this.decimalSigned;
        }
        else {
            regex = this.integerSigned;
        }
        // when a numbers begins with a decimal separator,
        // fix it adding a zero in the beginning
        const firstCharacter = value.charAt(0);
        if (firstCharacter == this.decimalSeparator)
            value = 0 + value;
        // when a numbers ends with a decimal separator,
        // fix it adding a zero in the end
        const lastCharacter = value.charAt(value.length - 1);
        if (lastCharacter == this.decimalSeparator)
            value = value + 0;
        // test number with regular expression, when
        // number is invalid, replace it with a zero
        const valid = new RegExp(regex).test(value);
        return valid ? value : null;
    }
    validatePhone(value) {
        // test phone with regular expression, when
        // phone is invalid, replace it with the previousValue
        const valid = new RegExp(this.phone).test(value);
        return valid;
    }
    getName(e) {
        if (e.key) {
            return e.key;
        }
        else {
            // for old browsers
            if (e.keyCode && String.fromCharCode) {
                switch (e.keyCode) {
                    case 8:
                        return 'Backspace';
                    case 9:
                        return 'Tab';
                    case 27:
                        return 'Escape';
                    case 37:
                        return 'ArrowLeft';
                    case 39:
                        return 'ArrowRight';
                    case 188:
                        return ',';
                    case 190:
                        return '.';
                    case 109:
                        return '-'; // minus in numbpad
                    case 173:
                        return '-'; // minus in alphabet keyboard in firefox
                    case 189:
                        return '-'; // minus in alphabet keyboard in chrome
                    default:
                        return String.fromCharCode(e.keyCode);
                }
            }
        }
    }
    allowKeyboardNonNumericCharacters(allowedKeys, key, controlOrCommand) {
        const defaultAllowedKeys = [
            'Backspace',
            'ArrowLeft',
            'ArrowRight',
            'Escape',
            'Tab',
            'Home',
            'End',
            'Delete',
        ];
        // allow some non-numeric characters
        if (defaultAllowedKeys.indexOf(key) != -1 ||
            allowedKeys.indexOf(key) != -1 ||
            // Allow: Ctrl+A and Command+A
            (key == 'a' && controlOrCommand) ||
            // Allow: Ctrl+C and Command+C
            (key == 'c' && controlOrCommand) ||
            // Allow: Ctrl+V and Command+V
            (key == 'v' && controlOrCommand) ||
            // Allow: Ctrl+X and Command+X
            (key == 'x' && controlOrCommand) ||
            key.startsWith('F')) {
            // let it happen, don't do anything
            return true;
        }
        else {
            return false;
        }
    }
    isPhone(e) {
        const key = this.getName(e);
        const controlOrCommand = e.ctrlKey === true || e.metaKey === true;
        // allowed keys apart from numeric characters
        const allowedKeys = ['.', '-', '+', '(', ')', '*', '#'];
        // allow some non-numeric characters
        if (this.allowKeyboardNonNumericCharacters(allowedKeys, key, controlOrCommand)) {
            return true;
        }
        // allow phone characters only
        const isPhone = new RegExp(this.phone).test(key);
        return isPhone;
    }
    isNumber(e, allowDecimal) {
        const cursorPosition = e.target['selectionStart'];
        const originalValue = e.target['value'];
        const key = this.getName(e);
        const controlOrCommand = e.ctrlKey === true || e.metaKey === true;
        const signExists = originalValue.includes('-');
        const separatorExists = originalValue.includes(this.decimalSeparator);
        // allowed keys apart from numeric characters
        const allowedKeys = [];
        // when decimals are allowed, add
        // decimal separator to allowed codes when
        // its position is not close to the the sign (-. and .-)
        const separatorIsCloseToSign = signExists && cursorPosition <= 1;
        if (allowDecimal && !separatorIsCloseToSign && !separatorExists) {
            if (this.decimalSeparator == '.')
                allowedKeys.push('.');
            else
                allowedKeys.push(',');
        }
        // when minus sign is allowed, add its
        // key to allowed key only when the
        // cursor is in the first position, and
        // first character is different from
        // decimal separator
        const firstCharacterIsSeparator = originalValue.charAt(0) != this.decimalSeparator;
        if (!signExists && firstCharacterIsSeparator && cursorPosition == 0) {
            allowedKeys.push('-');
        }
        // allow some non-numeric characters
        if (this.allowKeyboardNonNumericCharacters(allowedKeys, key, controlOrCommand)) {
            return true;
        }
        // allow number characters only
        const isNumber = new RegExp(this.integerUnsigned).test(key);
        return isNumber;
    }
}
PepValidatorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepValidatorService_Factory() { return new PepValidatorService(i0.ɵɵinject(i1.TranslateService, 8)); }, token: PepValidatorService, providedIn: "root" });
PepValidatorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepValidatorService.ctorParameters = () => [
    { type: TranslateService, decorators: [{ type: Optional }] }
];

class PepWindowScrollingService {
    constructor() {
        this.styleTag = this.buildStyleElement();
    }
    // Disable the scrolling feature on the main viewport.
    disable() {
        document.body.appendChild(this.styleTag);
    }
    // Re-enable the scrolling feature on the main viewport.
    enable() {
        document.body.removeChild(this.styleTag);
    }
    // Return a Style element that will prevent scrolling on the body.
    buildStyleElement() {
        const style = document.createElement('style');
        style.type = 'text/css';
        style.setAttribute('data-debug', 'Injected by WindowScrolling service.');
        style.textContent = `
            body {
                overflow: hidden !important ;
            }
        `;
        return style;
    }
}
PepWindowScrollingService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepWindowScrollingService_Factory() { return new PepWindowScrollingService(); }, token: PepWindowScrollingService, providedIn: "root" });
PepWindowScrollingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepWindowScrollingService.ctorParameters = () => [];

/*
 * Public API Surface of ngx-lib/core/common/services
 */

/*
 * export from ngx-lib/core/common/services
 */

/*
 * Public API Surface of ngx-lib/core/common
 */

/*
 * export from ngx-lib/core/common
 */

/** Default horizontal alignment. */
const DEFAULT_HORIZONTAL_ALIGNMENT = 'left';
/** Default horizontal alignment. */
const DEFAULT_VERTICAL_ALIGNMENT = 'top';
class PepFieldBase {
    // lastFocusField: any;
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        this.key = options.key || '';
        this.label = options.label || '';
        this.accessory = options.accessory || '';
        this.mandatory = !!options.mandatory;
        this.order = (_a = options.order) !== null && _a !== void 0 ? _a : 1;
        this.controlType = options.controlType || '';
        // this.type = options.type || '';
        this.placeholder = options.placeholder || '';
        this.hidden = !!options.hidden;
        this.row = (_b = options.row) !== null && _b !== void 0 ? _b : 1;
        this.rowSpan = (_c = options.rowSpan) !== null && _c !== void 0 ? _c : 1;
        this.col = (_d = options.col) !== null && _d !== void 0 ? _d : 1;
        this.colSpan = (_e = options.colSpan) !== null && _e !== void 0 ? _e : 1;
        this.xAlignment = (_f = options.xAlignment) !== null && _f !== void 0 ? _f : DEFAULT_HORIZONTAL_ALIGNMENT;
        this.yAlignment = (_g = options.yAlignment) !== null && _g !== void 0 ? _g : DEFAULT_VERTICAL_ALIGNMENT;
        this.maxFieldCharacters = (_h = options.maxFieldCharacters) !== null && _h !== void 0 ? _h : 0;
        this.minValue = (_j = options.minValue) !== null && _j !== void 0 ? _j : 0;
        this.maxValue = (_k = options.maxValue) !== null && _k !== void 0 ? _k : 0;
        this.update(options);
    }
    getBaseValidators(isCheckbox = false) {
        const validators = [];
        if (this.mandatory && !this.readonly && !this.disabled) {
            if (isCheckbox) {
                validators.push(Validators.requiredTrue);
            }
            else {
                validators.push(Validators.required);
            }
        }
        else {
            validators.push(Validators.nullValidator);
        }
        if (this.maxFieldCharacters > 0) {
            validators.push(Validators.maxLength(this.maxFieldCharacters));
        }
        return validators;
    }
    getValidators() {
        const validators = this.getBaseValidators();
        return validators;
    }
    update(options) {
        this.value = options.value;
        this.formattedValue = options.formattedValue;
        this.additionalValue = options.additionalValue;
        this.readonly = !!options.readonly;
        this.disabled = !!options.disabled;
        this.visible = !!options.visible;
        this.textColor = options.textColor || '';
        // this.lastFocusField = options.lastFocusField || null;
    }
}
class PepPlaceholderField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'placeholder';
    }
}
class PepSeparatorField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'separator';
    }
}
class PepAttachmentField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'attachment';
    }
}
class PepIndicatorsField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'indicators';
    }
}
class PepTextboxField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'textbox';
        this.type = 'text';
        this.type = options.type || 'text';
        this.update(options);
    }
    update(options) {
        super.update(options);
        if (this.type === 'link') {
            // DI-11292 - add changes for link field for the "Read Only display value" prop
            this.formattedValue =
                this.disabled && this.formattedValue && this.value
                    ? this.formattedValue
                    : this.value;
        }
    }
    getValidators() {
        const validators = super.getBaseValidators();
        if (this.type === 'email') {
            validators.push(Validators.pattern(/^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/));
        }
        else if (this.type === 'phone') {
            validators.push(Validators.pattern(/^[\d\.\-\+\(\)\*\#]+$/));
        }
        else if (this.type === 'int' || this.type === 'real') {
            validators.push(Validators.pattern(/^[\.,\-\+\d]+$/));
            if (!isNaN(this.minValue)) {
                validators.push(Validators.min(this.minValue));
            }
            if (!isNaN(this.maxValue)) {
                validators.push(Validators.max(this.maxValue));
            }
        }
        return validators;
    }
}
class PepTextareaField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'textarea';
        // this.type = 'textarea';
    }
}
class PepRichHtmlTextareaField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'richhtmltextarea';
        // this.type = 'richhtmltextarea';
    }
}
class PepSignatureField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'signature';
        this.options = [];
        this.options = options.options || [];
    }
}
class PepImageField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'image';
        this.hasCampaignField = null;
        this.indicatorsField = null;
        this.menuField = null;
        this.options = [];
        this.sizeLimitMB = 5;
        this.hasCampaignField = options.hasCampaignField || null;
        this.indicatorsField = options.indicatorsField || null;
        this.menuField = options.menuField || null;
        this.options = options.options || [];
        this.sizeLimitMB = options.sizeLimitMB || 5;
    }
}
class PepImagesField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'images';
        this.options = [];
        this.options = options.options || [];
    }
}
class PepQuantitySelectorField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'qs';
        this.notificationInfo = {};
        this.updatedDataCount = 0;
        this.allowDecimal = options.allowDecimal || false;
        this.type = options.type || 'qs';
        this.update(options);
    }
    update(options) {
        super.update(options);
        this.notificationInfo = options.notificationInfo;
        this.updatedDataCount += 1;
    }
}
class PepDateField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'date';
        this.type = options.type || 'date';
    }
}
class PepCheckboxField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'checkbox';
        this.type = options.type || 'checkbox';
    }
    getValidators() {
        const validators = super.getBaseValidators(true);
        return validators;
    }
}
class PepSelectField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'select';
        this.options = [];
        this.type = options.type || 'select';
        this.update(options);
    }
    update(options) {
        super.update(options);
        this.options = options.options || [];
    }
}
class PepAddressField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'address';
        this.groupFields = null;
        this.groupFields = options.groupFields || null;
    }
}
class PepInternalButtonField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'button';
        this.referenceObjectSubType = '';
        this.referenceObjectInternalType = '';
        this.referenceObjectType = options.referenceObjectType || null;
        this.referenceObjectSubType = options.referenceObjectSubType || null;
        this.referenceObjectInternalType =
            options.referenceObjectInternalType || null;
        this.type = options.type || 'button';
    }
}
class PepInternalPageField extends PepFieldBase {
    constructor(options = {}) {
        super(options);
        this.controlType = 'internalPage';
        this.objectId = '';
        this.parentId = '';
        this.searchCode = '';
        this.objectId = options.objectId || '';
        this.parentId = options.parentId || '';
        this.searchCode = options.searchCode || '';
    }
}
class PepInternalMenuField extends PepFieldBase {
    // hasSubMenu: boolean = false;
    constructor(options = {}) {
        super(options);
        this.controlType = 'menu';
        this.options = [];
        this.options = options.options || [];
        // this.hasSubMenu = options['hasSubMenu'];
    }
}

class PepCustomizationService {
    constructor(sessionService, fileService, fb) {
        this.sessionService = sessionService;
        this.fileService = fileService;
        this.fb = fb;
        this.hasCustomHomepage = null;
        this.hasCustomHeader = null;
        this.customHeaderHeight = PepCustomizationService.DEFAULT_HEADER_HEIGHT;
        this.mainContHeight = 0;
        this.footerHeight = new BehaviorSubject(0);
        this.settingsWidth = new BehaviorSubject(0);
        this.hideFooter();
        //
    }
    getDefaultFromGroup(field, withValidators = true) {
        const validators = withValidators ? field.getValidators() : [];
        const group = {};
        group[field.key] = [
            { value: field.value, disabled: field.disabled },
            validators,
        ];
        return this.fb.group(group);
    }
    getFormControl(form, fieldKey, parentFieldKey = null) {
        let formControl = null;
        if (form && form.controls) {
            if (parentFieldKey === null) {
                formControl = form.controls[fieldKey];
            }
            else {
                formControl = form.controls[parentFieldKey].get(fieldKey);
            }
        }
        return formControl;
    }
    updateFormFieldValue(form, fieldKey, value = '', parentFieldKey = null) {
        const formControl = this.getFormControl(form, fieldKey, parentFieldKey);
        if (formControl) {
            formControl.setValue(value);
        }
    }
    updateFormField(form, field, value = '', parentField = null) {
        const formControl = this.getFormControl(form, field.key, parentField === null || parentField === void 0 ? void 0 : parentField.key);
        if (formControl) {
            formControl.setValue(value);
            // If disabled has changed.
            if (formControl.disabled !== field.disabled) {
                field.disabled ? formControl.disable() : formControl.enable();
                const validators = field.getValidators();
                formControl.setValidators(validators);
            }
        }
    }
    calculateFormFieldHeight(withTitle = true, rowSpan = 1, standAlone = false) {
        const themeVars = this.getThemeVariables();
        const rowFieldHeight = this.getNumberThemeVariable(themeVars, PepCustomizationService.FORM_FIELD_HEIGHT_KEY);
        const rowFieldTitleHeight = this.getNumberThemeVariable(themeVars, PepCustomizationService.FORM_FIELD_TITLE_HEIGHT_KEY);
        const rowFieldSpacingBottom = this.getNumberThemeVariable(themeVars, PepCustomizationService.FORM_SPACEING_KEY);
        let fieldHeight = 0;
        if (rowSpan === 1) {
            fieldHeight =
                (withTitle ? rowFieldTitleHeight : 0) + rowFieldHeight;
        }
        else {
            const rowSpanCalc = withTitle ? rowSpan : rowSpan - 1;
            fieldHeight =
                rowSpan * rowFieldHeight +
                    rowSpanCalc * rowFieldTitleHeight +
                    (standAlone ? 0 : rowSpanCalc * rowFieldSpacingBottom);
        }
        return fieldHeight;
    }
    calculateCardRowsHeight(rowsCount = 1, withSpacing = true) {
        const themeVars = this.getThemeVariables();
        const cardFieldHeight = this.getNumberThemeVariable(themeVars, PepCustomizationService.CARD_FIELD_HEIGHT_KEY);
        const cardFieldSpacing = this.getNumberThemeVariable(themeVars, PepCustomizationService.CARD_SPACEING_KEY);
        const fieldHeight = rowsCount * cardFieldHeight +
            (rowsCount - 1) * (withSpacing ? cardFieldSpacing : 0);
        return fieldHeight;
    }
    calculateTableRowsHeight(rowsCount = 1, withSpacing = true) {
        const themeVars = this.getThemeVariables();
        const tableFieldHeight = this.getNumberThemeVariable(themeVars, PepCustomizationService.TABLE_FIELD_HEIGHT_KEY);
        const tableFieldSpacing = this.getNumberThemeVariable(themeVars, PepCustomizationService.TABLE_SPACEING_KEY);
        const fieldHeight = rowsCount *
            (tableFieldHeight + (withSpacing ? tableFieldSpacing * 2 : 0));
        return fieldHeight;
    }
    calculateFieldHeight(layoutType = 'form', rowSpan, standAlone) {
        let fieldHeight = 'inherit'; // Default for card (with no title)
        if (layoutType === 'table') {
            fieldHeight = this.getThemeVariable(PepCustomizationService.TABLE_FIELD_HEIGHT_KEY);
        }
        else if (layoutType === 'card') {
            fieldHeight =
                this.calculateCardRowsHeight(rowSpan, !standAlone) +
                    PepCustomizationService.REM_STRING;
        }
        else {
            // Form
            fieldHeight =
                this.calculateFormFieldHeight(false, rowSpan, standAlone) +
                    PepCustomizationService.REM_STRING;
        }
        return fieldHeight;
    }
    getBrandingTheme() {
        const themeObj = this.sessionService.getObject(PepCustomizationService.USER_THEME);
        return (themeObj && themeObj.Theme) || 'default-theme'; // 'light-theme';
    }
    getDefaultThemeLayoutVariables(themeVars) {
        // Declare default screen sizes.
        themeVars['--pep-screen-max-size-2xs'] =
            '460' + PepCustomizationService.PX_STRING;
        themeVars['--pep-screen-max-size-xs'] =
            '767' + PepCustomizationService.PX_STRING;
        themeVars['--pep-screen-max-size-sm'] =
            '991' + PepCustomizationService.PX_STRING;
        themeVars['--pep-screen-max-size-md'] =
            '1199' + PepCustomizationService.PX_STRING;
        themeVars['--pep-screen-max-size-lg'] =
            '1366' + PepCustomizationService.PX_STRING;
        themeVars['--pep-screen-max-size-xl'] =
            '1920' + PepCustomizationService.PX_STRING;
        // Declare default top bar.
        themeVars[PepCustomizationService.SIDE_BAR_WIDTH_KEY] =
            '16' + PepCustomizationService.REM_STRING;
        // Declare default top bar.
        themeVars[PepCustomizationService.TOP_BAR_SPACING_TOP_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.TOP_BAR_SPACING_BOTTOM_KEY] =
            '0.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.TOP_BAR_FIELD_HEIGHT_KEY] =
            '2.5' + PepCustomizationService.REM_STRING;
        // Declare default footer.
        themeVars[PepCustomizationService.FOOTER_BAR_SPACING_TOP_KEY] =
            '0.75' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FOOTER_BAR_SPACING_BOTTOM_KEY] =
            '1.25' + PepCustomizationService.REM_STRING;
    }
    getDefaultThemeBorderRadiusVariables(themeVars) {
        themeVars[PepCustomizationService.BORDER_RADIUS_SM_KEY] =
            '0.125' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.BORDER_RADIUS_MD_KEY] =
            '0.25' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.BORDER_RADIUS_LG_KEY] =
            '0.5' + PepCustomizationService.REM_STRING;
    }
    getDefaultThemeSpacingVariables(themeVars) {
        themeVars[PepCustomizationService.SPACING_SIZE_2XS_KEY] =
            '0.125' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_XS_KEY] =
            '0.25' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_SM_KEY] =
            '0.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_MD_KEY] =
            '0.75' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_LG_KEY] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_XL_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_2XL_KEY] =
            '2' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_3XL_KEY] =
            '2.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_4XL_KEY] =
            '3' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_5XL_KEY] =
            '3.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_6XL_KEY] =
            '5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_7XL_KEY] =
            '6' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_8XL_KEY] =
            '8' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.SPACING_SIZE_9XL_KEY] =
            '16' + PepCustomizationService.REM_STRING;
    }
    getDefaultThemeFontsVariables(themeVars) {
        // Title font family
        themeVars[PepCustomizationService.FONT_FAMILY_TITLE_KEY] = 'Nexa';
        // Body font family
        themeVars[PepCustomizationService.FONT_FAMILY_BODY_KEY] = 'Inter';
        // Font sizes
        themeVars[PepCustomizationService.FONT_SIZE_2XS_KEY] =
            '0.625' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_XS_KEY] =
            '0.75' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_SM_KEY] =
            '0.875' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_MD_KEY] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_LG_KEY] =
            '1.125' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_XL_KEY] =
            '1.25' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FONT_SIZE_2XL_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        // Line height
        themeVars[PepCustomizationService.LINE_HEIGHT_2XS_KEY] =
            '0.75' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_XS_KEY] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_SM_KEY] =
            '1.25' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_MD_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_LG_KEY] =
            '1.75' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_XL_KEY] =
            '2' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.LINE_HEIGHT_2XL_KEY] =
            '2.25' + PepCustomizationService.REM_STRING;
        // Font weight
        themeVars['--pep-font-weight-normal'] = 400;
        themeVars['--pep-font-weight-bold'] = 600;
        themeVars['--pep-font-weight-bolder'] = 800;
    }
    getDefaultThemeButtonsVariables(themeVars) {
        themeVars['--pep-button-2xs-horizontal-spacing'] =
            '0.25' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-2xs-min-width'] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-2xs-height'] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-2xs-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_2XS_KEY + ')';
        // themeVars['--pep-button-2xs-icon-horizontal-spacing'] = '0.125' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xs-horizontal-spacing'] =
            '0.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xs-min-width'] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xs-height'] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xs-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_XS_KEY + ')';
        // themeVars['--pep-button-xs-icon-horizontal-spacing'] = '0.25' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-sm-horizontal-spacing'] =
            '0.75' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-sm-min-width'] =
            '2' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-sm-height'] =
            '2' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-sm-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_SM_KEY + ')';
        // themeVars['--pep-button-sm-icon-horizontal-spacing'] = '0.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-md-horizontal-spacing'] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-md-min-width'] =
            '2.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-md-height'] =
            '2.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-md-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_MD_KEY + ')';
        // themeVars['--pep-button-md-icon-horizontal-spacing'] = '0.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-lg-horizontal-spacing'] =
            '1' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-lg-min-width'] =
            '3' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-lg-height'] =
            '3' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-lg-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_LG_KEY + ')';
        // themeVars['--pep-button-lg-icon-horizontal-spacing'] = '0.75' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xl-horizontal-spacing'] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xl-min-width'] =
            '4' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xl-height'] =
            '4' + PepCustomizationService.REM_STRING;
        themeVars['--pep-button-xl-font-size'] =
            'var(' + PepCustomizationService.FONT_SIZE_XL_KEY + ')';
        // themeVars['--pep-button-xl-icon-horizontal-spacing'] = '1' + PepCustomizationService.REM_STRING;
    }
    getSystemPrimaryInvertColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_INVERT_KEY + '-h'] = '255';
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_INVERT_KEY + '-s'] = '100%';
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_INVERT_KEY + '-l'] = '100%';
    }
    getSystemPrimaryColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-h'] =
            '0';
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-s'] =
            '0%';
        themeVars[PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-l'] =
            '10%';
    }
    getSystemSuccessColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_SYSTEM_SUCCESS_KEY + '-h'] =
            '100';
        themeVars[PepCustomizationService.COLOR_SYSTEM_SUCCESS_KEY + '-s'] =
            '100%';
        themeVars[PepCustomizationService.COLOR_SYSTEM_SUCCESS_KEY + '-l'] =
            '25%';
    }
    getSystemCautionColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_SYSTEM_CAUTION_KEY + '-h'] =
            '360';
        themeVars[PepCustomizationService.COLOR_SYSTEM_CAUTION_KEY + '-s'] =
            '100%';
        themeVars[PepCustomizationService.COLOR_SYSTEM_CAUTION_KEY + '-l'] =
            '40%';
    }
    getUserPrimaryColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-h'] = '78';
        themeVars[PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-s'] =
            '87%';
        themeVars[PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-l'] =
            '27%';
    }
    getUserSecondaryColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_USER_SECONDARY_KEY + '-h'] =
            '77';
        themeVars[PepCustomizationService.COLOR_USER_SECONDARY_KEY + '-s'] =
            '87%';
        themeVars[PepCustomizationService.COLOR_USER_SECONDARY_KEY + '-l'] =
            '42%';
    }
    getWeakColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_WEAK_KEY + '-h'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-h)';
        themeVars[PepCustomizationService.COLOR_WEAK_KEY + '-s'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-s)';
        themeVars[PepCustomizationService.COLOR_WEAK_KEY + '-l'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-l)';
    }
    getRegularColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_REGULAR_KEY + '-h'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-h)';
        themeVars[PepCustomizationService.COLOR_REGULAR_KEY + '-s'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-s)';
        themeVars[PepCustomizationService.COLOR_REGULAR_KEY + '-l'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-l)';
    }
    getStrongColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_STRONG_KEY + '-h'] =
            'var(' + PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-h)';
        themeVars[PepCustomizationService.COLOR_STRONG_KEY + '-s'] =
            'var(' + PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-s)';
        themeVars[PepCustomizationService.COLOR_STRONG_KEY + '-l'] =
            'var(' + PepCustomizationService.COLOR_USER_PRIMARY_KEY + '-l)';
    }
    getTextColorsVariables(themeVars) {
        themeVars[PepCustomizationService.COLOR_TEXT_LINK_KEY + '-h'] = '207';
        themeVars[PepCustomizationService.COLOR_TEXT_LINK_KEY + '-s'] = '76%';
        themeVars[PepCustomizationService.COLOR_TEXT_LINK_KEY + '-l'] = '37%';
    }
    getDefaultThemeColorsVariables(themeVars) {
        // System primary invert colors.
        this.getSystemPrimaryInvertColorsVariables(themeVars);
        // System primary colors.
        this.getSystemPrimaryColorsVariables(themeVars);
        // System success colors.
        this.getSystemSuccessColorsVariables(themeVars);
        // System caution colors.
        this.getSystemCautionColorsVariables(themeVars);
        // User primary colors.
        this.getUserPrimaryColorsVariables(themeVars);
        // User secondary colors.
        this.getUserSecondaryColorsVariables(themeVars);
        // Weak colors.
        this.getWeakColorsVariables(themeVars);
        // Regular colors.
        this.getRegularColorsVariables(themeVars);
        // Strong colors.
        this.getStrongColorsVariables(themeVars);
        // Text colors.
        this.getTextColorsVariables(themeVars);
    }
    getDefaultThemeShadowsVariables(themeVars) {
        const noneOffset = '0';
        themeVars[PepCustomizationService.SHADOW_NONE_OFFSET_KEY] = noneOffset;
        const xsOffset = '0 0.125rem 0.25rem 0';
        themeVars[PepCustomizationService.SHADOW_XS_OFFSET_KEY] = xsOffset;
        const smOffset = '0 0.25rem 0.5rem 0';
        themeVars[PepCustomizationService.SHADOW_SM_OFFSET_KEY] = smOffset;
        const mdOffset = '0 0.5rem 1rem 0';
        themeVars[PepCustomizationService.SHADOW_MD_OFFSET_KEY] = mdOffset;
        const lgOffset = '0 1rem 2rem 0';
        themeVars[PepCustomizationService.SHADOW_LG_OFFSET_KEY] = lgOffset;
        const xlOffset = '0 2rem 4rem 0';
        themeVars[PepCustomizationService.SHADOW_XL_OFFSET_KEY] = xlOffset;
    }
    getDefaultThemeFormCustomizationVariables(themeVars) {
        const formFieldSpacing = 1;
        themeVars[PepCustomizationService.FORM_FIELD_HEIGHT_KEY] =
            '2.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FORM_FIELD_TITLE_HEIGHT_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FORM_SPACEING_KEY] =
            formFieldSpacing + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.FORM_FIELD_SPACEING_KEY] =
            formFieldSpacing + PepCustomizationService.REM_STRING;
    }
    getDefaultThemeCardCustomizationVariables(themeVars) {
        themeVars[PepCustomizationService.CARD_FIELD_HEIGHT_KEY] =
            '1.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.CARD_SPACEING_KEY] =
            'var(' + PepCustomizationService.SPACING_SIZE_XS_KEY + ')';
        themeVars[PepCustomizationService.CARD_BORDER_RADIUS_KEY] =
            'var(' + PepCustomizationService.BORDER_RADIUS_MD_KEY + ')';
        themeVars[PepCustomizationService.CARD_SHADOW_OFFSET_KEY] =
            'var(' + PepCustomizationService.SHADOW_MD_OFFSET_KEY + ')';
    }
    getDefaultThemeTableCustomizationVariables(themeVars) {
        themeVars[PepCustomizationService.TABLE_FIELD_HEIGHT_KEY] =
            '2' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.TABLE_SPACEING_KEY] =
            '0.5' + PepCustomizationService.REM_STRING;
        themeVars[PepCustomizationService.TABLE_BORDER_RADIUS_KEY] =
            'var(' + PepCustomizationService.BORDER_RADIUS_MD_KEY + ')';
    }
    getDefaultThemeQSCustomizationVariables(themeVars) {
        const qsState = 'regular';
        themeVars[PepCustomizationService.STYLE_QS_KEY] = qsState;
        themeVars[PepCustomizationService.COLOR_QS_KEY + '-h'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-h)';
        themeVars[PepCustomizationService.COLOR_QS_KEY + '-s'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-s)';
        themeVars[PepCustomizationService.COLOR_QS_KEY + '-l'] =
            'var(' + PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY + '-l)';
    }
    getDefaultThemeTopHeaderCustomizationVariables(themeVars) {
        const topHeaderState = 'strong';
        themeVars[PepCustomizationService.STYLE_TOP_HEADER_KEY] = topHeaderState;
        themeVars[PepCustomizationService.COLOR_TOP_HEADER_KEY + '-h'] = '';
        themeVars[PepCustomizationService.COLOR_TOP_HEADER_KEY + '-s'] = '';
        themeVars[PepCustomizationService.COLOR_TOP_HEADER_KEY + '-l'] = '';
    }
    getDefaultThemeVariables() {
        const themeVars = {};
        // Declare default layout.
        this.getDefaultThemeLayoutVariables(themeVars);
        // Declare default border radius.
        this.getDefaultThemeBorderRadiusVariables(themeVars);
        // Declare default spacing.
        this.getDefaultThemeSpacingVariables(themeVars);
        // Declare default fonts size & line height.
        this.getDefaultThemeFontsVariables(themeVars);
        // Declare default buttons.
        this.getDefaultThemeButtonsVariables(themeVars);
        // Declare default colors.
        this.getDefaultThemeColorsVariables(themeVars);
        // Declare default shadows.
        this.getDefaultThemeShadowsVariables(themeVars);
        // Declare default form customization.
        this.getDefaultThemeFormCustomizationVariables(themeVars);
        // Declare default card customization.
        this.getDefaultThemeCardCustomizationVariables(themeVars);
        // Declare default table customization.
        this.getDefaultThemeTableCustomizationVariables(themeVars);
        // Declare default qs customization.
        this.getDefaultThemeQSCustomizationVariables(themeVars);
        // Declare default top header customization.
        this.getDefaultThemeTopHeaderCustomizationVariables(themeVars);
        return themeVars;
    }
    getThemeVariables() {
        const ret = this.getDefaultThemeVariables();
        const themeVars = this.sessionService.getObject(PepCustomizationService.USER_THEME_VARIABLES);
        // Override defaults.
        if (themeVars) {
            for (const key in themeVars) {
                ret[key] = themeVars[key];
            }
        }
        return ret;
    }
    setThemeVariables(themeVariablesToSet = null) {
        const themeVariables = this.getThemeVariables();
        // Override defaults.
        if (themeVariablesToSet) {
            for (const key in themeVariablesToSet) {
                themeVariables[key] = themeVariablesToSet[key];
            }
        }
        this.sessionService.setObject(PepCustomizationService.USER_THEME_VARIABLES, JSON.stringify(themeVariables));
        for (const key in themeVariables) {
            if (this.isFontUrlKey(key)) {
                this.fileService.loadFontStyle(key, themeVariables[key]);
            }
            else {
                document.documentElement.style.setProperty(key, themeVariables[key]);
            }
        }
    }
    isFontUrlKey(key) {
        let res = false;
        if (key === PepCustomizationService.FONT_FAMILY_TITLE_NORMAL_URL_KEY ||
            key === PepCustomizationService.FONT_FAMILY_TITLE_BOLD_URL_KEY ||
            key === PepCustomizationService.FONT_FAMILY_BODY_NORMAL_URL_KEY ||
            key === PepCustomizationService.FONT_FAMILY_BODY_BOLD_URL_KEY) {
            res = true;
        }
        return res;
    }
    getThemeVariable(key) {
        const themeVars = this.getThemeVariables();
        if (themeVars.hasOwnProperty(key)) {
            return themeVars[key];
        }
        else {
            return '';
        }
    }
    getNumberThemeVariable(themeVars, key) {
        if (themeVars && themeVars.hasOwnProperty(key)) {
            // If it's reference to another key.
            if (themeVars[key].indexOf('var(') === 0) {
                key = themeVars[key].substr(4).split(')')[0];
            }
            const tmp = Number(themeVars[key].replace(PepCustomizationService.REM_STRING, ''));
            return tmp;
        }
        else {
            return 0;
        }
    }
    setFooterHeight(height) {
        if (this.footerHeight.getValue() !== height) {
            // it is publishing this value to all the subscribers that have already subscribed to this message
            setTimeout(() => {
                this.footerHeight.next(height);
            }, 0);
        }
        document.documentElement.style.setProperty(PepCustomizationService.FOOTER_HEIGHT_KEY, height + PepCustomizationService.REM_STRING);
    }
    hideFooter() {
        this.setFooterHeight(0);
    }
    showFooter() {
        const themeVars = this.getThemeVariables();
        const res = this.getNumberThemeVariable(themeVars, PepCustomizationService.FOOTER_BAR_SPACING_TOP_KEY) +
            this.getNumberThemeVariable(themeVars, PepCustomizationService.FOOTER_BAR_SPACING_BOTTOM_KEY) +
            this.getNumberThemeVariable(themeVars, PepCustomizationService.TOP_BAR_FIELD_HEIGHT_KEY);
        this.setFooterHeight(res);
    }
    setSettingsWidth(width) {
        if (this.settingsWidth.getValue() !== width) {
            // it is publishing this value to all the subscribers that have already subscribed to this message
            setTimeout(() => {
                this.settingsWidth.next(width);
            }, 0);
        }
        document.documentElement.style.setProperty(PepCustomizationService.SETTINGS_WIDTH_KEY, width + PepCustomizationService.REM_STRING);
    }
    hideSettings() {
        this.setSettingsWidth(0);
    }
    showSettings() {
        const themeVars = this.getThemeVariables();
        const res = this.getNumberThemeVariable(themeVars, PepCustomizationService.SIDE_BAR_WIDTH_KEY);
        this.setSettingsWidth(res);
    }
    getTopBarHeight() {
        const themeVars = this.getThemeVariables();
        const res = this.getNumberThemeVariable(themeVars, PepCustomizationService.TOP_BAR_SPACING_TOP_KEY) +
            this.getNumberThemeVariable(themeVars, PepCustomizationService.TOP_BAR_SPACING_BOTTOM_KEY) +
            this.getNumberThemeVariable(themeVars, PepCustomizationService.TOP_BAR_FIELD_HEIGHT_KEY);
        return res;
    }
    setOldUserTheme(res) {
        // Added user theme.
        const themeObj = {
            Theme: res.Theme || 'default-theme',
        };
        this.sessionService.setObject(PepCustomizationService.USER_THEME, JSON.stringify(themeObj));
        let spinnerColor;
        let brandingFontColor;
        if (this.isLightColor(res.BrandingMainColor)) {
            spinnerColor = PepCustomizationService.DEFAULT_SPINNER_COLOR;
            brandingFontColor = '#222';
        }
        else {
            spinnerColor = res.BrandingMainColor;
            brandingFontColor = PepCustomizationService.DEFAULT_BRANDING_COLOR;
        }
        const color = {
            BrandingSecondaryColor: res.BrandingSecondaryColor,
            BrandingMainColor: res.BrandingMainColor,
            BrandingFontColor: brandingFontColor,
            SpinnerColor: spinnerColor,
        };
        this.sessionService.setObject(PepCustomizationService.USER_COLOR, JSON.stringify(color));
        this.hasCustomHeader =
            res.TopHeaderFiles &&
                res.TopHeaderFiles.length > 0 &&
                res.TopHeaderFiles[0] !== ''
                ? true
                : false;
        this.hasCustomHomepage =
            res.UserRole === 'Buyer' &&
                res.TopHeaderFiles &&
                res.TopHeaderFiles.length > 1 &&
                res.TopHeaderFiles[1] !== '';
    }
    isLegacyColor() {
        const h = document.documentElement.style.getPropertyValue(PepCustomizationService.COLOR_TOP_HEADER_KEY + '-h');
        const s = document.documentElement.style.getPropertyValue(PepCustomizationService.COLOR_TOP_HEADER_KEY + '-s');
        const l = document.documentElement.style.getPropertyValue(PepCustomizationService.COLOR_TOP_HEADER_KEY + '-l');
        return !(h && s && l);
    }
    getLoadingSpinnerColor() {
        let spinnerColor = '';
        if (this.isLegacyColor()) {
            const color = this.sessionService.getObject(PepCustomizationService.USER_COLOR);
            if (color && color.SpinnerColor) {
                spinnerColor = color.SpinnerColor;
            }
            else {
                spinnerColor = PepCustomizationService.DEFAULT_SPINNER_COLOR;
            }
        }
        return spinnerColor;
    }
    getBrandingMainColor() {
        let brandingMainColor = '';
        if (this.isLegacyColor()) {
            const color = this.sessionService.getObject(PepCustomizationService.USER_COLOR);
            if (color && color.BrandingMainColor) {
                brandingMainColor = color.BrandingMainColor;
            }
            else {
                brandingMainColor =
                    PepCustomizationService.DEFAULT_BRANDING_COLOR;
            }
        }
        return brandingMainColor;
    }
    isLightColor(hexColor) {
        if (!hexColor) {
            return;
        }
        let isBright = false;
        let sum = 0;
        const c = hexColor.replace(/^#/, '');
        sum = parseInt(c[0] + c[1], 16);
        sum += parseInt(c[2] + c[3], 16);
        sum += parseInt(c[4] + c[5], 16);
        if (sum > 382.6) {
            // it's bright color
            isBright = true;
        }
        return isBright;
    }
}
PepCustomizationService.STAND_ALONE_FIELD_CLASS_NAME = 'pep-field';
PepCustomizationService.REM_STRING = 'rem';
PepCustomizationService.PX_STRING = 'px';
PepCustomizationService.USER_THEME = 'user_theme';
PepCustomizationService.USER_COLOR = 'user_color';
PepCustomizationService.USER_THEME_VARIABLES = 'user_theme_variables';
// Header height
PepCustomizationService.HEADER_HEIGHT_KEY = '--pep-header-height';
// Side bar variables keys
PepCustomizationService.SIDE_BAR_WIDTH_KEY = '--pep-side-bar-width';
// Settings width
PepCustomizationService.SETTINGS_WIDTH_KEY = '--pep-settings-bar-width';
// Top bar variables keys
PepCustomizationService.TOP_BAR_SPACING_TOP_KEY = '--pep-top-bar-spacing-top';
PepCustomizationService.TOP_BAR_SPACING_BOTTOM_KEY = '--pep-top-bar-spacing-bottom';
PepCustomizationService.TOP_BAR_FIELD_HEIGHT_KEY = '--pep-top-bar-field-height';
// Footer variables keys
PepCustomizationService.FOOTER_HEIGHT_KEY = '--pep-footer-bar-height';
PepCustomizationService.FOOTER_BAR_SPACING_TOP_KEY = '--pep-footer-bar-spacing-top';
PepCustomizationService.FOOTER_BAR_SPACING_BOTTOM_KEY = '--pep-footer-bar-spacing-bottom';
// Main container height
PepCustomizationService.MAIN_HEIGHT_KEY = '--pep-main-height';
// Colors variables keys
PepCustomizationService.COLOR_USER_PRIMARY_KEY = '--pep-color-user-primary';
PepCustomizationService.COLOR_USER_SECONDARY_KEY = '--pep-color-user-secondary';
PepCustomizationService.COLOR_SYSTEM_PRIMARY_INVERT_KEY = '--pep-color-system-primary-invert';
PepCustomizationService.COLOR_SYSTEM_PRIMARY_KEY = '--pep-color-system-primary';
PepCustomizationService.COLOR_TEXT_LINK_KEY = '--pep-color-text-link';
PepCustomizationService.COLOR_SYSTEM_CAUTION_KEY = '--pep-color-system-caution';
PepCustomizationService.COLOR_SYSTEM_SUCCESS_KEY = '--pep-color-system-success';
PepCustomizationService.COLOR_STRONG_KEY = '--pep-color-strong';
PepCustomizationService.COLOR_REGULAR_KEY = '--pep-color-regular';
PepCustomizationService.COLOR_WEAK_KEY = '--pep-color-weak';
// Top header variables keys
PepCustomizationService.COLOR_TOP_HEADER_KEY = '--pep-color-top-header';
PepCustomizationService.STYLE_TOP_HEADER_KEY = '--pep-style-top-header';
// QS variables keys
PepCustomizationService.COLOR_QS_KEY = '--pep-color-qs';
PepCustomizationService.STYLE_QS_KEY = '--pep-style-qs';
// Fonts variables keys
PepCustomizationService.FONT_FAMILY_TITLE_KEY = '--pep-font-family-title';
PepCustomizationService.FONT_FAMILY_TITLE_NORMAL_URL_KEY = '--pep-font-family-title-normal-url';
PepCustomizationService.FONT_FAMILY_TITLE_BOLD_URL_KEY = '--pep-font-family-title-bold-url';
PepCustomizationService.FONT_FAMILY_BODY_KEY = '--pep-font-family-body';
PepCustomizationService.FONT_FAMILY_BODY_NORMAL_URL_KEY = '--pep-font-family-body-normal-url';
PepCustomizationService.FONT_FAMILY_BODY_BOLD_URL_KEY = '--pep-font-family-body-bold-url';
// Border radius variables keys
PepCustomizationService.BORDER_RADIUS_KEY = '--pep-border-radius';
PepCustomizationService.BORDER_RADIUS_SM_KEY = PepCustomizationService.BORDER_RADIUS_KEY + '-sm';
PepCustomizationService.BORDER_RADIUS_MD_KEY = PepCustomizationService.BORDER_RADIUS_KEY + '-md';
PepCustomizationService.BORDER_RADIUS_LG_KEY = PepCustomizationService.BORDER_RADIUS_KEY + '-lg';
// Fonts variables keys
PepCustomizationService.FONT_SIZE_2XS_KEY = '--pep-font-size-2xs';
PepCustomizationService.FONT_SIZE_XS_KEY = '--pep-font-size-xs';
PepCustomizationService.FONT_SIZE_SM_KEY = '--pep-font-size-sm';
PepCustomizationService.FONT_SIZE_MD_KEY = '--pep-font-size-md';
PepCustomizationService.FONT_SIZE_LG_KEY = '--pep-font-size-lg';
PepCustomizationService.FONT_SIZE_XL_KEY = '--pep-font-size-xl';
PepCustomizationService.FONT_SIZE_2XL_KEY = '--pep-font-size-2xl';
// Line height variables keys
PepCustomizationService.LINE_HEIGHT_2XS_KEY = '--pep-line-height-2xs';
PepCustomizationService.LINE_HEIGHT_XS_KEY = '--pep-line-height-xs';
PepCustomizationService.LINE_HEIGHT_SM_KEY = '--pep-line-height-sm';
PepCustomizationService.LINE_HEIGHT_MD_KEY = '--pep-line-height-md';
PepCustomizationService.LINE_HEIGHT_LG_KEY = '--pep-line-height-lg';
PepCustomizationService.LINE_HEIGHT_XL_KEY = '--pep-line-height-xl';
PepCustomizationService.LINE_HEIGHT_2XL_KEY = '--pep-line-height-2xl';
// Shadows offset variables keys
PepCustomizationService.SHADOW_NONE_OFFSET_KEY = '--pep-shadow-none-offset';
PepCustomizationService.SHADOW_XS_OFFSET_KEY = '--pep-shadow-xs-offset';
PepCustomizationService.SHADOW_SM_OFFSET_KEY = '--pep-shadow-sm-offset';
PepCustomizationService.SHADOW_MD_OFFSET_KEY = '--pep-shadow-md-offset';
PepCustomizationService.SHADOW_LG_OFFSET_KEY = '--pep-shadow-lg-offset';
PepCustomizationService.SHADOW_XL_OFFSET_KEY = '--pep-shadow-xl-offset';
// Spacing variables keys
PepCustomizationService.SPACING_SIZE_2XS_KEY = '--pep-spacing-2xs';
PepCustomizationService.SPACING_SIZE_XS_KEY = '--pep-spacing-xs';
PepCustomizationService.SPACING_SIZE_SM_KEY = '--pep-spacing-sm';
PepCustomizationService.SPACING_SIZE_MD_KEY = '--pep-spacing-md';
PepCustomizationService.SPACING_SIZE_LG_KEY = '--pep-spacing-lg';
PepCustomizationService.SPACING_SIZE_XL_KEY = '--pep-spacing-xl';
PepCustomizationService.SPACING_SIZE_2XL_KEY = '--pep-spacing-2xl';
PepCustomizationService.SPACING_SIZE_3XL_KEY = '--pep-spacing-3xl';
PepCustomizationService.SPACING_SIZE_4XL_KEY = '--pep-spacing-4xl';
PepCustomizationService.SPACING_SIZE_5XL_KEY = '--pep-spacing-5xl';
PepCustomizationService.SPACING_SIZE_6XL_KEY = '--pep-spacing-6xl';
PepCustomizationService.SPACING_SIZE_7XL_KEY = '--pep-spacing-7xl';
PepCustomizationService.SPACING_SIZE_8XL_KEY = '--pep-spacing-8xl';
PepCustomizationService.SPACING_SIZE_9XL_KEY = '--pep-spacing-9xl';
// Form variables keys
PepCustomizationService.FORM_FIELD_HEIGHT_KEY = '--pep-form-field-height';
PepCustomizationService.FORM_FIELD_TITLE_HEIGHT_KEY = '--pep-form-field-title-height';
PepCustomizationService.FORM_FIELD_SPACEING_KEY = '--pep-form-field-spacing';
PepCustomizationService.FORM_SPACEING_KEY = '--pep-form-spacing';
// Card variables keys
PepCustomizationService.CARD_FIELD_HEIGHT_KEY = '--pep-card-field-height';
PepCustomizationService.CARD_SPACEING_KEY = '--pep-card-spacing';
PepCustomizationService.CARD_SHADOW_OFFSET_KEY = '--pep-shadow-card-offset';
PepCustomizationService.CARD_BORDER_RADIUS_KEY = '--pep-card-border-radius';
// Table variables keys
PepCustomizationService.TABLE_FIELD_HEIGHT_KEY = '--pep-table-field-height';
PepCustomizationService.TABLE_SPACEING_KEY = '--pep-table-spacing';
PepCustomizationService.TABLE_BORDER_RADIUS_KEY = '--pep-table-border-radius';
PepCustomizationService.DEFAULT_HEADER_HEIGHT = 64; // Default
PepCustomizationService.DEFAULT_SPINNER_COLOR = '#78aa00';
PepCustomizationService.DEFAULT_BRANDING_COLOR = '#fff';
PepCustomizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepCustomizationService_Factory() { return new PepCustomizationService(i0.ɵɵinject(PepSessionService), i0.ɵɵinject(PepFileService), i0.ɵɵinject(i3$1.FormBuilder)); }, token: PepCustomizationService, providedIn: "root" });
PepCustomizationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
PepCustomizationService.ctorParameters = () => [
    { type: PepSessionService },
    { type: PepFileService },
    { type: FormBuilder }
];

/*
 * Public API Surface of ngx-lib/core/customizatin
 */

/*
 * export from ngx-lib/core/customization
 */

/*
 * Public API Surface of ngx-lib/core/http
 */

/*
 * export from ngx-lib/core/http
 */

/*
 * Public API Surface of ngx-lib/core/layout
 */

/*
 * export from ngx-lib/core/layout
 */

/*
 * Public API Surface of ngx-lib/core/portal
 */

/*
 * export from ngx-lib/core/portal
 */

class PepScrollToService {
    scrollElementTo(element, duration = 500, top = 0) {
        const subject = new Subject();
        if (element instanceof Element || element instanceof Window) {
            this._scrollElementTo(element, duration, top, subject);
        }
        else {
            subject.error("I don't find element");
        }
        return subject;
    }
    _scrollElementTo(el, duration, top, subject) {
        if (el) {
            let startingY;
            if (el instanceof Window) {
                startingY = window.pageYOffset;
            }
            else {
                const viewportOffset = el.getBoundingClientRect();
                startingY = viewportOffset.top;
            }
            this.doScrolling(el, startingY, top, duration, subject);
        }
        else {
            subject.error("I don't find element");
        }
        return subject;
    }
    scrollWindowToElement(element, duration = 500, offset = 0) {
        const subject = new Subject();
        if (typeof element === 'string') {
            const el = document.querySelector(element);
            this._scrollWindowToElement(el, duration, offset, subject);
        }
        else if (element instanceof HTMLElement) {
            this._scrollWindowToElement(element, duration, offset, subject);
        }
        else {
            subject.error("I don't find element");
        }
        return subject;
    }
    _scrollWindowToElement(el, duration, offset, subject) {
        if (el) {
            const viewportOffset = el.getBoundingClientRect();
            const startingY = window.pageYOffset;
            const offsetTop = viewportOffset.top + startingY;
            this.doScrolling(window, startingY, offsetTop + offset, duration, subject);
        }
        else {
            subject.error("I don't find element");
        }
        return subject;
    }
    doScrolling(scrollingElement, startingY, elementY, duration, subject) {
        const diff = elementY - startingY;
        let start;
        requestAnimationFrame(function step(timestamp) {
            start = !start ? timestamp : start;
            const time = timestamp - start;
            const percent = Math.min(time / duration, 1);
            scrollingElement.scrollTo(0, startingY + diff * percent);
            if (time < duration) {
                requestAnimationFrame(step);
                subject.next({});
            }
            else {
                subject.complete();
            }
        });
    }
}
PepScrollToService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PepScrollToService_Factory() { return new PepScrollToService(); }, token: PepScrollToService, providedIn: "root" });
PepScrollToService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

/*
 * Public API Surface of ngx-lib/core/scroll-to
 */

/*
 * export from ngx-lib/core/scroll-to
 */

/*
 * Public API Surface of ngx-lib/core
 */

/*
 * export from ngx-lib/core
 */

/*
 * Public API Surface of ngx-lib
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_HORIZONTAL_ALIGNMENT, DEFAULT_VERTICAL_ALIGNMENT, FIELD_TYPE, FieldLayout, KeyValuePair, ObjectSingleData, ObjectsData, ObjectsDataRow, ObjectsDataRowCell, PepAddonService, PepAddressField, PepAttachDirective, PepAttachmentField, PepButtonBlurDirective, PepButtonLoaderDirective, PepCapitalizePipe, PepCheckboxField, PepClipboardDirective, PepClipboardService, PepColorService, PepCookieService, PepCustomizationService, PepDataConvertorService, PepDataQaDirective, PepDateField, PepDateFormatterPipe, PepDateStringFormatterPipe, PepEncodePipe, PepEscapePipe, PepFieldBase, PepFieldData, PepFileService, PepGuid, PepHttpService, PepImageField, PepImagesField, PepIndicatorsField, PepInputAutoWidthDirective, PepInternalButtonField, PepInternalMenuField, PepInternalPageField, PepJwtHelperService, PepLayoutService, PepLoaderService, PepMenuBlurDirective, PepNgxLibModule, PepPlaceholderField, PepPortalService, PepPreventMultiClickDirective, PepPrintDirective, PepQuantitySelectorField, PepReplaceLineBreaksPipe, PepRichHtmlTextareaField, PepRowData, PepRtlClassDirective, PepRtlDirectionDirective, PepSafeHtmlPipe, PepSafePipe, PepScreenSizeType, PepScrollToService, PepSelectField, PepSeparatorField, PepSessionService, PepSignatureField, PepSplitUppercasePipe, PepTargetDirective, PepTextareaField, PepTextboxField, PepToNumberPipe, PepUtilitiesService, PepValidatorService, PepWindowScrollingService, SmartSearchResponse, SmartSearchValues, Test, UIControl, UIControlField, X_ALIGNMENT_TYPE, Y_ALIGNMENT_TYPE, httpInterceptorProviders as ɵa, PepErrorInterceptor as ɵb, PepLoaderInterceptor as ɵc, PepProfilerInterceptor as ɵd };
//# sourceMappingURL=pepperi-addons-ngx-lib.js.map
