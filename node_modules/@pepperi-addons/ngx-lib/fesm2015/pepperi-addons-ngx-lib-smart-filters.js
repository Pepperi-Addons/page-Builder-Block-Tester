import { EventEmitter, Component, ChangeDetectionStrategy, ElementRef, Input, Output, Directive, ViewContainerRef, Injector, ComponentFactoryResolver, Renderer2, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { Validators, FormBuilder, FormControl, ReactiveFormsModule } from '@angular/forms';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatCommonModule } from '@angular/material/core';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatIconModule } from '@angular/material/icon';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatRadioModule } from '@angular/material/radio';
import { VirtualScrollerComponent, VirtualScrollerModule } from 'ngx-virtual-scroller';
import { PepLayoutService, PepValidatorService, PepNgxLibModule } from '@pepperi-addons/ngx-lib';
import { PepCheckboxModule } from '@pepperi-addons/ngx-lib/checkbox';
import { PepDateModule } from '@pepperi-addons/ngx-lib/date';
import { PepSelectModule } from '@pepperi-addons/ngx-lib/select';
import { PepTextboxModule } from '@pepperi-addons/ngx-lib/textbox';
import { PepSearchModule } from '@pepperi-addons/ngx-lib/search';
import { pepIconNumberMinus, pepIconNumberPlus, PepIconModule, PepIconRegistry } from '@pepperi-addons/ngx-lib/icon';
import { Subject } from 'rxjs';
import { takeUntil, distinctUntilChanged, startWith, map } from 'rxjs/operators';
import { TranslateService } from '@ngx-translate/core';

class PepSmartFiltersComponent {
    constructor(hostElement, layoutService) {
        this.hostElement = hostElement;
        this.layoutService = layoutService;
        this.title = '';
        this.filtersDataMap = new Map();
        this._filters = [];
        this._fields = [];
        this._useAsWebComponent = false;
        // @Output()
        // filtersClear: EventEmitter<void> = new EventEmitter<void>();
        this.filtersChange = new EventEmitter();
        this.fieldToggleChange = new EventEmitter();
        this.expansionPanelHeaderHeight = '*';
    }
    set filters(value) {
        this._filters = value;
        this.setupFilters(value);
    }
    get filters() {
        this._filters = [...this.filtersDataMap.keys()]
            // .filter((key) => this.filtersDataMap.get(key) !== null)
            .map((key) => {
            if (key) {
                return this.filtersDataMap.get(key);
            }
        });
        return this._filters;
    }
    set fields(value) {
        this._fields = value;
    }
    get fields() {
        return this._fields;
    }
    set useAsWebComponent(value) {
        if (value) {
            this.exportFunctionsOnHostElement();
        }
    }
    get useAsWebComponent() {
        return this._useAsWebComponent;
    }
    exportFunctionsOnHostElement() {
        // This is for web component usage for use those functions.
        this.hostElement.nativeElement.clearFilters = this.clearFilters.bind(this);
        this.hostElement.nativeElement.clearFilter = this.clearFilter.bind(this);
        this.hostElement.nativeElement.toggleField = this.toggleField.bind(this);
    }
    setupFilters(value) {
        this.filtersDataMap.clear();
        if (value) {
            value.forEach((filter) => {
                // Validate before add the filter into the map.
                let currentField = null;
                if (this.fields && this.fields.length > 0) {
                    currentField = this.fields.find((field) => field.id === filter.fieldId);
                }
                if (currentField) {
                    // Only if the operator is from the same type
                    if (filter.operator.componentType.includes(currentField.componentType)) {
                        let isOperatorUnitValid = true;
                        if (filter.operatorUnit) {
                            // Only if the operator unit is not from the same type
                            if (!filter.operatorUnit.componentType.includes(currentField.componentType)) {
                                isOperatorUnitValid = false;
                            }
                        }
                        // Add the filter.
                        if (isOperatorUnitValid) {
                            this.filtersDataMap.set(filter.fieldId, filter);
                        }
                    }
                }
            });
        }
    }
    raiseFiltersChange() {
        this.filtersChange.emit(this.filters);
    }
    toggleField(index, isOpen) {
        this.fields[index].isOpen = isOpen;
        this.fieldToggleChange.emit(this.fields[index]);
    }
    clearFilters() {
        this.filtersDataMap.clear();
    }
    clearFilter(fieldId) {
        this.filtersDataMap.delete(fieldId);
    }
    // Clear all the filters and raise event that filters has change.
    onFiltersClear() {
        this.clearFilters();
        this.raiseFiltersChange();
    }
    // Clear the filter and raise event that filters has change.
    onFilterClear(field) {
        this.clearFilter(field.id);
        this.raiseFiltersChange();
    }
    // Set the filter and raise event that filters has change.
    onFilterChange(field, filterData) {
        this.clearFilter(field.id);
        this.filtersDataMap.set(field.id, filterData);
        this.raiseFiltersChange();
    }
}
PepSmartFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-smart-filters',
                template: "<div class=\"smart-filters-container\" dir=\"{{ layoutService.isRtl() ? 'rtl' : 'ltr' }}\">\n    <div class=\"title\">\n        <span class=\"body-md bold\">{{ title?.length > 0 ? title : (\"SMART_FILTERS.TITLE\" | translate)}}</span>\n        <mat-chip *ngIf=\"filtersDataMap.size > 0\" [selectable]=\"false\" [removable]=\"true\" (click)=\"onFiltersClear()\"\n            class=\"clear-filter pep-button chip xs weak\">\n            <span class=\"body-xs ellipsis \">\n                {{ \"ACTIONS.CLEAR\" | translate}}\n            </span>\n        </mat-chip>\n    </div>\n\n    <mat-accordion [displayMode]=\"'flat'\" [multi]=\"true\" class=\"pep-accordion2\">\n        <mat-expansion-panel *ngFor=\"let field of fields; let i = index\" hideToggle=\"true\" [expanded]=\"field.isOpen\"\n            (opened)=\"toggleField(i, true)\" (closed)=\"toggleField(i, false)\">\n            <mat-expansion-panel-header [collapsedHeight]=\"expansionPanelHeaderHeight\"\n                [expandedHeight]=\"expansionPanelHeaderHeight\">\n                <mat-panel-title class=\"pep-spacing-element-negative\">\n                    <div class=\"smart-filter-title-container\">\n                        <mat-icon class=\"pep-spacing-element\">\n                            <pep-icon [name]=\"field.isOpen ? 'number_minus' : 'number_plus'\"></pep-icon>\n                        </mat-icon>\n                        <span class=\"body-sm ellipsis\" [title]=\"field.name\">\n                            {{ field.name }}\n                        </span>\n                        <mat-chip *ngIf=\"filtersDataMap.get(field.id)\" [selectable]=\"false\" [removable]=\"true\"\n                            (click)=\"onFilterClear(field)\" class=\"clear-filter pep-button chip xs weak\">\n                            <span *ngIf=\"field.componentType === 'multi-select'\" class=\"body-xs pep-spacing-element\">\n                                {{ filtersDataMap.get(field.id).value?.first?.length }}\n                                <!-- {{ field.componentType === 'multi-select' ?\n                                filtersDataMap.get(field.id).value?.first?.length : 1 }} -->\n                            </span>\n                            <mat-icon>\n                                <pep-icon name=\"system_close\"></pep-icon>\n                            </mat-icon>\n                        </mat-chip>\n                    </div>\n                </mat-panel-title>\n            </mat-expansion-panel-header>\n            <div class=\"expansion-content smart-filter-content\">\n                <ng-container [ngSwitch]=\"field.componentType\">\n                    <ng-container *ngSwitchCase=\"'boolean'\">\n                        <pep-boolean-filter [field]=\"field\" [filter]=\"filtersDataMap.get(field.id)\"\n                            (filterChange)=\"onFilterChange(field, $event)\" (filterClear)=\"onFilterClear(field)\">\n                        </pep-boolean-filter>\n                    </ng-container>\n                    <ng-container *ngSwitchCase=\"'date'\">\n                        <pep-date-filter [field]=\"field\" [filter]=\"filtersDataMap.get(field.id)\"\n                            (filterChange)=\"onFilterChange(field, $event)\" (filterClear)=\"onFilterClear(field)\">\n                        </pep-date-filter>\n                    </ng-container>\n                    <ng-container *ngSwitchCase=\"'multi-select'\">\n                        <pep-multi-select-filter [field]=\"field\" [filter]=\"filtersDataMap.get(field.id)\"\n                            (filterChange)=\"onFilterChange(field, $event)\" (filterClear)=\"onFilterClear(field)\">\n                        </pep-multi-select-filter>\n                    </ng-container>\n                    <ng-container *ngSwitchCase=\"'number'\">\n                        <pep-number-filter [field]=\"field\" [filter]=\"filtersDataMap.get(field.id)\"\n                            (filterChange)=\"onFilterChange(field, $event)\" (filterClear)=\"onFilterClear(field)\">\n                        </pep-number-filter>\n                    </ng-container>\n                    <!-- <div *ngSwitchDefault>\n                    </div> -->\n                </ng-container>\n            </div>\n        </mat-expansion-panel>\n    </mat-accordion>\n</div>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [".smart-filters-container .title{height:calc(.5rem + 2.5rem);height:calc(var(--pep-top-bar-spacing-bottom, .5rem) + var(--pep-top-bar-field-height, 2.5rem));display:flex;flex-flow:wrap;align-items:center;justify-content:space-between}.smart-filters-container .title .clear-filter{display:flex;flex-direction:row;align-items:center;justify-content:center;margin:0 .25rem;margin:0 var(--pep-spacing-xs,.25rem);padding:0 .75rem;padding:0 var(--pep-spacing-md,.75rem)}.smart-filters-container .title .clear-filter:after{background-color:transparent}.smart-filters-container .smart-filter-title-container{display:grid;grid-auto-flow:column;grid-template-columns:auto 1fr auto;width:100%}.smart-filters-container .smart-filter-title-container>*{align-self:center}.smart-filters-container .smart-filter-title-container .clear-filter{display:flex;flex-direction:row;align-items:center;justify-content:center;-webkit-margin-end:.5rem;margin-inline-end:.5rem;-webkit-margin-end:var(--pep-spacing-sm,.5rem);margin-inline-end:var(--pep-spacing-sm,.5rem)}.smart-filters-container .smart-filter-title-container .clear-filter:after{background-color:transparent}.smart-filters-container .smart-filter-title-container .mat-icon pep-icon{height:.75rem;width:.75rem}"]
            },] }
];
PepSmartFiltersComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: PepLayoutService }
];
PepSmartFiltersComponent.propDecorators = {
    title: [{ type: Input }],
    filters: [{ type: Input }],
    fields: [{ type: Input }],
    useAsWebComponent: [{ type: Input }],
    filtersChange: [{ type: Output }],
    fieldToggleChange: [{ type: Output }]
};

class PepFilterActionsComponent {
    constructor() {
        this.clearClick = new EventEmitter();
        this.applyClick = new EventEmitter();
    }
    clear() {
        this.clearClick.emit();
    }
    apply() {
        this.applyClick.emit();
    }
}
PepFilterActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-filter-actions',
                template: "<div [formGroup]=\"form\" class=\"filter-actions pep-spacing-element-negative\">\n    <button mat-button class=\"pep-spacing-element pep-button sm weak\" (click)=\"clear()\">\n        {{ 'ACTIONS.CLEAR' | translate }}\n    </button>\n    <button mat-button class=\"pep-spacing-element pep-button sm strong\" (click)=\"apply()\" [disabled]=\"form.invalid\">\n        {{ 'ACTIONS.APPLY' | translate }}\n    </button>\n</div>",
                styles: [".filter-actions{margin:1rem 0 calc(1rem / 2);margin:var(--pep-spacing-lg,1rem) 0 calc(var(--pep-spacing-lg, 1rem) / 2);display:flex;justify-content:flex-end}"]
            },] }
];
PepFilterActionsComponent.propDecorators = {
    form: [{ type: Input }],
    clearClick: [{ type: Output }],
    applyClick: [{ type: Output }]
};

class IPepSmartFilterOperator {
}
const Equals = {
    id: 'eq',
    name: 'EQUAL',
    short: '=',
    componentType: [
        'number',
        'boolean'
        // 'multi-select',
        // 'date',
        // 'text',
        // 'auto-complete',
        // 'select',
    ],
};
const NotEqual = {
    id: 'neq',
    name: 'NOT_EQUAL',
    short: '<>',
    componentType: [
        'number',
        // 'multi-select',
        // 'date',
        // 'text',
        // 'auto-complete',
        // 'select',
    ],
};
const LessThan = {
    id: 'lt',
    name: 'LESS_THEN',
    short: '<',
    componentType: ['number'],
};
// const LessThanOrEquals: IPepSmartFilterOperator = {
//     id: 'ltoe',
//     name: 'LESS_THEN_OR_EQUAL',
//     short: '<=',
//     type: ['number'],
// };
const GreaterThan = {
    id: 'gt',
    name: 'GREATER_THEN',
    short: '>',
    componentType: ['number'],
};
// const GreaterThanOrEquals: IPepSmartFilterOperator = {
//     id: 'gtoe',
//     name: 'GREATER_THEN_OR_EQUAL',
//     short: '>=',
//     type: ['number'],
// };
const NumberRange = {
    id: 'numberRange',
    name: 'NUMBER_RANGE',
    short: 'Range',
    componentType: ['number'],
};
// const Contains: Operator = {
//     id: 'contains',
//     name: 'Contains',
//     short: 'Contains',
//     type: ['text'],
// };
// const BeginsWith: Operator = {
//     id: 'beginsWith',
//     name: 'Begins With',
//     short: 'Begins With',
//     type: ['text'],
// };
// const EndsWith: Operator = {
//     id: 'endsWith',
//     name: 'Ends With',
//     short: 'End With',
//     type: ['text'],
// };
// const After: Operator = {
//     id: 'after',
//     name: 'After',
//     short: 'After',
//     type: ['date'],
// };
// const Before: Operator = {
//     id: 'before',
//     name: 'Before',
//     short: 'Before',
//     type: ['date'],
// };
const InTheLast = {
    id: 'inTheLast',
    name: 'IN_THE_LAST',
    short: 'In the last',
    componentType: ['date'],
};
const Today = {
    id: 'today',
    name: 'TODAY',
    short: 'Today',
    componentType: ['date'],
};
const ThisWeek = {
    id: 'thisWeek',
    name: 'THIS_WEEK',
    short: 'This week',
    componentType: ['date'],
};
const ThisMonth = {
    id: 'thisMonth',
    name: 'THIS_MONTH',
    short: 'This month',
    componentType: ['date'],
};
const DateRange = {
    id: 'dateRange',
    name: 'DATE_RANGE',
    short: 'Range',
    componentType: ['date'],
};
const DueIn = {
    id: 'dueIn',
    name: 'DUE_IN',
    short: 'Due in',
    componentType: ['date'],
};
const On = {
    id: 'on',
    name: 'ON',
    short: 'On',
    componentType: ['date'],
};
const NotInTheLast = {
    id: 'notInTheLast',
    name: 'NOT_IN_THE_LAST',
    short: 'Not in the last',
    componentType: ['date'],
};
const NotDueIn = {
    id: 'notDueIn',
    name: 'NOT_DUE_IN',
    short: 'Not due in',
    componentType: ['date'],
};
const IsEmpty = {
    id: 'isEmpty',
    name: 'IS_EMPTY',
    short: 'Is empty',
    componentType: ['date'],
};
const IsNotEmpty = {
    id: 'isNotEmpty',
    name: 'IS_NOT_EMPTY',
    short: 'Is not empty',
    componentType: ['date'],
};
const In = {
    id: 'in',
    name: 'IN',
    short: 'In',
    componentType: ['multi-select'],
};
const PepSmartFilterOperators = {
    Equals: Equals,
    NotEqual: NotEqual,
    LessThan: LessThan,
    // LessThanOrEquals: LessThanOrEquals,
    GreaterThan: GreaterThan,
    // GreaterThanOrEquals: GreaterThanOrEquals,
    NumberRange: NumberRange,
    // Contains: Contains,
    // BeginsWith: BeginsWith,
    // EndsWith: EndsWith,
    // After: After,
    // Before: Before,
    InTheLast: InTheLast,
    Today: Today,
    ThisWeek: ThisWeek,
    ThisMonth: ThisMonth,
    DateRange: DateRange,
    DueIn: DueIn,
    On: On,
    NotInTheLast: NotInTheLast,
    NotDueIn: NotDueIn,
    IsEmpty: IsEmpty,
    IsNotEmpty: IsNotEmpty,
    In: In,
};
class IPepSmartFilterOperatorUnit {
}
const Days = {
    id: 'days',
    name: 'DAYS',
    componentType: ['date'],
};
const Weeks = {
    id: 'weeks',
    name: 'WEEKS',
    componentType: ['date'],
};
const Months = {
    id: 'months',
    name: 'MONTHS',
    componentType: ['date'],
};
const Years = {
    id: 'years',
    name: 'YEARS',
    componentType: ['date'],
};
const PepSmartFilterOperatorUnits = {
    Days: Days,
    Weeks: Weeks,
    Months: Months,
    Years: Years,
};

class BaseFilterComponent {
    constructor(viewContainerRef, injector, resolver, builder, translate, validator, renderer) {
        this.viewContainerRef = viewContainerRef;
        this.injector = injector;
        this.resolver = resolver;
        this.builder = builder;
        this.translate = translate;
        this.validator = validator;
        this.renderer = renderer;
        this._fieldIdWithNoDots = '';
        this.filterClear = new EventEmitter();
        this.filterChange = new EventEmitter();
        this.OPERATORS_TRANSLATION_PREFIX = 'SMART_FILTERS.OPERATORS';
        this.OPERATOR_UNITS_TRANSLATION_PREFIX = 'SMART_FILTERS.OPERATOR_UNITS';
        this._destroyed = new Subject();
    }
    set field(value) {
        this._field = value;
        this._fieldIdWithNoDots = value ? value.id.replace(/./g, '_') : '';
        this.setupForm();
    }
    get field() {
        return this._field;
    }
    set filter(value) {
        this._filter = value;
        this.setupFilter();
    }
    get filter() {
        return this._filter;
    }
    set operator(operator) {
        var _a;
        if ((operator === null || operator === void 0 ? void 0 : operator.id) != ((_a = this._operator) === null || _a === void 0 ? void 0 : _a.id)) {
            // Validate operator
            const index = this.operators.findIndex((o) => o.id === operator.id);
            if (index >= 0) {
                this._operator = this.operators[index];
            }
            else {
                this._operator = this.operators[0];
            }
            this.form.reset();
            this.updateValidity();
        }
    }
    get operator() {
        return this._operator;
    }
    set operatorUnit(operatorUnit) {
        // Validate operator unit
        if (operatorUnit === undefined) {
            this._operatorUnit = undefined;
        }
        else {
            const index = this.operatorUnits.findIndex((ou) => ou.id === operatorUnit.id);
            if (index >= 0) {
                this._operatorUnit = this.operatorUnits[index];
            }
            else {
                this._operatorUnit = this.operatorUnits[0];
            }
        }
    }
    get operatorUnit() {
        return this._operatorUnit;
    }
    get firstControlKey() {
        return this.field ? `${this._fieldIdWithNoDots}_first` : 'first';
    }
    get firstControl() {
        return this.form.get(this.firstControlKey);
    }
    get secondControlKey() {
        return this.field ? `${this._fieldIdWithNoDots}_second` : 'second';
    }
    get secondControl() {
        return this.form.get(this.secondControlKey);
    }
    createActionsComponent() {
        const factory = this.resolver.resolveComponentFactory(PepFilterActionsComponent);
        this.actionsContainerRef = factory.create(this.injector);
        this.actionsContainerRef.instance.form = this.form;
        this.actionsContainerRef.instance.applyClick.subscribe(() => this.applyFilter());
        this.actionsContainerRef.instance.clearClick.subscribe(() => this.clearFilter());
        this.viewContainerRef.insert(this.actionsContainerRef.hostView);
    }
    setupForm() {
        const formValue = {};
        formValue[this.firstControlKey] = [];
        formValue[this.secondControlKey] = [];
        // this.form.patchValue(formValue);
        this.form = this.builder.group(formValue);
        // this.form[this.firstControlKey] = [];
        // this.form[this.secondControlKey] = [];
        this.setupOperators();
        this.createActionsComponent();
    }
    setupOperators() {
        var _a, _b;
        // Get the operators by componentType.
        this.operators = Object.keys(PepSmartFilterOperators)
            .filter((key) => {
            return PepSmartFilterOperators[key].componentType.includes(this.field.componentType);
        })
            .map((key) => PepSmartFilterOperators[key]);
        // Filter by from field.operators input if exist.
        if (((_a = this.field.operators) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this.operators = this.operators.filter((o1) => this.field.operators.some((o2) => o1.id === o2));
        }
        // Get the operator units by componentType.
        this.operatorUnits = Object.keys(PepSmartFilterOperatorUnits)
            .filter((key) => {
            return PepSmartFilterOperatorUnits[key].componentType.includes(this.field.componentType);
        })
            .map((key) => PepSmartFilterOperatorUnits[key]);
        // Filter by from field.operatorsUnits input if exist.
        if (((_b = this.field.operatorUnits) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            this.operatorUnits = this.operatorUnits.filter((o1) => this.field.operatorUnits.some((o2) => o1.id === o2));
        }
        // Load translation before get the options in the children.
        this.translate.get('SMART_FILTERS.TITLE').subscribe((res) => {
            this.loadOperatorsOptions();
        });
    }
    setupFilter() {
        if (this.filter) {
            this.operator = this.filter.operator;
            this.operatorUnit = this.filter.operatorUnit;
            const formValue = {};
            formValue[this.firstControlKey] = this.filter.value.first;
            formValue[this.secondControlKey] = this.filter.value.second;
            this.form.patchValue(formValue);
        }
        else {
            this.operator = this.getDefaultOperator();
            this.operatorUnit = this.getDefaultOperatorUnit();
            this.clearFilter(false);
        }
    }
    getDestroyer() {
        return takeUntil(this._destroyed);
    }
    updateValidity() {
        this.setFieldsStateAndValidators();
        this.firstControl.updateValueAndValidity();
        this.secondControl.updateValueAndValidity();
    }
    // Load the operators options from the translation.
    loadOperatorsOptions() {
        // Not implemented in the base
    }
    // Set default validators - some childs override this.
    setFieldsStateAndValidators() {
        this.firstControl.setValidators(Validators.required);
        this.secondControl.setValidators(Validators.required);
        this.secondControl.disable();
    }
    // Return undefined - some childs override this.
    getDefaultOperatorUnit() {
        return undefined;
    }
    initFilter() {
        // Not implemented in the base
    }
    clearFilter(emitEvent = true) {
        this._filter = null;
        this.form.reset();
        this.initFilter();
        if (emitEvent) {
            this.filterClear.emit();
        }
    }
    applyFilter() {
        const filterValue = this.getFilterValue();
        // If the filter is not null declare it, else - clear it.
        if (filterValue) {
            const filter = {
                fieldId: this.field.id,
                operator: this.operator,
                operatorUnit: this.operatorUnit,
                value: filterValue,
            };
            this._filter = filter;
            this.filterChange.emit(filter);
        }
        else {
            this.clearFilter();
        }
    }
    ngOnInit() {
        if (this.form) {
            this.updateValidity();
        }
    }
    ngOnChanges() {
        // if (this.form) {
        //     this.updateValidity();
        // }
    }
    ngOnDestroy() {
        this._destroyed.next();
        this._destroyed.complete();
        this.actionsContainerRef.destroy();
    }
}
BaseFilterComponent.decorators = [
    { type: Directive, args: [{},] }
];
BaseFilterComponent.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: FormBuilder },
    { type: TranslateService },
    { type: PepValidatorService },
    { type: Renderer2 }
];
BaseFilterComponent.propDecorators = {
    field: [{ type: Input }],
    filter: [{ type: Input }],
    filterClear: [{ type: Output }],
    filterChange: [{ type: Output }]
};

class PepBooleanFilterComponent extends BaseFilterComponent {
    // Override
    getDefaultOperator() {
        return PepSmartFilterOperators.Equals;
    }
    // Override
    getFilterValue() {
        const filterValue = { first: this.firstControl.value || false };
        return filterValue;
    }
}
PepBooleanFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-boolean-filter',
                template: "<div [formGroup]=\"form\">\n    <mat-radio-group class=\"radio-group\" [formControlName]=\"firstControlKey\">\n        <mat-radio-button class=\"pep-radio-button md pep-input no-default-background\" value=\"true\">\n            {{ 'CHECKBOX.TRUE' | translate }}\n        </mat-radio-button>\n        <mat-radio-button class=\"pep-radio-button md pep-input no-default-background\" value=\"false\">\n            {{ 'CHECKBOX.FALSE' | translate }}\n        </mat-radio-button>\n    </mat-radio-group>\n</div>",
                styles: [".radio-group{display:flex;flex-direction:column}.radio-group .pep-radio-button.pep-input{height:2.25rem;display:flex}"]
            },] }
];

class PepDateFilterComponent extends BaseFilterComponent {
    constructor() {
        super(...arguments);
        this.PepSmartFilterOperators = PepSmartFilterOperators;
        this.chooseTimeOptions = [];
        this.chooseTimeUnitOptions = [];
    }
    // Override
    getDefaultOperator() {
        return PepSmartFilterOperators.InTheLast;
    }
    // Override
    getDefaultOperatorUnit() {
        if (this.operator === PepSmartFilterOperators.InTheLast ||
            this.operator === PepSmartFilterOperators.NotInTheLast ||
            this.operator === PepSmartFilterOperators.DueIn ||
            this.operator === PepSmartFilterOperators.NotDueIn) {
            return PepSmartFilterOperatorUnits.Months;
        }
        else {
            return undefined;
        }
    }
    // Override
    getFilterValue() {
        const filterValue = {
            first: this.firstControl.value,
        };
        if (this.operator === PepSmartFilterOperators.DateRange) {
            filterValue['second'] = this.secondControl.value;
        }
        return filterValue;
    }
    // Override
    loadOperatorsOptions() {
        this.chooseTimeOptions = this.operators.map((operator) => {
            return {
                key: operator.id,
                value: this.translate.instant(`${this.OPERATORS_TRANSLATION_PREFIX}.${operator.name}`),
            };
        });
        this.chooseTimeUnitOptions = this.operatorUnits.map((operatorUnit) => {
            return {
                key: operatorUnit.id,
                value: this.translate.instant(`${this.OPERATOR_UNITS_TRANSLATION_PREFIX}.${operatorUnit.name}`),
            };
        });
    }
    // Override
    setFieldsStateAndValidators() {
        this.firstControl.enable();
        if (this.operator === PepSmartFilterOperators.DateRange) {
            this.firstControl.setValidators(Validators.required);
            this.secondControl.enable();
            this.secondControl.setValidators(Validators.required);
        }
        else if (this.operator === PepSmartFilterOperators.InTheLast ||
            this.operator === PepSmartFilterOperators.NotInTheLast ||
            this.operator === PepSmartFilterOperators.DueIn ||
            this.operator === PepSmartFilterOperators.NotDueIn) {
            this.firstControl.setValidators([
                Validators.required,
                this.validator.numberValidator(),
            ]);
            this.secondControl.disable();
        }
        else {
            // Disable 'first' field.
            if (this.operator === PepSmartFilterOperators.Today ||
                this.operator === PepSmartFilterOperators.ThisWeek ||
                this.operator === PepSmartFilterOperators.ThisMonth ||
                this.operator === PepSmartFilterOperators.IsEmpty ||
                this.operator === PepSmartFilterOperators.IsNotEmpty) {
                this.firstControl.disable();
            }
            // Default disable 'second' field.
            super.setFieldsStateAndValidators();
        }
    }
    onOperatorChanged(value) {
        const operator = Object.values(PepSmartFilterOperators).find((operator) => operator.id === value);
        this.operator = operator;
        this.operatorUnit = this.getDefaultOperatorUnit();
    }
    onTimeUnitChanged(value) {
        const operatorUnit = Object.values(PepSmartFilterOperatorUnits).find((operatorUnit) => operatorUnit.id === value);
        this.operatorUnit = operatorUnit;
    }
}
PepDateFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-date-filter',
                template: "<div [formGroup]=\"form\">\n    <ng-container>\n        <pep-select [key]=\"'timeOperator'\" [value]=\"operator.id\" [label]=\"'SMART_FILTERS.CHOOSE_TIME' | translate\"\n            [emptyOption]=\"false\" [options]=\"chooseTimeOptions\" (valueChange)=\"onOperatorChanged($event)\">\n        </pep-select>\n    </ng-container>\n\n    <div *ngIf=\"operator === PepSmartFilterOperators.InTheLast ||\n                operator === PepSmartFilterOperators.NotInTheLast ||\n                operator === PepSmartFilterOperators.DueIn ||\n                operator === PepSmartFilterOperators.NotDueIn\" fxLayout=\"row\" fxLayout.xs=\"column\" fxLayoutGap=\"1rem\">\n        <!-- Amount -->\n        <pep-textbox [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.AMOUNT' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"'int'\" [formattedValue]=\"firstControl.value\"\n            [value]=\"firstControl.value\">\n        </pep-textbox>\n        <!-- Time unit -->\n        <pep-select [form]=\"form\" [key]=\"'timeUnit'\" [value]=\"operatorUnit?.id\"\n            [label]=\"'SMART_FILTERS.TIME_UNIT' | translate\" fxFlex=\"50%\" [emptyOption]=\"false\"\n            [options]=\"chooseTimeUnitOptions\" (valueChange)=\"onTimeUnitChanged($event)\">\n        </pep-select>\n    </div>\n    <div pepRtlDirection *ngIf=\"operator === PepSmartFilterOperators.DateRange\" fxLayout=\"row\" fxLayout.xs=\"column\"\n        fxLayoutGap=\"1rem\">\n        <!-- Start date -->\n        <pep-date [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.START_DATE' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type === 'date' ? 'date' : 'datetime'\"\n            [value]=\"firstControl.value\" [maxDateValue]=\"secondControl.value\">\n        </pep-date>\n        <!-- End date -->\n        <pep-date [form]=\"form\" [key]=\"secondControlKey\" [label]=\"'SMART_FILTERS.END_DATE' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type === 'date' ? 'date' : 'datetime'\"\n            [value]=\"secondControl.value\" [minDateValue]=\"firstControl.value\">\n        </pep-date>\n    </div>\n    <ng-container *ngIf=\"operator === PepSmartFilterOperators.On\">\n        <!-- Choose a date -->\n        <pep-date [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.CHOOSE_DATE' | translate\"\n            [renderError]=\"false\" [type]=\"field.type === 'date' ? 'date' : 'datetime'\" [value]=\"firstControl.value\">\n        </pep-date>\n    </ng-container>\n</div>",
                styles: [""]
            },] }
];

class PepMultiSelectFilterOption {
    constructor() {
        this.selected = false;
    }
}
class PepMultiSelectFilterComponent extends BaseFilterComponent {
    constructor() {
        super(...arguments);
        this.options = [];
        this.searchControl = new FormControl();
        this.MAX_OPTIONS_TO_SHOW = 6.35;
        this.numberOptionsToShowSearch = 10;
    }
    ngOnInit() {
        var _a;
        super.ngOnInit;
        if (((_a = this.field.options) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            this.options = this.field.options.map((opt) => {
                return { value: opt.value, count: opt.count, selected: false };
            });
        }
        else {
            this.searchControl.disable();
        }
        // Init the selected values from first value.
        const firstControl = this.firstControl;
        if (firstControl.value) {
            this.initOptionsSelectedValues(firstControl.value);
        }
        // Add subscription for the first value change to set the selected options.
        firstControl.valueChanges
            .pipe(this.getDestroyer(), distinctUntilChanged())
            .subscribe((selectedValues) => {
            this.initOptionsSelectedValues(selectedValues);
        });
        // Filter the options by the search control.
        this.filteredOptions$ = this.searchControl.valueChanges.pipe(this.getDestroyer(), startWith(''), map((option) => typeof option === 'string' ? option : option && option.value), map((value) => (value ? this.filterOptions(value) : this.options)));
        // Each time the filter change.
        this.filteredOptions$.subscribe((filterdOptions) => {
            this.calcOptionsHeight(filterdOptions.length);
            setTimeout(() => {
                // 8 is the padding top of the multi-select-options
                this.virtualScroller.scrollToPosition(-8);
            }, 125);
        });
    }
    ngAfterViewInit() {
        // Calc for the first time.
        this.calcOptionsHeight(this.options.length);
    }
    initOptionsSelectedValues(selectedValues) {
        this.options.forEach((opt) => {
            const isValueSelected = selectedValues && selectedValues.includes(opt.value);
            opt.selected = isValueSelected;
        });
    }
    calcOptionsHeight(optionsCount) {
        if (this.optionsContainer) {
            const optionsToShow = optionsCount > this.MAX_OPTIONS_TO_SHOW
                ? this.MAX_OPTIONS_TO_SHOW
                : optionsCount;
            // optionsToShow * 2.25 is 1 option height + 1 is the padding top & bottom of the container.
            const optionsHeight = optionsToShow * 2.25 + 1 + 'rem';
            this.renderer.setStyle(this.optionsContainer.nativeElement, 'height', optionsHeight);
        }
    }
    filterOptions(value) {
        const filterValue = value.toLowerCase();
        return this.options.filter((opt) => opt.value &&
            opt.value.toLowerCase().includes(filterValue.toLowerCase()));
    }
    // Override
    getDefaultOperator() {
        return PepSmartFilterOperators.In;
    }
    // Override
    getFilterValue() {
        const selectedValues = this.options
            .filter((opt) => opt.selected)
            .map((opt) => opt.value);
        const filterValue = {
            first: selectedValues,
        };
        return selectedValues.length > 0 ? filterValue : null;
    }
    // Override
    initFilter() {
        this.options.forEach((opt) => (opt.selected = false));
        this.searchControl.setValue('');
    }
    onOptionChange(option, event) {
        option.selected = event.checked;
        this.firstControl.setValue(this.options.filter((opt) => opt.selected).map((opt) => opt.value), { emitEvent: false });
    }
}
PepMultiSelectFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-multi-select-filter',
                template: "<div [formGroup]=\"form\">\n    <pep-search *ngIf=\"options?.length > numberOptionsToShowSearch\" [searchControl]=\"searchControl\"\n        [triggerOn]=\"'keydown'\" [shrinkInSmallScreen]=\"false\"></pep-search>\n    <div pepRtlClass class=\"multi-select-options pep-border-top pep-border-bottom\"\n        [ngClass]=\"{'with-no-search': options?.length <= numberOptionsToShowSearch}\">\n        <div #optionsContainer class=\"flip-scroll\" pepRtlClass>\n            <virtual-scroller #scroll [items]=\"filteredOptions$ | async\" [parentScroll]=\"optionsContainer\">\n                <mat-checkbox *ngFor=\"let opt of scroll.viewPortItems\"\n                    class=\"pep-checkbox-container pep-input no-default-background md\" [title]=\"opt.value\"\n                    [checked]=\"opt.selected\" (change)=\"onOptionChange(opt, $event)\">\n                    <div class=\"title\">\n                        <span class=\"body-sm ellipsis\">{{ opt.value }}</span>\n                        <span *ngIf=\"opt.count\" class=\"color-dimmed body-xs ellipsis\">({{opt.count}})</span>\n                    </div>\n                </mat-checkbox>\n                <ng-container *ngIf=\"scroll.viewPortItems?.length === 0\">\n                    <span class=\"no-options body-sm ellipsis\" [title]=\"field.name\">\n                        {{ ( options.length > 0 ? \"SMART_FILTERS.NO_SEARCH_RESULTS\" : \"SMART_FILTERS.NO_OPTIONS\") |\n                        translate }}\n                    </span>\n                </ng-container>\n            </virtual-scroller>\n        </div>\n    </div>\n</div>",
                styles: [".multi-select-options{margin:.5rem calc(.25rem * -1) 0;margin:var(--pep-spacing-sm,.5rem) calc(var(--pep-spacing-xs, .25rem) * -1) 0}.multi-select-options.with-no-search{margin:calc(.5rem * -1) calc(.25rem * -1) 0;margin:calc(var(--pep-spacing-sm, .5rem) * -1) calc(var(--pep-spacing-xs, .25rem) * -1) 0}.multi-select-options .no-options{display:flex;padding:.5rem .75rem;padding:var(--pep-spacing-sm,.5rem) var(--pep-spacing-md,.75rem)}.multi-select-options .flip-scroll{padding:.5rem .25rem;padding:var(--pep-spacing-sm,.5rem) var(--pep-spacing-xs,.25rem);min-height:3.25rem;max-height:34.75rem;direction:rtl}.multi-select-options .flip-scroll.rtl,.multi-select-options .flip-scroll virtual-scroller{direction:ltr}.multi-select-options .flip-scroll.rtl virtual-scroller{direction:rtl}.multi-select-options .pep-checkbox-container{height:2.25rem;-webkit-padding-end:0;padding-inline-end:0}.multi-select-options .pep-checkbox-container ::ng-deep.mat-checkbox-layout{width:100%;height:100%;grid-template-columns:auto 1fr}.multi-select-options .pep-checkbox-container ::ng-deep.mat-checkbox-layout .mat-checkbox-label{align-self:center}.multi-select-options .pep-checkbox-container .title{display:flex;justify-content:space-between;align-items:center;margin:0 .25rem;margin:0 var(--pep-spacing-xs,.25rem)}"]
            },] }
];
PepMultiSelectFilterComponent.propDecorators = {
    optionsContainer: [{ type: ViewChild, args: ['optionsContainer',] }],
    virtualScroller: [{ type: ViewChild, args: [VirtualScrollerComponent,] }]
};

class PepNumberFilterComponent extends BaseFilterComponent {
    constructor() {
        super(...arguments);
        this.PepSmartFilterOperators = PepSmartFilterOperators;
        this.chooseTypeOptions = [];
    }
    ngOnInit() {
        this.firstControl.valueChanges
            .pipe(this.getDestroyer(), distinctUntilChanged())
            .subscribe(() => {
            this.setFieldsStateAndValidators();
        });
        this.secondControl.valueChanges
            .pipe(this.getDestroyer(), distinctUntilChanged())
            .subscribe(() => {
            this.setFieldsStateAndValidators();
        });
    }
    // Override
    getDefaultOperator() {
        return PepSmartFilterOperators.Equals;
    }
    // Override
    getFilterValue() {
        const filterValue = {
            first: this.firstControl.value,
        };
        if (this.operator === PepSmartFilterOperators.NumberRange) {
            filterValue['second'] = this.secondControl.value;
        }
        return filterValue;
    }
    // Override
    loadOperatorsOptions() {
        this.chooseTypeOptions = this.operators.map((operator) => {
            return {
                key: operator.id,
                value: this.translate.instant(`${this.OPERATORS_TRANSLATION_PREFIX}.${operator.name}`),
            };
        });
    }
    // Override
    setFieldsStateAndValidators() {
        if (this.operator === PepSmartFilterOperators.NumberRange) {
            const firstValidators = [Validators.required];
            if (this.secondControl.value) {
                firstValidators.push(this.validator.isLessThan(this.secondControl));
            }
            this.firstControl.setValidators(firstValidators);
            this.secondControl.enable();
            const secondValidators = [Validators.required];
            if (this.firstControl.value) {
                secondValidators.push(this.validator.isGreaterThan(this.firstControl));
            }
            this.secondControl.setValidators(secondValidators);
        }
        else {
            super.setFieldsStateAndValidators();
        }
    }
    onOperatorChanged(value) {
        const operator = Object.values(PepSmartFilterOperators).find((operator) => operator.id === value);
        this.operator = operator;
    }
}
PepNumberFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-number-filter',
                template: "<div [formGroup]=\"form\">\n    <ng-container>\n        <pep-select [key]=\"'typeOperator'\" [value]=\"operator.id\" [label]=\"'SMART_FILTERS.TYPE' | translate\"\n            [emptyOption]=\"false\" [options]=\"chooseTypeOptions\" (valueChange)=\"onOperatorChanged($event)\">\n        </pep-select>\n    </ng-container>\n    <div *ngIf=\"operator !== PepSmartFilterOperators.NumberRange\">\n        <!-- Amount -->\n        <pep-textbox [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.AMOUNT' | translate\"\n            [renderError]=\"false\" [type]=\"field.type\" [formattedValue]=\"firstControl.value\"\n            [value]=\"firstControl.value\">\n        </pep-textbox>\n    </div>\n    <div *ngIf=\"operator === PepSmartFilterOperators.NumberRange\" fxLayout=\"row\" fxLayout.xs=\"column\"\n        fxLayoutGap=\"1rem\">\n        <!-- Min number -->\n        <pep-textbox [form]=\"form\" [key]=\"firstControlKey\" [label]=\"'SMART_FILTERS.MIN' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type\" [formattedValue]=\"firstControl.value\"\n            [value]=\"firstControl.value\" [maxValue]=\"secondControl.value\">\n        </pep-textbox>\n        <!-- Max number -->\n        <pep-textbox [form]=\"form\" [key]=\"secondControlKey\" [label]=\"'SMART_FILTERS.MAX' | translate\"\n            [renderError]=\"false\" fxFlex=\"50%\" [type]=\"field.type\" [formattedValue]=\"secondControl.value\"\n            [value]=\"secondControl.value\" [minValue]=\"firstControl.value\">\n        </pep-textbox>\n    </div>\n</div>",
                styles: [""]
            },] }
];

class PepSmartFiltersModule {
    constructor(pepIconRegistry) {
        this.pepIconRegistry = pepIconRegistry;
        this.pepIconRegistry.registerIcons([
            pepIconNumberMinus,
            pepIconNumberPlus,
        ]);
    }
}
PepSmartFiltersModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FlexLayoutModule,
                    // Material modules
                    MatCommonModule,
                    MatCheckboxModule,
                    MatChipsModule,
                    MatExpansionModule,
                    MatIconModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatRadioModule,
                    // External modules
                    VirtualScrollerModule,
                    // ngx-lib modules
                    PepNgxLibModule,
                    PepCheckboxModule,
                    PepDateModule,
                    PepSelectModule,
                    PepTextboxModule,
                    PepSearchModule,
                    PepIconModule,
                ],
                exports: [PepSmartFiltersComponent],
                declarations: [
                    // BaseFilterComponent,
                    PepSmartFiltersComponent,
                    PepFilterActionsComponent,
                    PepBooleanFilterComponent,
                    PepDateFilterComponent,
                    PepMultiSelectFilterComponent,
                    PepNumberFilterComponent,
                ],
            },] }
];
PepSmartFiltersModule.ctorParameters = () => [
    { type: PepIconRegistry }
];

// Base field
// ------------------------------
class PepSmartFilterBaseField {
    constructor(field) {
        this.id = field.id;
        this.name = field.name;
        this.isOpen = field.isOpen;
        this.options = field.options;
        this.operators = field.operators;
        this.operatorUnits = field.operatorUnits;
        this._type = this.getType();
    }
    get componentType() {
        return this._componentType;
    }
    get type() {
        return this._type;
    }
}
// Boolean field
// ------------------------------
class PepSmartFilterBooleanField extends PepSmartFilterBaseField {
    constructor(field) {
        super(field);
        this._componentType = 'boolean';
    }
    getType() {
        return 'boolean';
    }
}
// Date fields
// ------------------------------
class PepSmartFilterDateBaseField extends PepSmartFilterBaseField {
    constructor(field) {
        super(field);
        this._componentType = 'date';
    }
}
class PepSmartFilterDateField extends PepSmartFilterDateBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'date';
    }
}
class PepSmartFilterDateTimeField extends PepSmartFilterDateBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'date-time';
    }
}
// Multi select field
// ------------------------------
class PepSmartFilterMultiSelectField extends PepSmartFilterBaseField {
    constructor(field) {
        super(field);
        this._componentType = 'multi-select';
    }
    getType() {
        return 'multi-select';
    }
}
// Number fields
// ------------------------------
class PepSmartFilterNumberBaseField extends PepSmartFilterBaseField {
    constructor(field) {
        super(field);
        this._componentType = 'number';
    }
}
class PepSmartFilterIntField extends PepSmartFilterNumberBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'int';
    }
}
class PepSmartFilterRealField extends PepSmartFilterNumberBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'real';
    }
}
class PepSmartFilterCurrencyField extends PepSmartFilterNumberBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'currency';
    }
}
class PepSmartFilterPercentageField extends PepSmartFilterNumberBaseField {
    constructor(field) {
        super(field);
    }
    getType() {
        return 'percentage';
    }
}

function createBooleanSmartFilterField(data) {
    return new PepSmartFilterBooleanField(data);
}
function createDateSmartFilterField(data) {
    return new PepSmartFilterDateField(data);
}
function createDateTimeSmartFilterField(data) {
    return new PepSmartFilterDateTimeField(data);
}
function createMultiSelectSmartFilterField(data) {
    return new PepSmartFilterMultiSelectField(data);
}
function createIntSmartFilterField(data) {
    return new PepSmartFilterIntField(data);
}
function createRealSmartFilterField(data) {
    return new PepSmartFilterRealField(data);
}
function createCurrencySmartFilterField(data) {
    return new PepSmartFilterCurrencyField(data);
}
function createPercentageSmartFilterField(data) {
    return new PepSmartFilterPercentageField(data);
}
function createSmartFilterField(data, type) {
    let field;
    switch (type) {
        case 'boolean':
            field = createBooleanSmartFilterField(data);
            break;
        case 'date':
            field = createDateSmartFilterField(data);
            break;
        case 'date-time':
            field = createDateTimeSmartFilterField(data);
            break;
        case 'multi-select':
            field = createMultiSelectSmartFilterField(data);
            break;
        case 'int':
            field = createIntSmartFilterField(data);
            break;
        case 'real':
            field = createRealSmartFilterField(data);
            break;
        case 'currency':
            field = createCurrencySmartFilterField(data);
            break;
        case 'percentage':
            field = createPercentageSmartFilterField(data);
            break;
        default:
            field = createMultiSelectSmartFilterField(data);
            break;
    }
    return field;
}
function createSmartFilter(fieldId, operator, first, second, operatorUnit) {
    return {
        fieldId: fieldId,
        operator: operator,
        operatorUnit: operatorUnit,
        value: {
            first: first,
            second: second,
        },
    };
}

/*
 * Public API Surface of ngx-lib/smart-filters
 */

/**
 * Generated bundle index. Do not edit.
 */

export { BaseFilterComponent, IPepSmartFilterOperator, IPepSmartFilterOperatorUnit, PepBooleanFilterComponent, PepDateFilterComponent, PepFilterActionsComponent, PepMultiSelectFilterComponent, PepNumberFilterComponent, PepSmartFilterBaseField, PepSmartFilterBooleanField, PepSmartFilterCurrencyField, PepSmartFilterDateBaseField, PepSmartFilterDateField, PepSmartFilterDateTimeField, PepSmartFilterIntField, PepSmartFilterMultiSelectField, PepSmartFilterNumberBaseField, PepSmartFilterOperatorUnits, PepSmartFilterOperators, PepSmartFilterPercentageField, PepSmartFilterRealField, PepSmartFiltersComponent, PepSmartFiltersModule, createSmartFilter, createSmartFilterField };
//# sourceMappingURL=pepperi-addons-ngx-lib-smart-filters.js.map
