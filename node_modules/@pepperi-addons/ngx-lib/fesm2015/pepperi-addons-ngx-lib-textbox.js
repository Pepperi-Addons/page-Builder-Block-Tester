import { EventEmitter, Component, ChangeDetectionStrategy, Renderer2, ElementRef, HostBinding, Input, Output, ViewChild, Directive, HostListener, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormBuilder, ReactiveFormsModule } from '@angular/forms';
import { MatCommonModule } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { DEFAULT_HORIZONTAL_ALIGNMENT, PepTextboxField, PepCustomizationService, PepUtilitiesService, PepValidatorService, PepNgxLibModule } from '@pepperi-addons/ngx-lib';
import { pepIconSystemEdit, PepIconModule, PepIconRegistry } from '@pepperi-addons/ngx-lib/icon';
import { PepTextboxIconModule } from '@pepperi-addons/ngx-lib/textbox-icon';
import { PepFieldTitleModule } from '@pepperi-addons/ngx-lib/field-title';
import { TranslateService } from '@ngx-translate/core';

/**
 * This is a text box input component that can be use to
 *
 * @export
 * @class PepTextboxComponent
 * @implements {OnChanges}
 * @implements {OnInit}
 * @implements {OnDestroy}
 */
class PepTextboxComponent {
    constructor(fb, customizationService, renderer, element, translate, utilitiesService) {
        this.fb = fb;
        this.customizationService = customizationService;
        this.renderer = renderer;
        this.element = element;
        this.translate = translate;
        this.utilitiesService = utilitiesService;
        this.dataQa = '';
        this._key = '';
        this._value = null;
        this._formattedValue = null;
        /**
         * The title of the textbox.
         *
         * @memberof PepTextboxComponent
         */
        this.label = '';
        /**
         * The placeholder (relevant only for children - if parent isn't null).
         *
         * @memberof PepTextboxComponent
         */
        this.placeholder = '';
        /**
         * The type of the textbox.
         *
         * @type {PepTextboxFieldType}
         * @memberof PepTextboxComponent
         */
        this.type = 'text';
        /**
         * If the textbox is mandatory
         *
         * @memberof PepTextboxComponent
         */
        this.mandatory = false;
        // TODO: Check if should remove disabled and keep only readonly.
        /**
         * If the textbox is disabled.
         *
         * @memberof PepTextboxComponent
         */
        this.disabled = false;
        /**
         * If the textbox is readonly
         *
         * @memberof PepTextboxComponent
         */
        this.readonly = false;
        this.textColor = '';
        this.xAlignment = DEFAULT_HORIZONTAL_ALIGNMENT;
        this.rowSpan = 1;
        // @Input() lastFocusField: any;
        this.minValue = NaN;
        this.maxValue = NaN;
        this._visible = true;
        this.form = null;
        this.isActive = false;
        this.showTitle = true;
        this.renderTitle = true;
        this.renderError = true;
        this.renderSymbol = true;
        this.layoutType = 'form';
        this.parentFieldKey = null;
        /**
         * The value change event.
         *
         * @type {EventEmitter<string>}
         * @memberof PepTextboxComponent
         */
        this.valueChange = new EventEmitter();
        this.formValidationChange = new EventEmitter();
        this._calculateFormattedValue = true;
        this.controlType = 'textbox';
        this.standAlone = false;
        this.isInEditMode = false;
        this.isInFocus = false;
    }
    /**
     * The text box key
     *
     * @memberof PepTextboxComponent
     */
    set key(value) {
        this._key = value;
        this.dataQa = value;
    }
    get key() {
        return this._key;
    }
    /**
     * The value of the text box.
     *
     * @memberof PepTextboxComponent
     */
    set value(value) {
        if (!value) {
            value = '';
        }
        this._value = value;
        if (this._calculateFormattedValue) {
            this.setFormattedValue(value);
        }
    }
    get value() {
        return this._value;
    }
    /**
     * The formatted value.
     *
     * @memberof PepTextboxComponent
     */
    set formattedValue(value) {
        if (!value) {
            value = '';
        }
        if (this._calculateFormattedValue) {
            this._calculateFormattedValue = false;
        }
        this.setFormattedValue(value);
    }
    get formattedValue() {
        return this._formattedValue;
    }
    set visible(visible) {
        this._visible = visible;
        if (visible) {
            this.renderer.removeClass(this.element.nativeElement, 'hidden-element');
        }
        else {
            this.renderer.addClass(this.element.nativeElement, 'hidden-element');
        }
    }
    get visible() {
        return this._visible;
    }
    get calculateFormattedValue() {
        return this._calculateFormattedValue;
    }
    setFormattedValue(value) {
        if (this._calculateFormattedValue) {
            this._formattedValue = this.isNumberType()
                ? this.utilitiesService.formatNumber(value)
                : value;
        }
        else {
            this._formattedValue = value;
        }
        this.updateFormFieldValue();
    }
    updateFormFieldValue() {
        this.customizationService.updateFormFieldValue(this.form, this.key, this.formattedValue, this.parentFieldKey);
    }
    get displayValue() {
        let res = '';
        if (this.type == 'link') {
            res = this.formattedValue;
        }
        else {
            res = this.isInFocus ? this.value : this.formattedValue;
        }
        return res;
    }
    setDefaultForm() {
        const pepField = new PepTextboxField({
            key: this.key,
            value: this.value,
            mandatory: this.mandatory,
            readonly: this.readonly,
            disabled: this.disabled,
            maxFieldCharacters: this.maxFieldCharacters,
            type: this.type,
            minValue: this.minValue,
            maxValue: this.maxValue,
        });
        this.form = this.customizationService.getDefaultFromGroup(pepField, this.renderError);
    }
    ngOnInit() {
        if (this.form === null) {
            this.standAlone = true;
            this.minValue =
                isNaN(this.minValue) && !isNaN(this.maxValue)
                    ? 0
                    : this.minValue;
            this.maxValue =
                isNaN(this.maxValue) && !isNaN(this.minValue)
                    ? 99999
                    : this.maxValue;
            this.setDefaultForm();
            this.renderer.addClass(this.element.nativeElement, PepCustomizationService.STAND_ALONE_FIELD_CLASS_NAME);
        }
        this.readonly = this.type === 'duration' ? true : this.readonly; // Hack until we develop Timer UI for editing Duration field
        this.updateFormFieldValue();
    }
    ngOnChanges(changes) {
        if (this.standAlone) {
            this.setDefaultForm();
        }
        this.readonly = this.type === 'duration' ? true : this.readonly; // Hack until we develop Timer UI for editing Duration field
    }
    ngOnDestroy() {
        //
    }
    onFocus(event) {
        this.isInFocus = true;
        // select the value in focus (DI-18246 improvement)
        setTimeout(() => {
            const eventTarget = event.target || event.srcElement;
            if (eventTarget) {
                eventTarget.select();
            }
        }, 0);
    }
    isNumberType() {
        return (this.type === 'percentage' ||
            this.type === 'currency' ||
            this.type === 'int' ||
            this.type === 'real');
    }
    isValueValid(value) {
        let res = false;
        if (this.isNumberType()) {
            if (value === '') {
                res = this.mandatory ? false : true;
            }
            else {
                const numberValue = this.utilitiesService.coerceNumberProperty(value);
                res =
                    numberValue >= this.minValue &&
                        numberValue <= this.maxValue;
            }
        }
        else {
            // TODO: Maybe need to check other types.
            res = true;
        }
        return res;
    }
    isDifferentValue(value) {
        let res = false;
        if (this.isNumberType()) {
            if (this.value === '' || value === '') {
                res = true;
            }
            else {
                const currentValue = this.utilitiesService.coerceNumberProperty(this.value);
                const newValue = this.utilitiesService.coerceNumberProperty(value);
                res = currentValue !== newValue;
            }
        }
        else {
            res = true;
        }
        return res;
    }
    onChange(e) {
        const value = e.target ? e.target.value : e;
        // TODO: uncomment
        // this.valueChange.emit(value);
    }
    onBlur(e) {
        this.isInFocus = false;
        const value = e.target ? e.target.value : e;
        if (value !== this.value && this.isDifferentValue(value)) {
            // If renderError is false and the new value is not valid.
            if (!this.renderError && !this.isValueValid(value)) {
                this.renderer.setProperty(this.input.nativeElement, 'value', this.value);
            }
            else {
                this.value = value;
                // If the user is setting the formatted value then set the value till the user format it and return it back.
                if (!this._calculateFormattedValue) {
                    this._formattedValue = value;
                }
                this.valueChange.emit(value);
            }
        }
        if (this.isInEditMode) {
            this.isInEditMode = false;
        }
    }
    anchorClicked() {
        const currentValue = this.value;
        if (currentValue.trim().length > 0) {
            switch (this.type) {
                case 'email':
                    window.open('mailto:' + currentValue, 'email');
                    break;
                case 'phone':
                    window.open('tel:' + currentValue, 'tel');
                    break;
                case 'link':
                    window.open(currentValue);
                    break;
                default:
                    break;
            }
        }
    }
    cardTemplateClicked(event) {
        this.isInEditMode = true;
        setTimeout(() => {
            this.input.nativeElement.focus();
        }, 0);
    }
}
PepTextboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-textbox',
                template: "<ng-container [formGroup]=\"form\">\n    <ng-template #pepTemplate let-isFormView=\"isFormView\" let-hasParent=\"hasParent\">\n        <pep-field-title *ngIf=\"renderTitle && isFormView && !hasParent\" [label]=\"label\" [mandatory]=\"mandatory\"\n            [disabled]=\"disabled\" [maxFieldCharacters]=\"maxFieldCharacters\" [xAlignment]=\"xAlignment\"\n            [showTitle]=\"showTitle\" [inputLength]=\"input.value?.length\">\n        </pep-field-title>\n        <mat-form-field appearance=\"outline\">\n            <input #input pepTextboxValidation [id]=\"key\" [name]=\"key\" class=\" body-sm \" matInput autocomplete=\"off\"\n                maxlength=\"{{ maxFieldCharacters > 0 ? maxFieldCharacters : 99999 }}\"\n                [placeholder]=\"hasParent && !disabled ? placeholder : ''\"\n                [ngStyle]=\"{ color: textColor, 'text-align': xAlignment == 'center' ? 'center' : xAlignment == 'right' ? 'right' : 'left' }\"\n                title=\"{{ formattedValue }}\" [formControlName]=\"key\" [type]=\"type\" [value]=\"displayValue\"\n                (keyup.enter)=\"$event?.currentTarget?.blur()\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\"\n                (change)=\"onChange($event)\"\n                [ngClass]=\"{'disable-hidden': disabled && formattedValue?.length > 0 && (type === 'phone' || type === 'email' || type === 'link')}\" />\n\n            <span\n                *ngIf=\"disabled && formattedValue?.length > 0 && (type === 'phone' || type === 'email' || type === 'link')\"\n                class=\"dis-grid\">\n                <a href=\"javascript:void(0)\" (click)=\"anchorClicked()\" [id]=\"key\" [name]=\"key\"\n                    class=\"color-link body-sm \"> {{formattedValue}}</a>\n            </span>\n            <mat-error *ngIf=\"renderError\">\n                <ng-container *ngIf=\"mandatory && input.value.length == 0 then requiredError else otherError\">\n                </ng-container>\n                <ng-template #requiredError>\n                    <span class=\"body-xs\" [title]=\"('MESSAGES.ERROR_IS_REQUIRED' | translate: { field: label })\"\n                        [innerText]=\"('MESSAGES.ERROR_IS_REQUIRED' | translate: { field: label })\">\n                    </span>\n                </ng-template>\n                <ng-template #otherError>\n                    <span class=\"body-xs\" [title]=\"(input.value | pepToNumber) > this.maxValue || (input.value | pepToNumber) < this.minValue ?\n                            ('MESSAGES.ERROR_RANGE_IS_NOT_VALID' | translate: { min: minValue, max: maxValue }) :\n                            ('MESSAGES.ERROR_IS_NOT_VALID' | translate: { field: label })\" [innerText]=\"(input.value | pepToNumber) > this.maxValue || (input.value | pepToNumber) < this.minValue ?\n                            ('MESSAGES.ERROR_RANGE_IS_NOT_VALID' | translate: { min: minValue, max: maxValue }) :\n                            ('MESSAGES.ERROR_IS_NOT_VALID' | translate: { field: label })\">\n                    </span>\n                </ng-template>\n            </mat-error>\n\n            <pep-textbox-icon *ngIf=\"renderSymbol && isFormView && xAlignment == 'right'\" matPrefix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\">\n            </pep-textbox-icon>\n            <pep-textbox-icon *ngIf=\"renderSymbol && isFormView && (xAlignment == 'left')\" matSuffix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\">\n            </pep-textbox-icon>\n        </mat-form-field>\n    </ng-template>\n\n    <ng-container *ngIf=\"layoutType === 'form'\">\n        <ng-container *ngIf=\"parentFieldKey; then groupedBlock; else regularBlock\"></ng-container>\n        <ng-template #regularBlock>\n            <ng-container *ngTemplateOutlet=\"pepTemplate; context: { isFormView: true, hasParent: false }\">\n            </ng-container>\n        </ng-template>\n        <ng-template #groupedBlock>\n            <ng-container [formGroupName]=\"parentFieldKey\">\n                <mat-form-field appearance=\"outline\">\n                    <!-- (keyup)=\"onKeyUp($event)\"  -->\n                    <input pepTextboxValidation [id]=\"key\" [name]=\"key\" class=\" body-sm \" matInput autocomplete=\"off\"\n                        [placeholder]=\"!disabled ? placeholder : ''\" title=\"{{ formattedValue }}\"\n                        [formControlName]=\"key\" [value]=\"value\" (blur)=\"onBlur($event)\" (change)=\"onChange($event)\"\n                        (keyup.enter)=\"$event?.currentTarget?.blur()\" (focus)=\"onFocus($event)\" />\n                </mat-form-field>\n                <!-- <ng-container *ngTemplateOutlet=\"pepTemplate; context: { isFormView: true, hasParent: true }\"></ng-container> -->\n            </ng-container>\n        </ng-template>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'card'\">\n        <ng-container *ngIf=\"isInEditMode; then editBlock; else readOnlyBlock\"></ng-container>\n        <ng-template #editBlock>\n            <div [ngClass]=\"{'one-row': rowSpan === 1}\">\n                <ng-container *ngTemplateOutlet=\"pepTemplate; context: { isFormView: false, hasParent: false }\">\n                </ng-container>\n            </div>\n        </ng-template>\n        <ng-template #readOnlyBlock>\n            <div class=\"pep-card-input card-flex-container\" [ngStyle]=\"{ color: textColor }\"\n                [class]=\"'text-align-' + xAlignment\" [ngClass]=\"{'one-row': rowSpan === 1,\n                            'multi-rows': rowSpan > 1,\n                            'pep-button weak': isActive && !disabled}\"\n                (click)=\"!disabled ? cardTemplateClicked($event) : ''\">\n                <span *ngIf=\"showTitle && label != ''\" class=\"body-xs title\" title=\"{{ label }}\">{{ label\n                    }}&nbsp;</span>\n                <span [id]=\"key\" title=\"{{ formattedValue }}\" class=\"body-sm value\"\n                    [ngClass]=\"{'multi-rows-text': rowSpan > 1}\" [ngStyle]=\"{ '-webkit-line-clamp': rowSpan }\">{{\n                    formattedValue }}</span>\n                <button *ngIf=\"isActive && !disabled\" class=\"pep-button weak card-edit-button\" mat-button>\n                    <mat-icon>\n                        <pep-icon name=\"system_edit\">\n                        </pep-icon>\n                    </mat-icon>\n                </button>\n            </div>\n        </ng-template>\n\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'table'\">\n        <ng-container *ngIf=\"isActive && !disabled; then selectedBlock; else notSelectedBlock\"></ng-container>\n        <ng-template #selectedBlock>\n            <ng-container *ngTemplateOutlet=\"pepTemplate; context: { isFormView: false, hasParent: false }\">\n            </ng-container>\n        </ng-template>\n        <ng-template #notSelectedBlock>\n            <ng-container *ngIf=\"formattedValue?.length > 0; then notEmptyBlock; else emptyBlock\"></ng-container>\n            <ng-template #notEmptyBlock>\n                <ng-container [ngSwitch]=\"type\">\n                    <ng-container *ngSwitchCase=\"'link'\">\n                        <a [id]=\"key\" class=\"color-link body-sm pep-report-input\"\n                            [ngClass]=\"{'disable': (disabled && value === '')}\" *ngIf=\"formattedValue != null\"\n                            title=\"{{ formattedValue }}\" target=\"_blank\" href=\"{{ value ? value : formattedValue }}\">{{\n                            formattedValue }}</a>\n                    </ng-container>\n                    <ng-container *ngSwitchDefault>\n                        <span [id]=\"key\" class=\"body-sm pep-report-input\" [ngClass]=\"{'readonly': disabled}\"\n                            title=\"{{ formattedValue }}\" [ngStyle]=\"{ color: textColor }\">{{ formattedValue }}</span>\n                    </ng-container>\n                </ng-container>\n            </ng-template>\n            <ng-template #emptyBlock>\n                <span [id]=\"key\">&nbsp;</span>\n            </ng-template>\n        </ng-template>\n    </ng-container>\n\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{height:inherit;display:grid}:host>*{align-self:center;align-items:baseline}.disable-hidden{display:none}.dis-grid{display:grid}.multi-rows-text{display:-webkit-box;-webkit-box-orient:vertical;overflow:hidden;text-overflow:ellipsis;white-space:normal!important}"]
            },] }
];
PepTextboxComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: PepCustomizationService },
    { type: Renderer2 },
    { type: ElementRef },
    { type: TranslateService },
    { type: PepUtilitiesService }
];
PepTextboxComponent.propDecorators = {
    dataQa: [{ type: HostBinding, args: ['attr.data-qa',] }],
    key: [{ type: Input }],
    value: [{ type: Input }],
    formattedValue: [{ type: Input }],
    label: [{ type: Input }],
    placeholder: [{ type: Input }],
    type: [{ type: Input }],
    mandatory: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    maxFieldCharacters: [{ type: Input }],
    textColor: [{ type: Input }],
    xAlignment: [{ type: Input }],
    rowSpan: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    visible: [{ type: Input }],
    form: [{ type: Input }],
    isActive: [{ type: Input }],
    showTitle: [{ type: Input }],
    renderTitle: [{ type: Input }],
    renderError: [{ type: Input }],
    renderSymbol: [{ type: Input }],
    layoutType: [{ type: Input }],
    parentFieldKey: [{ type: Input }],
    valueChange: [{ type: Output }],
    formValidationChange: [{ type: Output }],
    input: [{ type: ViewChild, args: ['input',] }]
};

class PepTextboxValidationDirective {
    constructor(hostElement, validatorService) {
        this.hostElement = hostElement;
        this.validatorService = validatorService;
        this.type = 'text';
        this.previousValue = '';
    }
    ngOnInit() {
        //
    }
    isNumber() {
        return this.isInteger() || this.isDecimal();
    }
    isInteger() {
        return this.type === 'int';
    }
    isDecimal() {
        return (this.type === 'currency' ||
            this.type === 'percentage' ||
            this.type === 'real');
    }
    isPhone() {
        return this.type === 'phone';
    }
    isText() {
        return (this.type === 'email' ||
            this.type === 'link' ||
            this.type === 'text');
    }
    onChange(e) {
        this.validateValue(this.hostElement.nativeElement.value);
    }
    onKeyDown(e) {
        const originalValue = e.target['value'];
        if (this.isNumber()) {
            // save value before keydown event
            this.previousValue = originalValue;
            const isNumber = this.validatorService.isNumber(e, this.isDecimal());
            if (isNumber)
                return;
            else
                e.preventDefault();
        }
        else if (this.isPhone()) {
            const isPhone = this.validatorService.isPhone(e);
            if (isPhone)
                return;
            else
                e.preventDefault();
        }
    }
    validateValue(value) {
        if (this.isNumber()) {
            const newValue = this.validatorService.validateNumber(value, this.isDecimal());
            this.hostElement.nativeElement['value'] = newValue ? newValue : 0;
        }
        else if (this.isPhone()) {
            // test phone with regular expression, when
            // phone is invalid, replace it with the previousValue
            const valid = this.validatorService.validatePhone(value);
            this.hostElement.nativeElement['value'] = valid
                ? value
                : this.previousValue;
        }
        else if (this.isText()) {
            this.hostElement.nativeElement['value'] = value;
        }
    }
}
PepTextboxValidationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[pepTextboxValidation]',
            },] }
];
PepTextboxValidationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: PepValidatorService }
];
PepTextboxValidationDirective.propDecorators = {
    type: [{ type: Input }],
    onChange: [{ type: HostListener, args: ['change', ['$event'],] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class PepTextboxModule {
    constructor(pepIconRegistry) {
        this.pepIconRegistry = pepIconRegistry;
        this.pepIconRegistry.registerIcons([pepIconSystemEdit]);
    }
}
PepTextboxModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    // Material modules,
                    MatCommonModule,
                    MatButtonModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatIconModule,
                    // ngx-lib modules
                    PepNgxLibModule,
                    PepIconModule,
                    PepFieldTitleModule,
                    PepTextboxIconModule,
                ],
                exports: [PepTextboxComponent],
                declarations: [PepTextboxComponent, PepTextboxValidationDirective],
            },] }
];
PepTextboxModule.ctorParameters = () => [
    { type: PepIconRegistry }
];

/*
 * Public API Surface of ngx-lib/textbox
 */

/**
 * Generated bundle index. Do not edit.
 */

export { PepTextboxComponent, PepTextboxModule, PepTextboxValidationDirective as ɵa };
//# sourceMappingURL=pepperi-addons-ngx-lib-textbox.js.map
