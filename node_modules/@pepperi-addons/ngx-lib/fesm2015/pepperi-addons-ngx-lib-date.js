import { Injectable, Optional, Inject, EventEmitter, Component, ChangeDetectionStrategy, ElementRef, Renderer2, Input, Output, ViewChild, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';
import { MAT_DATE_LOCALE, DateAdapter, MAT_DATE_FORMATS, MatCommonModule, MatNativeDateModule } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { DatetimeAdapter, MAT_DATETIME_FORMATS, MatDatetimepickerModule, MatNativeDatetimeModule } from '@mat-datetimepicker/core';
import { DEFAULT_HORIZONTAL_ALIGNMENT, PepDateField, PepCustomizationService, PepLayoutService, PepUtilitiesService, PepNgxLibModule } from '@pepperi-addons/ngx-lib';
import { pepIconSystemEdit, PepIconModule, PepIconRegistry } from '@pepperi-addons/ngx-lib/icon';
import { PepTextboxIconModule } from '@pepperi-addons/ngx-lib/textbox-icon';
import { PepFieldTitleModule } from '@pepperi-addons/ngx-lib/field-title';
import { utc } from 'moment/moment';
import { MomentDateAdapter } from '@angular/material-moment-adapter';
import { MomentDatetimeAdapter } from '@mat-datetimepicker/moment';

class MomentUtcDateAdapter extends MomentDateAdapter {
    constructor(dateLocale) {
        super(dateLocale);
    }
}
MomentUtcDateAdapter.decorators = [
    { type: Injectable }
];
MomentUtcDateAdapter.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_LOCALE,] }] }
];
class MomentUtcDateTimeAdapter extends MomentDatetimeAdapter {
    constructor(dateLocale) {
        super(dateLocale, { strict: false, useUtc: false }, new MomentUtcDateAdapter(dateLocale));
    }
}
MomentUtcDateTimeAdapter.decorators = [
    { type: Injectable }
];
MomentUtcDateTimeAdapter.ctorParameters = () => [
    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DATE_LOCALE,] }] }
];
const MY_DATE_FORMATS = {
    parse: {
        dateInput: 'L',
        monthInput: 'MMMM',
        timeInput: 'LT',
        datetimeInput: 'L LT',
    },
    display: {
        dateInput: 'L',
        monthInput: 'MMMM',
        timeInput: 'LT',
        datetimeInput: 'L LT',
        monthYearLabel: 'MMM YYYY',
        dateA11yLabel: 'LL',
        monthYearA11yLabel: 'MMMM YYYY',
        popupHeaderDateLabel: 'ddd, DD MMM',
    },
};

const ɵ0 = MY_DATE_FORMATS, ɵ1 = MY_DATE_FORMATS;
class PepDateComponent {
    constructor(adapter, element, layoutService, utilitiesService, customizationService, renderer) {
        this.adapter = adapter;
        this.element = element;
        this.layoutService = layoutService;
        this.utilitiesService = utilitiesService;
        this.customizationService = customizationService;
        this.renderer = renderer;
        this.key = '';
        this._value = '';
        this.formattedValue = '';
        this.label = '';
        this._type = 'date';
        this.mandatory = false;
        this.disabled = false;
        this.readonly = false;
        this.textColor = '';
        this.xAlignment = DEFAULT_HORIZONTAL_ALIGNMENT;
        this.rowSpan = 1;
        this._visible = true;
        this.controlType = 'date';
        this.form = null;
        this.isActive = false;
        this.showTitle = true;
        this.renderTitle = true;
        this.renderError = true;
        this.renderSymbol = true;
        this.layoutType = 'form';
        this.valueChange = new EventEmitter();
        this.standAlone = false;
        this.isInEditMode = false;
        this.showDatepicker = false;
        this.showTime = false;
    }
    set value(value) {
        this._value = value;
        this.setDateModel();
    }
    get value() {
        return this._value;
    }
    set type(type) {
        this._type = type;
        this.showTime = type === 'datetime';
    }
    get type() {
        return this._type;
    }
    set visible(visible) {
        this._visible = visible;
        if (visible) {
            this.renderer.removeClass(this.element.nativeElement, 'hidden-element');
        }
        else {
            this.renderer.addClass(this.element.nativeElement, 'hidden-element');
        }
    }
    get visible() {
        return this._visible;
    }
    // Minimum in thicks
    set minValue(value) {
        if (value > 0) {
            this.minDate = new Date(value * 1000 * 60 * 60 * 24);
        }
    }
    // Maximum in thicks
    set maxValue(value) {
        if (value > 0) {
            this.maxDate = new Date(value * 1000 * 60 * 60 * 24);
        }
    }
    // Minimum in date
    set minDateValue(date) {
        this.minDate = date ? new Date(date) : null;
    }
    // Maximum in date
    set maxDateValue(date) {
        this.maxDate = date ? new Date(date) : null;
    }
    setDefaultForm() {
        const pepField = new PepDateField({
            key: this.key,
            value: this.value,
            mandatory: this.mandatory,
            readonly: this.readonly,
            disabled: this.disabled,
        });
        this.form = this.customizationService.getDefaultFromGroup(pepField);
    }
    ngOnInit() {
        if (this.form === null) {
            this.standAlone = true;
            this.setDefaultForm();
            this.renderer.addClass(this.element.nativeElement, PepCustomizationService.STAND_ALONE_FIELD_CLASS_NAME);
        }
        const culture = this.layoutService.getCurrentLanguage();
        this.adapter.setLocale(culture);
        this.setDateModel();
    }
    ngOnChanges(changes) {
        if (this.standAlone) {
            this.setDefaultForm();
        }
    }
    ngOnDestroy() {
        //
    }
    setFormattedValueFromModel() {
        if (this.dateModel === null || !this.dateModel.isValid()) {
            this.formattedValue = '';
        }
        else {
            const format = this.showTime
                ? MY_DATE_FORMATS.display.datetimeInput
                : MY_DATE_FORMATS.display.dateInput;
            this.formattedValue = this.adapter.format(this.dateModel, format);
        }
    }
    setDateModel() {
        if (this.value === null ||
            this.value === '' ||
            this.value.indexOf('1900-1-1') >= 0 ||
            this.value.indexOf('1900-01-01') >= 0 ||
            this.value.indexOf('1970-1-1') >= 0 ||
            this.value.indexOf('1970-01-01') >= 0) {
            this._value = '';
            this.dateModel = null;
        }
        else {
            this.dateModel = utc(this.utilitiesService.parseDate(this.value, this.showTime));
        }
        this.setFormattedValueFromModel();
    }
    openDatetimePicker(datetimePicker) {
        datetimePicker.opened = false;
        datetimePicker.open();
    }
    onBlur(event) {
        // Don't remove the timeout cause a bug DI-17819.
        setTimeout(() => {
            if (this.isInEditMode && !this.datetimePicker.opened) {
                this.isInEditMode = false;
            }
        }, 0);
    }
    onDateChange(event) {
        let value = '';
        if (event.value != null) {
            const date = event.value.toDate();
            value = this.utilitiesService.stringifyDate(date, this.showTime);
            // Update the formatted value.
            this.setFormattedValueFromModel();
        }
        this.customizationService.updateFormFieldValue(this.form, this.key, 
        // this.formattedValue
        value);
        this.valueChange.emit(value);
        setTimeout(() => {
            if (this.isInEditMode) {
                this.isInEditMode = false;
            }
        }, 0);
    }
    cardTemplateClicked(event) {
        this.isInEditMode = true;
        setTimeout(() => {
            this.input.nativeElement.focus();
            this.openDatetimePicker(this.datetimePicker);
        }, 0);
    }
}
PepDateComponent.decorators = [
    { type: Component, args: [{
                selector: 'pep-date',
                template: "<ng-container [formGroup]=\"form\">\n    <ng-template #pepTemplate let-showIcon=\"showIcon\">\n        <mat-form-field appearance=\"outline\">\n            <input #input [id]=\"key\" title=\"{{ formattedValue }}\" matInput class=\"body-sm\" autocomplete=\"false\"\n                [ngStyle]=\"{ color: textColor, 'text-align': xAlignment == 'center' ? 'center' : xAlignment == 'right' ? 'right' : 'left'}\"\n                [(ngModel)]=\"dateModel\" [ngModelOptions]=\"{standalone: true}\" [matDatetimepicker]=\"datetimePicker\"\n                [min]=\"minDate\" [max]=\"maxDate\" [required]=\"mandatory\" [disabled]=\"disabled\"\n                (dateChange)=\"onDateChange($event)\" (click)=\"openDatetimePicker(datetimePicker)\"\n                (blur)=\"onBlur($event)\" />\n            <mat-error *ngIf=\"renderError\"><span class=\"body-xs\"\n                    [title]=\"mandatory && formattedValue.length == 0 ? ('MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}) : ('MESSAGES.ERROR_IS_NOT_VALID' | translate: {field: label})\"\n                    [innerText]=\"mandatory && formattedValue.length == 0 ? ('MESSAGES.ERROR_IS_REQUIRED' | translate: {field: label}) : ('MESSAGES.ERROR_IS_NOT_VALID' | translate: {field: label})\"></span>\n            </mat-error>\n            <pep-textbox-icon *ngIf=\"renderSymbol && showIcon && xAlignment == 'right'\" matPrefix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\" (iconClick)=\"openDatetimePicker(datetimePicker)\">\n            </pep-textbox-icon>\n            <pep-textbox-icon *ngIf=\"renderSymbol && showIcon && xAlignment == 'left'\" matSuffix [value]=\"value\"\n                [label]=\"label\" [type]=\"type\" [disabled]=\"disabled\" (iconClick)=\"openDatetimePicker(datetimePicker)\">\n            </pep-textbox-icon>\n            <mat-datetimepicker #datetimePicker [type]=\"showTime ? 'datetime' : 'date'\" [openOnFocus]=\"false\"\n                [touchUi]=\"true\" [timeInterval]=\"1\"></mat-datetimepicker>\n        </mat-form-field>\n    </ng-template>\n\n    <ng-container *ngIf=\"layoutType === 'form'\">\n        <pep-field-title *ngIf=\"renderTitle\" [label]=\"label\" [mandatory]=\"mandatory\" [disabled]=\"disabled\"\n            [xAlignment]=\"xAlignment\" [showTitle]=\"showTitle\">\n        </pep-field-title>\n        <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: true}\"></ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'card'\">\n        <ng-container *ngIf=\"isInEditMode; then editBlock; else readOnlyBlock\"></ng-container>\n        <ng-template #editBlock>\n            <div [ngClass]=\"{'one-row': rowSpan === 1}\">\n                <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: false}\"></ng-container>\n            </div>\n        </ng-template>\n        <ng-template #readOnlyBlock>\n            <div class=\"pep-card-input card-flex-container\"\n                [ngClass]=\"{'one-row': rowSpan === 1, 'pep-button weak': isActive && !disabled }\"\n                [ngStyle]=\"{ color: textColor }\" [class]=\"'text-align-' + xAlignment\"\n                (click)=\"!disabled ? cardTemplateClicked($event) : ''\">\n                <span *ngIf=\"showTitle && label != ''\" class=\"body-xs title\" title=\"{{ label }}\">{{ label\n                    }}&nbsp;</span>\n                <span [id]=\"key\" title=\"{{ formattedValue }}\" class=\"body-sm value\">{{ formattedValue }}</span>\n                <button *ngIf=\"isActive && !disabled\" class=\"pep-button weak card-edit-button\" mat-button>\n                    <mat-icon>\n                        <pep-icon name=\"system_edit\">\n                        </pep-icon>\n                    </mat-icon>\n                </button>\n            </div>\n        </ng-template>\n    </ng-container>\n\n    <ng-container *ngIf=\"layoutType === 'table'\">\n        <ng-container *ngIf=\"isActive && !disabled; then selectedBlock; else notSelectedBlock\"></ng-container>\n        <ng-template #selectedBlock>\n            <ng-container *ngTemplateOutlet=\"pepTemplate; context: {showIcon: true}\"></ng-container>\n        </ng-template>\n        <ng-template #notSelectedBlock>\n            <ng-container *ngIf=\"formattedValue?.length > 0; then notEmptyBlock; else emptyBlock\"></ng-container>\n            <ng-template #notEmptyBlock>\n                <ng-container [ngSwitch]=\"type\">\n                    <ng-container *ngSwitchDefault>\n                        <span [id]=\"key\" class=\"body-sm pep-report-input\" [ngStyle]=\"{ color: textColor }\"\n                            [ngClass]=\"{readonly: disabled}\" title=\"{{ formattedValue }}\">{{ formattedValue }}</span>\n                    </ng-container>\n                </ng-container>\n            </ng-template>\n            <ng-template #emptyBlock>\n                <span [id]=\"key\">&nbsp;</span>\n            </ng-template>\n        </ng-template>\n    </ng-container>\n</ng-container>",
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    // CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR,
                    // The locale would typically be provided on the root module of your application. We do it at
                    // the component level here, due to limitations of our example generation script.
                    //{ provide: MAT_DATE_LOCALE, useValue: 'en-US' },
                    // `MomentDateAdapter` and `MAT_MOMENT_DATE_FORMATS` can be automatically provided by importing
                    // `MatMomentDateModule` in your applications root module. We provide it at the component level
                    // here, due to limitations of our example generation script.
                    //{ provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    //{ provide: MAT_DATE_FORMATS, useValue: MAT_MOMENT_DATE_FORMATS },
                    { provide: DateAdapter, useClass: MomentUtcDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 },
                    { provide: DatetimeAdapter, useClass: MomentUtcDateTimeAdapter },
                    //{ provide: MAT_DATETIME_FORMATS, useValue: MAT_NATIVE_DATETIME_FORMATS }
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1 },
                ],
                styles: [":host{height:inherit;display:grid}:host>*{align-self:center}"]
            },] }
];
PepDateComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: ElementRef },
    { type: PepLayoutService },
    { type: PepUtilitiesService },
    { type: PepCustomizationService },
    { type: Renderer2 }
];
PepDateComponent.propDecorators = {
    key: [{ type: Input }],
    value: [{ type: Input }],
    formattedValue: [{ type: Input }],
    label: [{ type: Input }],
    type: [{ type: Input }],
    mandatory: [{ type: Input }],
    disabled: [{ type: Input }],
    readonly: [{ type: Input }],
    textColor: [{ type: Input }],
    xAlignment: [{ type: Input }],
    rowSpan: [{ type: Input }],
    visible: [{ type: Input }],
    minValue: [{ type: Input }],
    maxValue: [{ type: Input }],
    minDateValue: [{ type: Input }],
    maxDateValue: [{ type: Input }],
    form: [{ type: Input }],
    isActive: [{ type: Input }],
    showTitle: [{ type: Input }],
    renderTitle: [{ type: Input }],
    renderError: [{ type: Input }],
    renderSymbol: [{ type: Input }],
    layoutType: [{ type: Input }],
    valueChange: [{ type: Output }],
    datetimePicker: [{ type: ViewChild, args: ['datetimePicker',] }],
    input: [{ type: ViewChild, args: ['input',] }]
};

class PepDateModule {
    constructor(pepIconRegistry) {
        this.pepIconRegistry = pepIconRegistry;
        this.pepIconRegistry.registerIcons([pepIconSystemEdit]);
    }
}
PepDateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule,
                    FormsModule,
                    // Material modules,
                    MatCommonModule,
                    MatButtonModule,
                    MatNativeDateModule,
                    MatDatepickerModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule,
                    MatFormFieldModule,
                    MatInputModule,
                    MatIconModule,
                    // ngx-lib modules
                    PepNgxLibModule,
                    PepIconModule,
                    PepFieldTitleModule,
                    PepTextboxIconModule,
                ],
                exports: [PepDateComponent],
                declarations: [PepDateComponent],
            },] }
];
PepDateModule.ctorParameters = () => [
    { type: PepIconRegistry }
];

/*
 * Public API Surface of ngx-lib/date
 */

/**
 * Generated bundle index. Do not edit.
 */

export { PepDateComponent, PepDateModule, ɵ0, ɵ1, MomentUtcDateAdapter as ɵa, MomentUtcDateTimeAdapter as ɵb, MY_DATE_FORMATS as ɵc };
//# sourceMappingURL=pepperi-addons-ngx-lib-date.js.map
